{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"themes/remind/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/ben.styl","path":"css/ben.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/code.styl","path":"css/code.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/footer.styl","path":"css/footer.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/functions.styl","path":"css/functions.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/heading.styl","path":"css/heading.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/nav.styl","path":"css/nav.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/post.styl","path":"css/post.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/sidebar.styl","path":"css/sidebar.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/tags.styl","path":"css/tags.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/remind/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/remind/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/remind/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/remind/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/remind/source/js/responsive.js","path":"js/responsive.js","modified":1,"renderable":1},{"_id":"themes/remind/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/remind/source/css/images/me.jpg","path":"css/images/me.jpg","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"themes/remind/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","path":"img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","path":"img/header_img/reed-xia-790819-unsplash.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/forrest.jpeg","path":"img/header_img/forrest.jpeg","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1546580545361},{"_id":"source/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1546580545361},{"_id":"themes/remind/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1546580545533},{"_id":"themes/remind/_config.yml","hash":"73d6de4ce5696e8cc20eb8c3b9ad36006095e82d","modified":1548235683074},{"_id":"source/_posts/2018-12-20-gulp-series-1.md","hash":"87cd505fb3cae85180b28ed52684beded34b2a2e","modified":1546580545361},{"_id":"source/_posts/2018-12-26-gulp-series-2-glob.md","hash":"a2086bfc28c2ceb4225eb19064b9c24b564a1d2d","modified":1546580545362},{"_id":"source/_posts/2018-12-29-summary-of-2018.md","hash":"161160ab8810ea875dae818680bf63f4d789b807","modified":1546580545362},{"_id":"source/_posts/2019-01-08-what-web-cannot-do.md","hash":"02a3a9bcaf2abe2c5f1d111db2799153fd7d8da0","modified":1548235683037},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl.md","hash":"a2f94c6b46fcacd9ffe152743ec3644d9bbe855e","modified":1548235683064},{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design.md","hash":"1ec005d3e64d7cd938271a24f29b083f80a5dcbc","modified":1548236332577},{"_id":"source/_posts/about-file-upload-1.md","hash":"a0983652d42511ae4315a4dad7b42848a596a971","modified":1546580545371},{"_id":"source/_posts/get-started-ejs.md","hash":"edb5e3bddf7eeceb73b3ee5660f74b947d3bdf41","modified":1546580545381},{"_id":"source/_posts/get-started-of-golang-with-mongodb.md","hash":"3993d7c9a7f7c216182cce875e98ef98514bdf2f","modified":1546580545381},{"_id":"source/_posts/golang-package-etc.md","hash":"84028c24adf16ab23a1684f25e6b53e76f969c9e","modified":1546580545382},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","hash":"5b44ff6b70cd69dcbc3252d83378b249647b5d1b","modified":1546580545392},{"_id":"source/about/index.md","hash":"016bf0fe230f4d15343355984c5f325c8860e35e","modified":1548235683071},{"_id":"source/archive/index.md","hash":"8aae18ca407df5101dd31957068be67b799d29e4","modified":1548235683071},{"_id":"source/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1546580545533},{"_id":"source/tags/index.md","hash":"e79b7dc92303106ae14f4333f2c6d0278923a8eb","modified":1548235683074},{"_id":"themes/remind/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1546580545534},{"_id":"themes/remind/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1546580545534},{"_id":"themes/remind/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1546580545534},{"_id":"themes/remind/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1546580545534},{"_id":"themes/remind/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1546580545534},{"_id":"themes/remind/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1546580545535},{"_id":"themes/remind/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1546580545535},{"_id":"themes/remind/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1546580545535},{"_id":"themes/remind/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1546580545535},{"_id":"themes/remind/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1546580545535},{"_id":"themes/remind/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1546580545538},{"_id":"themes/remind/layout/archive.ejs","hash":"2a3582a1c24c1f7f6b55d0e794d8ae62bdae0dc1","modified":1548235683075},{"_id":"themes/remind/layout/index.ejs","hash":"f3f531d43e43904c2f8cc1e33d187d7304a3dc6b","modified":1546580545538},{"_id":"themes/remind/layout/keynote.ejs","hash":"7fe853b7bbcaa45f8b770314484df46d6871ed58","modified":1546580545539},{"_id":"themes/remind/layout/layout.ejs","hash":"9df05fc62dd09934e6b641216c1914c1a4cd1bb1","modified":1546580545539},{"_id":"themes/remind/layout/page.ejs","hash":"c86377e2105b5bc902d3b52843c94d6fffe22763","modified":1546580545539},{"_id":"themes/remind/layout/post.ejs","hash":"fdedac1bdc6c3131602358fc428d1cb1a4660cff","modified":1548235683076},{"_id":"themes/remind/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1546580545540},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","hash":"094b871e1da4b46b467a26225ff98a63e3602667","modified":1548235683064},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/chrome-extension-tinyurl.jpg","hash":"1e8d2043d3e1c0a50951f2538985bf9be6f69191","modified":1548235683065},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1546580545398},{"_id":"themes/remind/layout/_partial/footer.ejs","hash":"73a601a6461d5ea31df48ef29e76b1d3ce64980d","modified":1546580545536},{"_id":"themes/remind/layout/_partial/head.ejs","hash":"e535b5adae5bca4d8f323c90ee65b3136c5876a5","modified":1548235683075},{"_id":"themes/remind/layout/_partial/header.ejs","hash":"5eec4ed0a92f3ee18cb39bb6484c2b926abf88eb","modified":1548235683075},{"_id":"themes/remind/layout/_partial/nav.ejs","hash":"2e6ea7a44e52c6e8a7ccca0022b28c1104894b44","modified":1548235683075},{"_id":"themes/remind/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1546580545536},{"_id":"themes/remind/layout/_partial/sidebar.ejs","hash":"7dc6f10f25981b1f1f0cc2f286f83592ec62a0cf","modified":1546580545536},{"_id":"themes/remind/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1546580545537},{"_id":"themes/remind/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1546580545536},{"_id":"themes/remind/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1546580545537},{"_id":"themes/remind/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1546580545537},{"_id":"themes/remind/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1546580545537},{"_id":"themes/remind/layout/_widget/recent-posts.ejs","hash":"2c2568ac58911a9060923a452394a8120cbb7990","modified":1546580545537},{"_id":"themes/remind/layout/_widget/short-about.ejs","hash":"a92fca2283f5b6b8ca7b6610896b7cbbdc353d44","modified":1546580545538},{"_id":"themes/remind/source/css/archive.styl","hash":"9beb0218f199e99a87a7c7a6b49281e641c46ecb","modified":1546580545540},{"_id":"themes/remind/source/css/ben.styl","hash":"ce1e2a1519523b170b7fb7f3e84cd7ca4e9f201f","modified":1548235683076},{"_id":"themes/remind/source/css/code.styl","hash":"1b6e2d47cdef7ad2c1a6636295bb992be85d2859","modified":1548235683077},{"_id":"themes/remind/source/css/footer.styl","hash":"4a3cf01128497cbf42f6be951d7b9ce0bc54cff3","modified":1546580545541},{"_id":"themes/remind/source/css/functions.styl","hash":"556a84b983e0fb6d0a1622bf3b9f0cdb3b01fac7","modified":1548235683077},{"_id":"themes/remind/source/css/heading.styl","hash":"e9e33a1250093bc9be10f88bbb555bb00c5f3d44","modified":1548235683078},{"_id":"themes/remind/source/css/nav.styl","hash":"137cd21153236a6990b215ddfbf4bca629125789","modified":1548235683078},{"_id":"themes/remind/source/css/post.styl","hash":"4004934643608202d77a179d384165c39bc9e71f","modified":1548235683079},{"_id":"themes/remind/source/css/sidebar.styl","hash":"0cc689803378c7e8da6cf422e4f77b490741e5a3","modified":1546580545543},{"_id":"themes/remind/source/css/tags.styl","hash":"82230349134f9f8d4d60ee773a637c5d75aee7e4","modified":1548235683079},{"_id":"themes/remind/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1546580545543},{"_id":"themes/remind/source/css/variables.styl","hash":"0500f800b3816d4d3b8ebfd158dfbc4a404a7f16","modified":1548235683080},{"_id":"themes/remind/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1546580545544},{"_id":"themes/remind/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1546580545550},{"_id":"themes/remind/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1546580545551},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1546580545544},{"_id":"themes/remind/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1546580545551},{"_id":"themes/remind/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1546580545552},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1546580545546},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1546580545546},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1546580545547},{"_id":"themes/remind/source/js/responsive.js","hash":"a32f0a550cbf0a679e49f6d286afa7c513912274","modified":1548235683080},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/cache-api-browser-compatibility.PNG","hash":"4957ba0d3f993035281b5cc03e606c0f99332dd9","modified":1548235683038},{"_id":"themes/remind/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546580545550},{"_id":"themes/remind/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1546580545545},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1546580545390},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1546580545393},{"_id":"themes/remind/source/css/images/me.jpg","hash":"707dfb5299ac612d6a762ad7012dcb5d65560720","modified":1546580545542},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1546580545391},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1546580545407},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1546580545532},{"_id":"themes/remind/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1546580545549},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1546580545395},{"_id":"source/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","hash":"4fb2c727df4e148ca7eb6271741c51e06fef3e64","modified":1548235683074},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1546580545525},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/iPad-Mini-iPhone.jpg","hash":"b0a26f4497c528d29af9482dbfbbf7864946a381","modified":1548235683070},{"_id":"source/_posts/2018-12-29-summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","hash":"faa6adeb7ab81fa49c68e6f672e40ecac2174f50","modified":1546580545370},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1546580545530},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/header.jpg","hash":"238b28f52e4ade27b1fc8dd6ecc8b9f8a5598eb7","modified":1548235683047},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1546580545388},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/s-b-vonlanthen-546859-unsplash.jpg","hash":"02d03917a2ececac9e5c734aecae969064ef0648","modified":1548235683063},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1546580545380},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1546580545418},{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","hash":"a0d4f84c0b7eb1402063de408ba569814859908b","modified":1548236218677},{"_id":"source/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1546580545503},{"_id":"public/post-sitemap.xml","hash":"49b32c2f04c7b8bbc84b809930beaba799b530b3","modified":1548236364736},{"_id":"public/page-sitemap.xml","hash":"d26cf54a73ea3895d6b5283eebcd25b3c86fa733","modified":1548236364736},{"_id":"public/tag-sitemap.xml","hash":"5aebfc798b1a3b5d8af8e1cfb7e3baf53d2150b5","modified":1548236365086},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1548236365086},{"_id":"public/sitemap.xml","hash":"4a139411843aed71c9ba7e5f232142ece42038f1","modified":1548236365153},{"_id":"public/404.html","hash":"e3507b867cd0811cb27b9f26dee0e45c961bf535","modified":1548236365197},{"_id":"public/2018/02/02/get-started-of-golang-with-mongodb/index.html","hash":"3e19747fc462c1c51236032a6f5b0905de762c7c","modified":1548236365200},{"_id":"public/archive/index.html","hash":"2f3f5996011819a991854e16eff64ef54a03c803","modified":1548236365319},{"_id":"public/about/index.html","hash":"b0ea43c82ac017a7900c9e1bcb9588e64b9a64bf","modified":1548236365320},{"_id":"public/archives/index.html","hash":"92d5ea0e74b2951665b8fab003d907d3ef0854ae","modified":1548236365387},{"_id":"public/archives/2015/index.html","hash":"ce3a2b8a02a78553e654bcf701987ea74354ab51","modified":1548236365387},{"_id":"public/archives/2018/index.html","hash":"eecbd102efaa1be17e15a557dfd6999b2f9c21a5","modified":1548236365390},{"_id":"public/archives/2015/11/index.html","hash":"43e7414061352e042512f50877aa8ed2f46189f5","modified":1548236365390},{"_id":"public/archives/2018/06/index.html","hash":"dc5fb9c39cf9e87deca20caf563841aa63cc130c","modified":1548236365390},{"_id":"public/archives/2018/12/index.html","hash":"7f89c4afb4c98a3031b00041db5d7ad87e15da77","modified":1548236365390},{"_id":"public/index.html","hash":"d8b7b507133e14ff69371217f702c81dc07ed4f7","modified":1548236365390},{"_id":"public/archives/2018/02/index.html","hash":"cf4fa2406f67d8516d09bd3f8c1386ef12b464ae","modified":1548236365390},{"_id":"public/tags/gulp/index.html","hash":"d8e9fcf02d923b06bf5dcba4b9d6da7ef4b58453","modified":1548236365390},{"_id":"public/tags/前端工程/index.html","hash":"085d85c5d8be4a14c114fbf973464601cfc3b08e","modified":1548236365390},{"_id":"public/tags/index.html","hash":"2dd0f4dc826358ca454c520fe57e2b3be768b852","modified":1548236365390},{"_id":"public/2018/12/29/summary-of-2018/index.html","hash":"938a2850d246806f1759e6b8ec6b6ee5d518d3a4","modified":1548236365390},{"_id":"public/2018/12/20/gulp-series-1/index.html","hash":"0033d97775c763a525f88735390ab5e3ffb11bd3","modified":1548236365391},{"_id":"public/2018/12/26/gulp-series-2-glob/index.html","hash":"a336d980ed3ff42c0fa7351d273124d0c39c50fd","modified":1548236365391},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/index.html","hash":"de2975b45ff57d4e15fccefb3780eaa9d7dc4895","modified":1548236365391},{"_id":"public/2018/02/05/golang-package-etc/index.html","hash":"a2946948331fd30741527a5a62212440c3b53a75","modified":1548236365391},{"_id":"public/2015/11/20/about-file-upload-1/index.html","hash":"6ece428106e4812fb48a5bb4876f85608e803012","modified":1548236365391},{"_id":"public/2018/02/02/get-started-ejs/index.html","hash":"3ca2bc2a99c06607fac46307e2344cf1653d20bc","modified":1548236365391},{"_id":"public/2019/01/11/start-to-use-tinyurl/index.html","hash":"87d49db74ab2b18953d2d2bf467651512ebcdd47","modified":1548236365401},{"_id":"public/archives/archives/2/index.html","hash":"16bbac768ff4aa315b40f3ff1e3b11b944bc8358","modified":1548236365401},{"_id":"public/archives/2019/index.html","hash":"dd9d800e5085227bf58548d80c79412424f92104","modified":1548236365401},{"_id":"public/archives/2019/01/index.html","hash":"03dd0d403aa62e3a41a3c46994532ca9dff2c9ac","modified":1548236365401},{"_id":"public/archives/2/index.html","hash":"48bcbbe8afac34a0870cf82116e4647e6d833fde","modified":1548236365401},{"_id":"public/tags/web-app/index.html","hash":"551c154dd1922565f050e3240ec4d9da35b02402","modified":1548236365401},{"_id":"public/tags/pwa/index.html","hash":"335dac72345db6ca300f4393ef964585631b424f","modified":1548236365401},{"_id":"public/tags/hybrid-app/index.html","hash":"f5c52fb3b3bbaed1530f0debfb526bf903b13437","modified":1548236365401},{"_id":"public/tags/tiny-url/index.html","hash":"48f04820259445fc908b04de5cffbc909ff830e2","modified":1548236365401},{"_id":"public/tags/url-shortener/index.html","hash":"f19430384f0b3aa3c521c56c4e4a5d2be93f3a3a","modified":1548236365401},{"_id":"public/tags/小程序/index.html","hash":"a1608177d3869da2923e4d7a812d74dfd94b356a","modified":1548236365402},{"_id":"public/tags/restful-api/index.html","hash":"3c6feb00fc9bdc95c18f8f4f0e610a814e27c61e","modified":1548236365402},{"_id":"public/tags/文件上传/index.html","hash":"d5fce66ccb22a34f3092482e3dfa8ae26a4bd610","modified":1548236365402},{"_id":"public/tags/ejs/index.html","hash":"6ca56feec42908f9a12cf64d1ab651655b938601","modified":1548236365402},{"_id":"public/tags/思考/index.html","hash":"9929ef01a0e92d672e1acd14e768c33a01686beb","modified":1548236365402},{"_id":"public/tags/micro-service/index.html","hash":"cd31555df1b19b7ccd0b267dab8a0fec69899182","modified":1548236365402},{"_id":"public/tags/模板引擎/index.html","hash":"531f7f4dced87bbb72f5850e6ad206b5f3b67075","modified":1548236365403},{"_id":"public/tags/沟通能力/index.html","hash":"c02a9a035fd438419286b8fd164ba5790a473052","modified":1548236365403},{"_id":"public/tags/总结/index.html","hash":"f4bd3372469f186b0e5c665cb8c64545fc42d181","modified":1548236365404},{"_id":"public/tags/职业发展/index.html","hash":"5fc6b08418e555b17c1c466d7702613cd5fdcd95","modified":1548236365404},{"_id":"public/tags/http/index.html","hash":"9d74f1ecaffe0a0958121d0267a06d93290b3f85","modified":1548236365404},{"_id":"public/2019/01/23/three-points-of-restful-api-design/index.html","hash":"8a9c438b59bf3549276034cdcba1679c86032766","modified":1548236365404},{"_id":"public/2019/01/08/what-web-cannot-do/index.html","hash":"e7e0fc195969b694f0323015b6be1dcf4965b35d","modified":1548236365404},{"_id":"public/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1548236365417},{"_id":"public/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1548236365417},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1548236365417},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1548236365417},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1548236365417},{"_id":"public/css/images/me.jpg","hash":"707dfb5299ac612d6a762ad7012dcb5d65560720","modified":1548236365417},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1548236365417},{"_id":"public/2019/01/08/what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","hash":"094b871e1da4b46b467a26225ff98a63e3602667","modified":1548236365417},{"_id":"public/2019/01/11/start-to-use-tinyurl/chrome-extension-tinyurl.jpg","hash":"1e8d2043d3e1c0a50951f2538985bf9be6f69191","modified":1548236365418},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1548236365754},{"_id":"public/2019/01/08/what-web-cannot-do/cache-api-browser-compatibility.PNG","hash":"4957ba0d3f993035281b5cc03e606c0f99332dd9","modified":1548236365755},{"_id":"public/css/archive.css","hash":"f3e2c93dc634f2350320587230bf8107fb644c53","modified":1548236365761},{"_id":"public/css/heading.css","hash":"146f52667604998cd2e6e969464f78e405123228","modified":1548236365761},{"_id":"public/css/footer.css","hash":"c366b85ea7279fbc3f7f521ba4a1081f5c1307f9","modified":1548236365761},{"_id":"public/css/sidebar.css","hash":"ad8b2047bda8017a83db9a856e32586f5f2053d5","modified":1548236365761},{"_id":"public/css/functions.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548236365761},{"_id":"public/css/ben.css","hash":"fcc90b80164cdcf2d9fa6635ebb8cca3e56738bc","modified":1548236365761},{"_id":"public/css/tags.css","hash":"b55fa347c559feccc601e5627a2f56c85d136d7d","modified":1548236365761},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548236365761},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1548236365761},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1548236365761},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1548236365762},{"_id":"public/css/post.css","hash":"390deaeb6f97386efbd0ae185274448c3b738b59","modified":1548236365762},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1548236365762},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1548236365762},{"_id":"public/js/responsive.js","hash":"14187e54920ec3b6f818f82432b232acf7a78035","modified":1548236365762},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1548236365762},{"_id":"public/css/nav.css","hash":"bb8f7fc1a12f8cd675d191c15a14c44f0c548c17","modified":1548236365762},{"_id":"public/css/code.css","hash":"0bfee69d219ba95945852df709759e4cee38f6e0","modified":1548236365762},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1548236365762},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1548236365774},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1548236365774},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1548236365774},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1548236365774},{"_id":"public/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","hash":"4fb2c727df4e148ca7eb6271741c51e06fef3e64","modified":1548236365774},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1548236365804},{"_id":"public/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1548236365815},{"_id":"public/2019/01/11/start-to-use-tinyurl/iPad-Mini-iPhone.jpg","hash":"b0a26f4497c528d29af9482dbfbbf7864946a381","modified":1548236365815},{"_id":"public/2018/12/29/summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","hash":"faa6adeb7ab81fa49c68e6f672e40ecac2174f50","modified":1548236365820},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1548236365839},{"_id":"public/2019/01/08/what-web-cannot-do/header.jpg","hash":"238b28f52e4ade27b1fc8dd6ecc8b9f8a5598eb7","modified":1548236365843},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1548236365855},{"_id":"public/2015/11/20/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1548236365856},{"_id":"public/2019/01/08/what-web-cannot-do/s-b-vonlanthen-546859-unsplash.jpg","hash":"02d03917a2ececac9e5c734aecae969064ef0648","modified":1548236365860},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1548236365869},{"_id":"public/2019/01/23/three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","hash":"a0d4f84c0b7eb1402063de408ba569814859908b","modified":1548236365894},{"_id":"public/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1548236365952}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-01-04T05:42:25.361Z","updated":"2019-01-04T05:42:25.361Z","path":"404.html","title":"","comments":1,"_id":"cjr8zycsi0000dwx7sbi573zs","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"关于我","icon":"fa-user","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/reed-xia-790819-unsplash.jpg","comments":1,"_content":"\n\n图片来自：Photo by Reed Xia on Unsplash\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于我\"\nicon: fa-user # the font awesome icon used for this page\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img:  \"img/header_img/reed-xia-790819-unsplash.jpg\"\ncomments: true\n---\n\n\n图片来自：Photo by Reed Xia on Unsplash\n\n","updated":"2019-01-23T09:28:03.071Z","path":"about/index.html","_id":"cjr8zycu90002dwx7dv0khbzk","content":"<p>图片来自：Photo by Reed Xia on Unsplash</p>\n","site":{"data":{}},"excerpt":"","more":"<p>图片来自：Photo by Reed Xia on Unsplash</p>\n"},{"layout":"archive","title":"归档","icon":"fa-folder","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"归档\"\nicon: fa-folder # the font awesome icon used for this page\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-01-23T09:28:03.071Z","path":"archive/index.html","_id":"cjr8zycud0004dwx7c6lupyll","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"标签","icon":"fa-flag","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"标签\"\nicon: fa-flag # the font awesome icon used for this page\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2019-01-23T09:28:03.074Z","updated":"2019-01-23T09:28:03.074Z","path":"tags/index.html","comments":1,"_id":"cjr8zycun0007dwx7oc6j19nr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"gulp 拾遗 - nodejs/配置文件/环境变量","catalog":true,"date":"2018-12-20T06:38:57.000Z","subtitle":"在学习之前，有必要夯实基础","header-img":null,"_content":"## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","source":"_posts/2018-12-20-gulp-series-1.md","raw":"---\ntitle: gulp 拾遗 - nodejs/配置文件/环境变量\ncatalog: true\ndate: 2018-12-20 14:38:57\nsubtitle: 在学习之前，有必要夯实基础\nheader-img: \ntags: [gulp,前端工程]\n---\n## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","slug":"gulp-series-1","published":1,"updated":"2019-01-04T05:42:25.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycu30001dwx709vokp33","content":"<h2><span id=\"楔子\">楔子</span></h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2><span id=\"nodejs\">Nodejs</span></h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"gulp-任务\">gulp 任务</span></h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"配制文件\">配制文件</span></h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2><span id=\"环境变量\">环境变量</span></h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>楔子</h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2>Nodejs</h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2>gulp 任务</h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2>配制文件</h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2>环境变量</h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2>总结</h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n"},{"title":"gulp 拾遗 (2) - 认识 glob","catalog":true,"date":"2018-12-26T09:05:16.000Z","subtitle":"一直纠结于书写各种文件查找脚本，直到遇见 glob","header-img":null,"_content":"# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","source":"_posts/2018-12-26-gulp-series-2-glob.md","raw":"---\ntitle: gulp 拾遗 (2) - 认识 glob \ncatalog: true\ndate: 2018-12-26 17:05:16\nsubtitle: 一直纠结于书写各种文件查找脚本，直到遇见 glob\nheader-img:\ntags: [gulp,前端工程]\n---\n# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","slug":"gulp-series-2-glob","published":1,"updated":"2019-01-04T05:42:25.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycub0003dwx7h1tzbdsq","content":"<h1><span id=\"为什么要用-glob\">为什么要用 glob</span></h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1><span id=\"node-glob\">node-glob</span></h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"pattern\">pattern</span></h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2><span id=\"options\">options</span></h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3><span id=\"cwd\">cwd</span></h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3><span id=\"ignore\">ignore</span></h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1><span id=\"gulp-中的-glob\">gulp 中的 glob</span></h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1><span id=\"其他脚本中的-glob\">其他脚本中的 glob</span></h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1><span id=\"总结\">总结</span></h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>为什么要用 glob</h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1>node-glob</h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2>pattern</h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2>options</h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3>cwd</h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3>ignore</h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1>gulp 中的 glob</h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1>其他脚本中的 glob</h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1>总结</h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n"},{"title":"震惊，web app 不能做的 N 件事","catalog":true,"date":"2019-01-08T08:45:37.000Z","subtitle":null,"header-img":"header.jpg","_content":"大概四五年前，我离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 **java** 。虽然在此之前， 我的所有 **java** 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。\n\n当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”\n\n如果不是后来阴差阳错，又转而做起了 **js**，我的人生可能又会是另一番模样。谁知道呢？\n\n# 和 js 的缘分\n\n参加工作以来，经历过两段**闲的蛋疼**的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。\n\n![phone.jpg](samsung-galaxy-mini-s5570.jpg)\n\n第二段则是在第二家公司，也就是那家中国公司。\n\n进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 **tab**，**dropdown** ，当然顺便也学了 **html** 和 **css** 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 **java** 写工具，深知 **layout** 和 **event listener** 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：\n\n![happy.jpg](s-b-vonlanthen-546859-unsplash.jpg)\n\n从此以后，我就“义无反顾”的加入了前端大军。\n\n同时，因为玩的比较多，所以早早就了解到 js 的各种限制，或者说是浏览器环境的诸多限制，譬如不能访问系统资源（本地文件），不能跨域访问资源，等等。但是，这点瑕疵丝毫不能熄灭我对 js 的热爱。\n\n# web app 的优势\n上面扯了一大段，大部分没有任何价值，只是写着写着情绪到了。哈哈。\n\n我理解的 **web app** 其实就是传统网站的一种变体。网站是以内容为主，交互为辅，而 web app 则两者平衡（比如**知乎**），甚至有些以交互为主（比如 teambition）。相对于**native app**，web app 的优势是低成本跨平台，free publish（相比 android app 和 ios app 的发布审核），开发成本相对较低。\n\n这里插一句：很多不懂技术被忽悠的进坑，大多是因为轻信了上面的好处。\n\n> 跨频台 -> 更少的开发和测试 -> 更低的成本\n\n套用一句话：**没有银弹**。你得到的多，付出的自然要更多。享受 web app 好处的同时，你不得不接受它的缺陷。\n\n# web app 的劣势，解决办法\n\nweb app 依赖浏览器来提供运行环境，相应的，也受制于浏览器的诸多限制。\n\n1. 不能自由的访问本地资源。举个例子，浏览器不允许 js 访问用户文件，那很多基于本地存储的功能（缓存，下载，上传）就做不了。\n2. 依赖网络。native app 可以离线工作，web app 却不能。\n3. 安全问题。任何人都能查看你的代码，以及各种 storeage。\n4. performance。web app 的优化只能止于浏览器，相对的，native app 可以做系统级别的优化。\n\n针对以上缺陷，很多大厂使用 **hybrid app** 技术 - 可以理解为 **web app in native container**。外层容器使用 native 语言开发，内部则加载 web app。容器赋予 web app 诸如文件系统等浏览器不具备的服务，而 web app 则承担复杂多变的业务逻辑和用户界面。\n\n# 低成本方案\n玩转 hybrid app 的成本太高，毕竟，你的开发团队需要两种技术人才，一种做 container，一种做 web。好在还有一些免费开源的 container 可以用，比如 [cordova](https://cordova.apache.org/), [electron](https://electronjs.org/)。\n\n可能，某些项目并不需要以上这样**全面**的方案。\n**老子只想要流线使用而已啊，说这么多干什么啊魂淡？！**\n**就不能发明一种只要开开心心写代码完全不用操心操作系统的ide吗？！**\n\n好，我们继续。上小程序。\n\n## 小程序\n过去的一年，很多大厂的**小程序**开始崭露头角。以微信小程序为例，它提供了全面的 **component** 用于构建界面，丰富的 **api** 用于访问硬件资源。程序员只需要编写少量的代码，就可以轻易完成一个app。相比 web app，它可以算得上无脑跨平台 - 因为微信这个容器本身已经对设备本身做了足够抽象，程序员不需要再花费精力做各种适配，解决兼容性问题。简单的说，可以将微信看作一个定制版浏览器，它提供了相比一般浏览器更多的功能，**以及限制**。\n\n如果你想的主要用户来自微信，小程序显然是比 web app 更好的选择。当然，这并不说明 web app 就没有市场了。有志向的大公司或者未来的独角兽们，通常不愿意仰人鼻息。而很多案例证明，腾讯爸爸显然对流量把控很看重。这就是简单的商业问题了。非我所长。\n\n## PWA\nweb app 不能离线使用，是因为所有的资源都存储在远端。那么，只需要解决如何将资源存在设备上，不就可以了吗？是的，目前已经有这样的 [cache api](https://developer.mozilla.org/en-US/docs/Web/API/Cache) 了，虽然还处于 **Experimental** 中（还未成为 web 标准）。但已经有不错的[兼容性](https://developer.mozilla.org/en-US/docs/Web/API/Cache#Browser_compatibility)了。\n\n![](cache-api-browser-compatibility.PNG)\n\n**PWA**（Progressive Web Apps）是 **google** 在 cache api 和 service worker 的基础上提出的一种 web app 方案。其实，本质上只是在原本的 web app 上又加了一层静态资源存储管理层。具体可以看[官方介绍](https://developers.google.com/web/progressive-web-apps/)。\n\n\n# 稍微总结一下\nweb app 开发快上线快，但是限制多。要放开限制，就得脱离浏览器。\n\n\n\n\n\n\n\n","source":"_posts/2019-01-08-what-web-cannot-do.md","raw":"---\ntitle: 震惊，web app 不能做的 N 件事\ncatalog: true\ndate: 2019-01-08 16:45:37\nsubtitle:\nheader-img: header.jpg\ntags: [web app, pwa, 小程序, hybrid app]\n---\n大概四五年前，我离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 **java** 。虽然在此之前， 我的所有 **java** 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。\n\n当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”\n\n如果不是后来阴差阳错，又转而做起了 **js**，我的人生可能又会是另一番模样。谁知道呢？\n\n# 和 js 的缘分\n\n参加工作以来，经历过两段**闲的蛋疼**的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。\n\n![phone.jpg](samsung-galaxy-mini-s5570.jpg)\n\n第二段则是在第二家公司，也就是那家中国公司。\n\n进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 **tab**，**dropdown** ，当然顺便也学了 **html** 和 **css** 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 **java** 写工具，深知 **layout** 和 **event listener** 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：\n\n![happy.jpg](s-b-vonlanthen-546859-unsplash.jpg)\n\n从此以后，我就“义无反顾”的加入了前端大军。\n\n同时，因为玩的比较多，所以早早就了解到 js 的各种限制，或者说是浏览器环境的诸多限制，譬如不能访问系统资源（本地文件），不能跨域访问资源，等等。但是，这点瑕疵丝毫不能熄灭我对 js 的热爱。\n\n# web app 的优势\n上面扯了一大段，大部分没有任何价值，只是写着写着情绪到了。哈哈。\n\n我理解的 **web app** 其实就是传统网站的一种变体。网站是以内容为主，交互为辅，而 web app 则两者平衡（比如**知乎**），甚至有些以交互为主（比如 teambition）。相对于**native app**，web app 的优势是低成本跨平台，free publish（相比 android app 和 ios app 的发布审核），开发成本相对较低。\n\n这里插一句：很多不懂技术被忽悠的进坑，大多是因为轻信了上面的好处。\n\n> 跨频台 -> 更少的开发和测试 -> 更低的成本\n\n套用一句话：**没有银弹**。你得到的多，付出的自然要更多。享受 web app 好处的同时，你不得不接受它的缺陷。\n\n# web app 的劣势，解决办法\n\nweb app 依赖浏览器来提供运行环境，相应的，也受制于浏览器的诸多限制。\n\n1. 不能自由的访问本地资源。举个例子，浏览器不允许 js 访问用户文件，那很多基于本地存储的功能（缓存，下载，上传）就做不了。\n2. 依赖网络。native app 可以离线工作，web app 却不能。\n3. 安全问题。任何人都能查看你的代码，以及各种 storeage。\n4. performance。web app 的优化只能止于浏览器，相对的，native app 可以做系统级别的优化。\n\n针对以上缺陷，很多大厂使用 **hybrid app** 技术 - 可以理解为 **web app in native container**。外层容器使用 native 语言开发，内部则加载 web app。容器赋予 web app 诸如文件系统等浏览器不具备的服务，而 web app 则承担复杂多变的业务逻辑和用户界面。\n\n# 低成本方案\n玩转 hybrid app 的成本太高，毕竟，你的开发团队需要两种技术人才，一种做 container，一种做 web。好在还有一些免费开源的 container 可以用，比如 [cordova](https://cordova.apache.org/), [electron](https://electronjs.org/)。\n\n可能，某些项目并不需要以上这样**全面**的方案。\n**老子只想要流线使用而已啊，说这么多干什么啊魂淡？！**\n**就不能发明一种只要开开心心写代码完全不用操心操作系统的ide吗？！**\n\n好，我们继续。上小程序。\n\n## 小程序\n过去的一年，很多大厂的**小程序**开始崭露头角。以微信小程序为例，它提供了全面的 **component** 用于构建界面，丰富的 **api** 用于访问硬件资源。程序员只需要编写少量的代码，就可以轻易完成一个app。相比 web app，它可以算得上无脑跨平台 - 因为微信这个容器本身已经对设备本身做了足够抽象，程序员不需要再花费精力做各种适配，解决兼容性问题。简单的说，可以将微信看作一个定制版浏览器，它提供了相比一般浏览器更多的功能，**以及限制**。\n\n如果你想的主要用户来自微信，小程序显然是比 web app 更好的选择。当然，这并不说明 web app 就没有市场了。有志向的大公司或者未来的独角兽们，通常不愿意仰人鼻息。而很多案例证明，腾讯爸爸显然对流量把控很看重。这就是简单的商业问题了。非我所长。\n\n## PWA\nweb app 不能离线使用，是因为所有的资源都存储在远端。那么，只需要解决如何将资源存在设备上，不就可以了吗？是的，目前已经有这样的 [cache api](https://developer.mozilla.org/en-US/docs/Web/API/Cache) 了，虽然还处于 **Experimental** 中（还未成为 web 标准）。但已经有不错的[兼容性](https://developer.mozilla.org/en-US/docs/Web/API/Cache#Browser_compatibility)了。\n\n![](cache-api-browser-compatibility.PNG)\n\n**PWA**（Progressive Web Apps）是 **google** 在 cache api 和 service worker 的基础上提出的一种 web app 方案。其实，本质上只是在原本的 web app 上又加了一层静态资源存储管理层。具体可以看[官方介绍](https://developers.google.com/web/progressive-web-apps/)。\n\n\n# 稍微总结一下\nweb app 开发快上线快，但是限制多。要放开限制，就得脱离浏览器。\n\n\n\n\n\n\n\n","slug":"what-web-cannot-do","published":1,"updated":"2019-01-23T09:28:03.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycuk0006dwx7j2po35ya","content":"<p>大概四五年前，我离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 <strong>java</strong> 。虽然在此之前， 我的所有 <strong>java</strong> 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。</p>\n<p>当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。<br>\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”</p>\n<p>如果不是后来阴差阳错，又转而做起了 <strong>js</strong>，我的人生可能又会是另一番模样。谁知道呢？</p>\n<h1><span id=\"和-js-的缘分\">和 js 的缘分</span></h1>\n<p>参加工作以来，经历过两段<strong>闲的蛋疼</strong>的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。</p>\n<p><img src=\"samsung-galaxy-mini-s5570.jpg\" alt=\"phone.jpg\"></p>\n<p>第二段则是在第二家公司，也就是那家中国公司。</p>\n<p>进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 <strong>tab</strong>，<strong>dropdown</strong> ，当然顺便也学了 <strong>html</strong> 和 <strong>css</strong> 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 <strong>java</strong> 写工具，深知 <strong>layout</strong> 和 <strong>event listener</strong> 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：</p>\n<p><img src=\"s-b-vonlanthen-546859-unsplash.jpg\" alt=\"happy.jpg\"></p>\n<p>从此以后，我就“义无反顾”的加入了前端大军。</p>\n<p>同时，因为玩的比较多，所以早早就了解到 js 的各种限制，或者说是浏览器环境的诸多限制，譬如不能访问系统资源（本地文件），不能跨域访问资源，等等。但是，这点瑕疵丝毫不能熄灭我对 js 的热爱。</p>\n<h1><span id=\"web-app-的优势\">web app 的优势</span></h1>\n<p>上面扯了一大段，大部分没有任何价值，只是写着写着情绪到了。哈哈。</p>\n<p>我理解的 <strong>web app</strong> 其实就是传统网站的一种变体。网站是以内容为主，交互为辅，而 web app 则两者平衡（比如<strong>知乎</strong>），甚至有些以交互为主（比如 teambition）。相对于<strong>native app</strong>，web app 的优势是低成本跨平台，free publish（相比 android app 和 ios app 的发布审核），开发成本相对较低。</p>\n<p>这里插一句：很多不懂技术被忽悠的进坑，大多是因为轻信了上面的好处。</p>\n<blockquote>\n<p>跨频台 -&gt; 更少的开发和测试 -&gt; 更低的成本</p>\n</blockquote>\n<p>套用一句话：<strong>没有银弹</strong>。你得到的多，付出的自然要更多。享受 web app 好处的同时，你不得不接受它的缺陷。</p>\n<h1><span id=\"web-app-的劣势解决办法\">web app 的劣势，解决办法</span></h1>\n<p>web app 依赖浏览器来提供运行环境，相应的，也受制于浏览器的诸多限制。</p>\n<ol>\n<li>不能自由的访问本地资源。举个例子，浏览器不允许 js 访问用户文件，那很多基于本地存储的功能（缓存，下载，上传）就做不了。</li>\n<li>依赖网络。native app 可以离线工作，web app 却不能。</li>\n<li>安全问题。任何人都能查看你的代码，以及各种 storeage。</li>\n<li>performance。web app 的优化只能止于浏览器，相对的，native app 可以做系统级别的优化。</li>\n</ol>\n<p>针对以上缺陷，很多大厂使用 <strong>hybrid app</strong> 技术 - 可以理解为 <strong>web app in native container</strong>。外层容器使用 native 语言开发，内部则加载 web app。容器赋予 web app 诸如文件系统等浏览器不具备的服务，而 web app 则承担复杂多变的业务逻辑和用户界面。</p>\n<h1><span id=\"低成本方案\">低成本方案</span></h1>\n<p>玩转 hybrid app 的成本太高，毕竟，你的开发团队需要两种技术人才，一种做 container，一种做 web。好在还有一些免费开源的 container 可以用，比如 <a href=\"https://cordova.apache.org/\" target=\"_blank\" rel=\"noopener\">cordova</a>, <a href=\"https://electronjs.org/\" target=\"_blank\" rel=\"noopener\">electron</a>。</p>\n<p>可能，某些项目并不需要以上这样<strong>全面</strong>的方案。<br>\n<strong>老子只想要流线使用而已啊，说这么多干什么啊魂淡？！</strong><br>\n<strong>就不能发明一种只要开开心心写代码完全不用操心操作系统的ide吗？！</strong></p>\n<p>好，我们继续。上小程序。</p>\n<h2><span id=\"小程序\">小程序</span></h2>\n<p>过去的一年，很多大厂的<strong>小程序</strong>开始崭露头角。以微信小程序为例，它提供了全面的 <strong>component</strong> 用于构建界面，丰富的 <strong>api</strong> 用于访问硬件资源。程序员只需要编写少量的代码，就可以轻易完成一个app。相比 web app，它可以算得上无脑跨平台 - 因为微信这个容器本身已经对设备本身做了足够抽象，程序员不需要再花费精力做各种适配，解决兼容性问题。简单的说，可以将微信看作一个定制版浏览器，它提供了相比一般浏览器更多的功能，<strong>以及限制</strong>。</p>\n<p>如果你想的主要用户来自微信，小程序显然是比 web app 更好的选择。当然，这并不说明 web app 就没有市场了。有志向的大公司或者未来的独角兽们，通常不愿意仰人鼻息。而很多案例证明，腾讯爸爸显然对流量把控很看重。这就是简单的商业问题了。非我所长。</p>\n<h2><span id=\"pwa\">PWA</span></h2>\n<p>web app 不能离线使用，是因为所有的资源都存储在远端。那么，只需要解决如何将资源存在设备上，不就可以了吗？是的，目前已经有这样的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Cache\" target=\"_blank\" rel=\"noopener\">cache api</a> 了，虽然还处于 <strong>Experimental</strong> 中（还未成为 web 标准）。但已经有不错的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Cache#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">兼容性</a>了。</p>\n<p><img src=\"cache-api-browser-compatibility.PNG\" alt=\"\"></p>\n<p><strong>PWA</strong>（Progressive Web Apps）是 <strong>google</strong> 在 cache api 和 service worker 的基础上提出的一种 web app 方案。其实，本质上只是在原本的 web app 上又加了一层静态资源存储管理层。具体可以看<a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">官方介绍</a>。</p>\n<h1><span id=\"稍微总结一下\">稍微总结一下</span></h1>\n<p>web app 开发快上线快，但是限制多。要放开限制，就得脱离浏览器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大概四五年前，我离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 <strong>java</strong> 。虽然在此之前， 我的所有 <strong>java</strong> 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。</p>\n<p>当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。<br>\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”</p>\n<p>如果不是后来阴差阳错，又转而做起了 <strong>js</strong>，我的人生可能又会是另一番模样。谁知道呢？</p>\n<h1>和 js 的缘分</h1>\n<p>参加工作以来，经历过两段<strong>闲的蛋疼</strong>的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。</p>\n<p><img src=\"samsung-galaxy-mini-s5570.jpg\" alt=\"phone.jpg\"></p>\n<p>第二段则是在第二家公司，也就是那家中国公司。</p>\n<p>进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 <strong>tab</strong>，<strong>dropdown</strong> ，当然顺便也学了 <strong>html</strong> 和 <strong>css</strong> 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 <strong>java</strong> 写工具，深知 <strong>layout</strong> 和 <strong>event listener</strong> 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：</p>\n<p><img src=\"s-b-vonlanthen-546859-unsplash.jpg\" alt=\"happy.jpg\"></p>\n<p>从此以后，我就“义无反顾”的加入了前端大军。</p>\n<p>同时，因为玩的比较多，所以早早就了解到 js 的各种限制，或者说是浏览器环境的诸多限制，譬如不能访问系统资源（本地文件），不能跨域访问资源，等等。但是，这点瑕疵丝毫不能熄灭我对 js 的热爱。</p>\n<h1>web app 的优势</h1>\n<p>上面扯了一大段，大部分没有任何价值，只是写着写着情绪到了。哈哈。</p>\n<p>我理解的 <strong>web app</strong> 其实就是传统网站的一种变体。网站是以内容为主，交互为辅，而 web app 则两者平衡（比如<strong>知乎</strong>），甚至有些以交互为主（比如 teambition）。相对于<strong>native app</strong>，web app 的优势是低成本跨平台，free publish（相比 android app 和 ios app 的发布审核），开发成本相对较低。</p>\n<p>这里插一句：很多不懂技术被忽悠的进坑，大多是因为轻信了上面的好处。</p>\n<blockquote>\n<p>跨频台 -&gt; 更少的开发和测试 -&gt; 更低的成本</p>\n</blockquote>\n<p>套用一句话：<strong>没有银弹</strong>。你得到的多，付出的自然要更多。享受 web app 好处的同时，你不得不接受它的缺陷。</p>\n<h1>web app 的劣势，解决办法</h1>\n<p>web app 依赖浏览器来提供运行环境，相应的，也受制于浏览器的诸多限制。</p>\n<ol>\n<li>不能自由的访问本地资源。举个例子，浏览器不允许 js 访问用户文件，那很多基于本地存储的功能（缓存，下载，上传）就做不了。</li>\n<li>依赖网络。native app 可以离线工作，web app 却不能。</li>\n<li>安全问题。任何人都能查看你的代码，以及各种 storeage。</li>\n<li>performance。web app 的优化只能止于浏览器，相对的，native app 可以做系统级别的优化。</li>\n</ol>\n<p>针对以上缺陷，很多大厂使用 <strong>hybrid app</strong> 技术 - 可以理解为 <strong>web app in native container</strong>。外层容器使用 native 语言开发，内部则加载 web app。容器赋予 web app 诸如文件系统等浏览器不具备的服务，而 web app 则承担复杂多变的业务逻辑和用户界面。</p>\n<h1>低成本方案</h1>\n<p>玩转 hybrid app 的成本太高，毕竟，你的开发团队需要两种技术人才，一种做 container，一种做 web。好在还有一些免费开源的 container 可以用，比如 <a href=\"https://cordova.apache.org/\" target=\"_blank\" rel=\"noopener\">cordova</a>, <a href=\"https://electronjs.org/\" target=\"_blank\" rel=\"noopener\">electron</a>。</p>\n<p>可能，某些项目并不需要以上这样<strong>全面</strong>的方案。<br>\n<strong>老子只想要流线使用而已啊，说这么多干什么啊魂淡？！</strong><br>\n<strong>就不能发明一种只要开开心心写代码完全不用操心操作系统的ide吗？！</strong></p>\n<p>好，我们继续。上小程序。</p>\n<h2>小程序</h2>\n<p>过去的一年，很多大厂的<strong>小程序</strong>开始崭露头角。以微信小程序为例，它提供了全面的 <strong>component</strong> 用于构建界面，丰富的 <strong>api</strong> 用于访问硬件资源。程序员只需要编写少量的代码，就可以轻易完成一个app。相比 web app，它可以算得上无脑跨平台 - 因为微信这个容器本身已经对设备本身做了足够抽象，程序员不需要再花费精力做各种适配，解决兼容性问题。简单的说，可以将微信看作一个定制版浏览器，它提供了相比一般浏览器更多的功能，<strong>以及限制</strong>。</p>\n<p>如果你想的主要用户来自微信，小程序显然是比 web app 更好的选择。当然，这并不说明 web app 就没有市场了。有志向的大公司或者未来的独角兽们，通常不愿意仰人鼻息。而很多案例证明，腾讯爸爸显然对流量把控很看重。这就是简单的商业问题了。非我所长。</p>\n<h2>PWA</h2>\n<p>web app 不能离线使用，是因为所有的资源都存储在远端。那么，只需要解决如何将资源存在设备上，不就可以了吗？是的，目前已经有这样的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Cache\" target=\"_blank\" rel=\"noopener\">cache api</a> 了，虽然还处于 <strong>Experimental</strong> 中（还未成为 web 标准）。但已经有不错的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Cache#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">兼容性</a>了。</p>\n<p><img src=\"cache-api-browser-compatibility.PNG\" alt=\"\"></p>\n<p><strong>PWA</strong>（Progressive Web Apps）是 <strong>google</strong> 在 cache api 和 service worker 的基础上提出的一种 web app 方案。其实，本质上只是在原本的 web app 上又加了一层静态资源存储管理层。具体可以看<a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">官方介绍</a>。</p>\n<h1>稍微总结一下</h1>\n<p>web app 开发快上线快，但是限制多。要放开限制，就得脱离浏览器。</p>\n"},{"title":"tiny url - 相见恨晚","catalog":true,"date":"2019-01-11T06:30:54.000Z","subtitle":null,"header-img":"iPad-Mini-iPhone.jpg","_content":"\n# 楔子\n刚开始做 **scrum master** 的时候，经常要发邮件广播 **user story** 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 **search query** 来搜索指定的内容。通常，我会将这些 **user store** 的 **search query** 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 **display text**，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。\n\n我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。\n\n这就是 **tiny url**。\n\n# tiny url\n**tiny url** 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。\n\n这是 [tiny url 官网](https://tinyurl.com/)，以及首页简介。\n> Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you've come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.\n\ntiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 [rebrandly](https://developers.rebrandly.com/)，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 [tinyurl](https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en)。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。\n\n![chrome-extension-tinyurl.jpg](chrome-extension-tinyurl.jpg)\n\n# 应用场景\n1. 使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 **tiny url** 是个不错的办法。\n2. 在某通讯工具中其假想敌的产品链接。[知乎上有过类似讨论](https://www.zhihu.com/question/37871221)。\n\n# tiny product\ntiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。**不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地**。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-01-11-start-to-use-tinyurl.md","raw":"---\ntitle: tiny url - 相见恨晚\ncatalog: true\ndate: 2019-01-11 14:30:54\nsubtitle:\nheader-img: iPad-Mini-iPhone.jpg\ntags: [tiny-url, url-shortener]\n---\n\n# 楔子\n刚开始做 **scrum master** 的时候，经常要发邮件广播 **user story** 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 **search query** 来搜索指定的内容。通常，我会将这些 **user store** 的 **search query** 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 **display text**，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。\n\n我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。\n\n这就是 **tiny url**。\n\n# tiny url\n**tiny url** 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。\n\n这是 [tiny url 官网](https://tinyurl.com/)，以及首页简介。\n> Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you've come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.\n\ntiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 [rebrandly](https://developers.rebrandly.com/)，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 [tinyurl](https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en)。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。\n\n![chrome-extension-tinyurl.jpg](chrome-extension-tinyurl.jpg)\n\n# 应用场景\n1. 使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 **tiny url** 是个不错的办法。\n2. 在某通讯工具中其假想敌的产品链接。[知乎上有过类似讨论](https://www.zhihu.com/question/37871221)。\n\n# tiny product\ntiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。**不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地**。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。\n\n\n\n\n\n\n\n\n\n\n","slug":"start-to-use-tinyurl","published":1,"updated":"2019-01-23T09:28:03.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycuq0008dwx7ja2ukg6u","content":"<h1><span id=\"楔子\">楔子</span></h1>\n<p>刚开始做 <strong>scrum master</strong> 的时候，经常要发邮件广播 <strong>user story</strong> 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 <strong>search query</strong> 来搜索指定的内容。通常，我会将这些 <strong>user store</strong> 的 <strong>search query</strong> 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 <strong>display text</strong>，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。</p>\n<p>我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。</p>\n<p>这就是 <strong>tiny url</strong>。</p>\n<h1><span id=\"tiny-url\">tiny url</span></h1>\n<p><strong>tiny url</strong> 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。</p>\n<p>这是 <a href=\"https://tinyurl.com/\" target=\"_blank\" rel=\"noopener\">tiny url 官网</a>，以及首页简介。</p>\n<blockquote>\n<p>Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you’ve come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.</p>\n</blockquote>\n<p>tiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 <a href=\"https://developers.rebrandly.com/\" target=\"_blank\" rel=\"noopener\">rebrandly</a>，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en\" target=\"_blank\" rel=\"noopener\">tinyurl</a>。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。</p>\n<p><img src=\"chrome-extension-tinyurl.jpg\" alt=\"chrome-extension-tinyurl.jpg\"></p>\n<h1><span id=\"应用场景\">应用场景</span></h1>\n<ol>\n<li>使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 <strong>tiny url</strong> 是个不错的办法。</li>\n<li>在某通讯工具中其假想敌的产品链接。<a href=\"https://www.zhihu.com/question/37871221\" target=\"_blank\" rel=\"noopener\">知乎上有过类似讨论</a>。</li>\n</ol>\n<h1><span id=\"tiny-product\">tiny product</span></h1>\n<p>tiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。<strong>不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地</strong>。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>楔子</h1>\n<p>刚开始做 <strong>scrum master</strong> 的时候，经常要发邮件广播 <strong>user story</strong> 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 <strong>search query</strong> 来搜索指定的内容。通常，我会将这些 <strong>user store</strong> 的 <strong>search query</strong> 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 <strong>display text</strong>，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。</p>\n<p>我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。</p>\n<p>这就是 <strong>tiny url</strong>。</p>\n<h1>tiny url</h1>\n<p><strong>tiny url</strong> 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。</p>\n<p>这是 <a href=\"https://tinyurl.com/\" target=\"_blank\" rel=\"noopener\">tiny url 官网</a>，以及首页简介。</p>\n<blockquote>\n<p>Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you’ve come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.</p>\n</blockquote>\n<p>tiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 <a href=\"https://developers.rebrandly.com/\" target=\"_blank\" rel=\"noopener\">rebrandly</a>，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en\" target=\"_blank\" rel=\"noopener\">tinyurl</a>。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。</p>\n<p><img src=\"chrome-extension-tinyurl.jpg\" alt=\"chrome-extension-tinyurl.jpg\"></p>\n<h1>应用场景</h1>\n<ol>\n<li>使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 <strong>tiny url</strong> 是个不错的办法。</li>\n<li>在某通讯工具中其假想敌的产品链接。<a href=\"https://www.zhihu.com/question/37871221\" target=\"_blank\" rel=\"noopener\">知乎上有过类似讨论</a>。</li>\n</ol>\n<h1>tiny product</h1>\n<p>tiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。<strong>不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地</strong>。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。</p>\n"},{"title":"Restful API 设计的三点经验之谈","catalog":true,"date":"2019-01-23T09:29:03.000Z","subtitle":null,"header-img":"lycs-lycs-744230-unsplash.jpg","_content":"2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。\n\n## Status code\n基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。\n\n那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。\n\n* 401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.\n* 403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。\n* 404 - not found，不存在。\n\n总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。\n\n服务端自身错误则包含两类情况：\n* io 错误，比如读写文件，访问数据库\n* 自身逻辑错误，比如内存泄漏。\n\n第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但**最好**有个兜底的错误处理以免程序挂掉。\n\n我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：\n\n```\n400 bad request\n{\n  \"code\": 123,\n  \"message\": \"Name is required\"\n}\n```\n\n## List API\nGET /orders\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [...]\n}\n```\n对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回\n```\n404 NotFound\n```\n难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [] // 空数组\n}\n```\n\n所以对于 List API 来说，没有 404。\n## Parent resource\nrestful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。\n```\n/users/{user_id}/addresses/\n```\n那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？\n\n用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。\n\n所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。 \n","source":"_posts/2019-01-23-three-points-of-restful-api-design.md","raw":"---\ntitle: Restful API 设计的三点经验之谈\ncatalog: true\ndate: 2019-01-23 17:29:03\nsubtitle:\nheader-img: lycs-lycs-744230-unsplash.jpg\ntags: restful-api\n---\n2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。\n\n## Status code\n基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。\n\n那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。\n\n* 401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.\n* 403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。\n* 404 - not found，不存在。\n\n总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。\n\n服务端自身错误则包含两类情况：\n* io 错误，比如读写文件，访问数据库\n* 自身逻辑错误，比如内存泄漏。\n\n第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但**最好**有个兜底的错误处理以免程序挂掉。\n\n我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：\n\n```\n400 bad request\n{\n  \"code\": 123,\n  \"message\": \"Name is required\"\n}\n```\n\n## List API\nGET /orders\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [...]\n}\n```\n对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回\n```\n404 NotFound\n```\n难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [] // 空数组\n}\n```\n\n所以对于 List API 来说，没有 404。\n## Parent resource\nrestful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。\n```\n/users/{user_id}/addresses/\n```\n那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？\n\n用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。\n\n所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。 \n","slug":"three-points-of-restful-api-design","published":1,"updated":"2019-01-23T09:38:52.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycv90009dwx7aietkt5p","content":"<p>2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。</p>\n<h2><span id=\"status-code\">Status code</span></h2>\n<p>基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。</p>\n<p>那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。</p>\n<ul>\n<li>401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.</li>\n<li>403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。</li>\n<li>404 - not found，不存在。</li>\n</ul>\n<p>总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。</p>\n<p>服务端自身错误则包含两类情况：</p>\n<ul>\n<li>io 错误，比如读写文件，访问数据库</li>\n<li>自身逻辑错误，比如内存泄漏。</li>\n</ul>\n<p>第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但<strong>最好</strong>有个兜底的错误处理以免程序挂掉。</p>\n<p>我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">400</span> <span class=\"keyword\">bad </span>request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"code\"</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">  <span class=\"string\">\"message\"</span>: <span class=\"string\">\"Name is required\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"list-api\">List API</span></h2>\n<p>GET /orders</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: <span class=\"string\">[...]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">404 </span>NotFound</span><br></pre></td></tr></table></figure>\n<p>难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: [] <span class=\"comment\">// 空数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于 List API 来说，没有 404。</p>\n<h2><span id=\"parent-resource\">Parent resource</span></h2>\n<p>restful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/users/</span>&#123;user_id&#125;<span class=\"regexp\">/addresses/</span></span><br></pre></td></tr></table></figure>\n<p>那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？</p>\n<p>用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。</p>\n<p>所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。</p>\n<h2>Status code</h2>\n<p>基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。</p>\n<p>那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。</p>\n<ul>\n<li>401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.</li>\n<li>403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。</li>\n<li>404 - not found，不存在。</li>\n</ul>\n<p>总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。</p>\n<p>服务端自身错误则包含两类情况：</p>\n<ul>\n<li>io 错误，比如读写文件，访问数据库</li>\n<li>自身逻辑错误，比如内存泄漏。</li>\n</ul>\n<p>第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但<strong>最好</strong>有个兜底的错误处理以免程序挂掉。</p>\n<p>我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">400</span> <span class=\"keyword\">bad </span>request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"code\"</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">  <span class=\"string\">\"message\"</span>: <span class=\"string\">\"Name is required\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>List API</h2>\n<p>GET /orders</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: <span class=\"string\">[...]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">404 </span>NotFound</span><br></pre></td></tr></table></figure>\n<p>难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: [] <span class=\"comment\">// 空数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于 List API 来说，没有 404。</p>\n<h2>Parent resource</h2>\n<p>restful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/users/</span>&#123;user_id&#125;<span class=\"regexp\">/addresses/</span></span><br></pre></td></tr></table></figure>\n<p>那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？</p>\n<p>用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。</p>\n<p>所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。</p>\n"},{"title":"文件上传二三事","catalog":true,"date":"2015-11-20T10:05:52.000Z","subtitle":null,"header-img":"home-bg-2-dark.png","_content":"# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","source":"_posts/about-file-upload-1.md","raw":"---\ntitle: 文件上传二三事\ncatalog: true\ndate: 2015-11-20 18:05:52\nsubtitle:\nheader-img: home-bg-2-dark.png\ntags: [文件上传,http]\n---\n# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","slug":"about-file-upload-1","published":1,"updated":"2019-01-04T05:42:25.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycvb000bdwx7wsyvps8l","content":"<h1><span id=\"引子\">引子</span></h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1><span id=\"选择文件\">选择文件</span></h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1><span id=\"如何上传\">如何上传</span></h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1><span id=\"增强实现\">增强实现</span></h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2><span id=\"美化选择按钮\">美化选择按钮</span></h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2><span id=\"不想刷新页面\">不想刷新页面</span></h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> (<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"built_in\">window</span>.uploadSuccess(<span class=\"string\">'xxxxxx'</span>);</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"undefined\">...</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2><span id=\"formdataajax文件上传\">FormData，ajax文件上传</span></h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1><span id=\"文件验证\">文件验证</span></h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2><span id=\"前端\">前端</span></h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2><span id=\"后端\">后端</span></h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1><span id=\"为什么叫二三事\">为什么叫二三事</span></h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1><span id=\"后记\">后记</span></h1>\n<h2><span id=\"补充\">补充</span></h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>引子</h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1>选择文件</h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1>如何上传</h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1>增强实现</h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2>美化选择按钮</h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2>不想刷新页面</h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> (<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"built_in\">window</span>.uploadSuccess(<span class=\"string\">'xxxxxx'</span>);</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"undefined\">...</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2>FormData，ajax文件上传</h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1>文件验证</h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2>前端</h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2>后端</h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1>为什么叫二三事</h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1>后记</h1>\n<h2>补充</h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n"},{"title":"ejs 入门","catalog":true,"date":"2018-02-02T05:21:32.000Z","subtitle":"熟练掌握一种模板引擎可以极大的提高页面开发效率","header-img":null,"_content":"## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","source":"_posts/get-started-ejs.md","raw":"---\ntitle: ejs 入门\ncatalog: true\ndate: 2018-02-02 13:21:32\nsubtitle: 熟练掌握一种模板引擎可以极大的提高页面开发效率\nheader-img: \ntags: [ejs,模板引擎,前端工程]\n---\n## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","slug":"get-started-ejs","published":1,"updated":"2019-01-04T05:42:25.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycvf000cdwx7jjjvk63r","content":"<h2><span id=\"为什么要学习模板引擎\">为什么要学习模板引擎</span></h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2><span id=\"安装\">安装</span></h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2><span id=\"基本语法要素\">基本语法要素</span></h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"标签\">标签</span></h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2><span id=\"包含-includes\">包含 Includes</span></h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2><span id=\"定制分隔符\">定制分隔符</span></h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"参考文档\">参考文档</span></h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>为什么要学习模板引擎</h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2>安装</h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2>基本语法要素</h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>标签</h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2>包含 Includes</h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2>定制分隔符</h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2>参考文档</h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n"},{"title":"Golang 与 MongoDB：入门篇","catalog":true,"date":"2018-02-02T07:47:08.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/get-started-of-golang-with-mongodb.md","raw":"---\ntitle: Golang 与 MongoDB：入门篇\ncatalog: true\ndate: 2018-02-02 15:47:08\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"get-started-of-golang-with-mongodb","published":1,"updated":"2019-01-04T05:42:25.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycvl000edwx7h51w2nd4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Golang：package 和 访问权限，以及其他基本知识总结","catalog":true,"date":"2018-02-05T07:46:05.000Z","subtitle":null,"header-img":null,"_content":"## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","source":"_posts/golang-package-etc.md","raw":"---\ntitle: Golang：package 和 访问权限，以及其他基本知识总结\ncatalog: true\ndate: 2018-02-05 15:46:05\nsubtitle: \nheader-img:\ntags:\n---\n## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","slug":"golang-package-etc","published":1,"updated":"2019-01-04T05:42:25.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycvn000gdwx7t5i6xvjz","content":"<h2><span id=\"引子\">引子</span></h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2><span id=\"项目结构\">项目结构</span></h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2><span id=\"访问权限\">访问权限</span></h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"安装-lib\">安装 lib</span></h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2><span id=\"管理依赖\">管理依赖</span></h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2><span id=\"常用的-libweb-service-开发小知识\">常用的 lib（web service 开发），小知识</span></h2>\n<h3><span id=\"web-框架路由\">web 框架，路由</span></h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3><span id=\"yaml-文件解析\">yaml 文件解析</span></h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>引子</h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2>项目结构</h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2>访问权限</h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2>安装 lib</h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2>管理依赖</h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2>常用的 lib（web service 开发），小知识</h2>\n<h3>web 框架，路由</h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3>yaml 文件解析</h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n"},{"title":"译-构建微服务面临的挑战","catalog":true,"date":"2018-06-12T02:30:51.000Z","subtitle":null,"header-img":null,"_content":"原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","source":"_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","raw":"---\ntitle: 译-构建微服务面临的挑战\ncatalog: true\ndate: 2018-06-12 10:30:51\nsubtitle: \nheader-img:\ntags: micro service\n---\n原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","slug":"translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices","published":1,"updated":"2019-01-04T05:42:25.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycvp000jdwx7lmv1uq56","content":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2><span id=\"六个问题\">六个问题</span></h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3><span id=\"组织架构\">组织架构</span></h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3><span id=\"更容易出错\">更容易出错</span></h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3><span id=\"资源竞争\">资源竞争</span></h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3><span id=\"对微服务的误解\">对微服务的误解</span></h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3><span id=\"技术债务\">技术债务</span></h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3><span id=\"缺乏信任\">缺乏信任</span></h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2><span id=\"解决办法\">解决办法</span></h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3><span id=\"需要标准化\">需要标准化</span></h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3><span id=\"production-ready-的微服务架构\">production ready 的微服务架构</span></h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3><span id=\"稳定性和可靠性\">稳定性和可靠性</span></h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3><span id=\"可扩展性和性能\">可扩展性和性能</span></h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3><span id=\"容错和灾难防护\">容错和灾难防护</span></h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3><span id=\"监控\">监控</span></h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3><span id=\"文档\">文档</span></h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2><span id=\"更多内容\">更多内容</span></h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2>六个问题</h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3>组织架构</h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3>更容易出错</h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3>资源竞争</h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3>对微服务的误解</h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3>技术债务</h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3>缺乏信任</h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2>解决办法</h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3>需要标准化</h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3>production ready 的微服务架构</h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3>稳定性和可靠性</h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3>可扩展性和性能</h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3>容错和灾难防护</h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3>监控</h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3>文档</h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2>更多内容</h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n"},{"title":"Wang Pin's 2018 总结 - thinking more，doing the best","catalog":true,"date":"2018-12-29T09:00:53.000Z","subtitle":"跳出程序员思维，读书，实践，思考","header-img":"stockvault-abstract-person-with-cogwheels209083.jpg","_content":"# 跳出程序员的思维\n## 做“出格”的事\n很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。\n**所以，我现在偏好做“出格”的事情**。\n>要掌握一件东西，必须先了解它。\n\n要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。\n然后，**必须去沟通**。\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。\n最后，**还得学会关键对话**。\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。\n\n当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。\n\n## 看书\n做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。\n* 《品牌的起源》\n* 《淘宝十年产品事》\n* 《产品经理入门攻略》\n* 《腾讯产品法》\n* 《产品经理方法论》\n* 《产品的视角：从热闹到门道》\n* 《人人都是产品经理》\n* 《破茧成蝶-用户体验设计师的成长之路》\n* 《关键对话》\n\n作为业余放松，我也看小说。目前已读完的：\n* 《三体》\n* 《大明1566》\n* 《天龙八部》\n* 《射雕英雄传》\n* 《神雕侠侣》\n* 《倚天屠龙记》\n* 《碧血剑》\n* 《鹿鼎记》\n* 《连城诀》\n* 《七种武器》\n\n在读和计划的：\n* 《冰与火之歌》\n* 《哈利波特》\n* 《书剑恩仇录》\n* 《雪山飞狐》\n* 《李自成》\n\n## 关于工程师和QA的思考\n当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。\n\n在这样的管理方式下，整个项目组的人员演变，将变成：\n* 工程师任务太重，所以减少编写单元测试的时间\n* 招聘QA来编写测试代码\n* 工程师发现单元测试可有可无，于是不再写单元测试\n* 招聘更多QA\n\n以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。\n\n很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。\n\n# 技术和创意\n## server render 和 pwa\nspa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的**必须**资源，一次返回给客户端，以加速首屏渲染效率。\n\npwa（progress web application）通过 server-worker 和 cache，将静态文件**存储**在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。\n\n结合 spa 和 pwa，app 的**启动速度**将得到质的飞跃。\n\n## web component\nweb component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如**微前端**：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。\n\n## material design\n我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。\n\n## 创意\n> 没实现的创意，那只是脑洞\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。\n\n世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：\n\n1. hexo 主题 - remind\n[remind](https://baike.baidu.com/item/remind/10466250?fr=aladdin#5) 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。\n2. boli - local 资源文件编辑器\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。\n3. 更简单的私人博客\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：\n1. 想玩，比如我\n2.想要自己的独立地址\n\n对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？\n\n（全文结束）\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018-12-29-summary-of-2018.md","raw":"---\ntitle: Wang Pin's 2018 总结 - thinking more，doing the best\ncatalog: true\ndate: 2018-12-29 17:00:53\nsubtitle: 跳出程序员思维，读书，实践，思考\nheader-img: stockvault-abstract-person-with-cogwheels209083.jpg\ntags: [思考,总结,沟通能力,职业发展]\n---\n# 跳出程序员的思维\n## 做“出格”的事\n很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。\n**所以，我现在偏好做“出格”的事情**。\n>要掌握一件东西，必须先了解它。\n\n要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。\n然后，**必须去沟通**。\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。\n最后，**还得学会关键对话**。\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。\n\n当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。\n\n## 看书\n做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。\n* 《品牌的起源》\n* 《淘宝十年产品事》\n* 《产品经理入门攻略》\n* 《腾讯产品法》\n* 《产品经理方法论》\n* 《产品的视角：从热闹到门道》\n* 《人人都是产品经理》\n* 《破茧成蝶-用户体验设计师的成长之路》\n* 《关键对话》\n\n作为业余放松，我也看小说。目前已读完的：\n* 《三体》\n* 《大明1566》\n* 《天龙八部》\n* 《射雕英雄传》\n* 《神雕侠侣》\n* 《倚天屠龙记》\n* 《碧血剑》\n* 《鹿鼎记》\n* 《连城诀》\n* 《七种武器》\n\n在读和计划的：\n* 《冰与火之歌》\n* 《哈利波特》\n* 《书剑恩仇录》\n* 《雪山飞狐》\n* 《李自成》\n\n## 关于工程师和QA的思考\n当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。\n\n在这样的管理方式下，整个项目组的人员演变，将变成：\n* 工程师任务太重，所以减少编写单元测试的时间\n* 招聘QA来编写测试代码\n* 工程师发现单元测试可有可无，于是不再写单元测试\n* 招聘更多QA\n\n以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。\n\n很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。\n\n# 技术和创意\n## server render 和 pwa\nspa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的**必须**资源，一次返回给客户端，以加速首屏渲染效率。\n\npwa（progress web application）通过 server-worker 和 cache，将静态文件**存储**在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。\n\n结合 spa 和 pwa，app 的**启动速度**将得到质的飞跃。\n\n## web component\nweb component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如**微前端**：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。\n\n## material design\n我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。\n\n## 创意\n> 没实现的创意，那只是脑洞\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。\n\n世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：\n\n1. hexo 主题 - remind\n[remind](https://baike.baidu.com/item/remind/10466250?fr=aladdin#5) 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。\n2. boli - local 资源文件编辑器\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。\n3. 更简单的私人博客\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：\n1. 想玩，比如我\n2.想要自己的独立地址\n\n对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？\n\n（全文结束）\n\n\n\n\n\n\n\n\n\n\n","slug":"summary-of-2018","published":1,"updated":"2019-01-04T05:42:25.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjr8zycw5001bdwx7g4hjmk19","content":"<h1><span id=\"跳出程序员的思维\">跳出程序员的思维</span></h1>\n<h2><span id=\"做出格的事\">做“出格”的事</span></h2>\n<p>很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。<br>\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。<br>\n<strong>所以，我现在偏好做“出格”的事情</strong>。</p>\n<blockquote>\n<p>要掌握一件东西，必须先了解它。</p>\n</blockquote>\n<p>要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。<br>\n然后，<strong>必须去沟通</strong>。<br>\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。<br>\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。<br>\n最后，<strong>还得学会关键对话</strong>。<br>\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。</p>\n<p>当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。</p>\n<h2><span id=\"看书\">看书</span></h2>\n<p>做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。</p>\n<ul>\n<li>《品牌的起源》</li>\n<li>《淘宝十年产品事》</li>\n<li>《产品经理入门攻略》</li>\n<li>《腾讯产品法》</li>\n<li>《产品经理方法论》</li>\n<li>《产品的视角：从热闹到门道》</li>\n<li>《人人都是产品经理》</li>\n<li>《破茧成蝶-用户体验设计师的成长之路》</li>\n<li>《关键对话》</li>\n</ul>\n<p>作为业余放松，我也看小说。目前已读完的：</p>\n<ul>\n<li>《三体》</li>\n<li>《大明1566》</li>\n<li>《天龙八部》</li>\n<li>《射雕英雄传》</li>\n<li>《神雕侠侣》</li>\n<li>《倚天屠龙记》</li>\n<li>《碧血剑》</li>\n<li>《鹿鼎记》</li>\n<li>《连城诀》</li>\n<li>《七种武器》</li>\n</ul>\n<p>在读和计划的：</p>\n<ul>\n<li>《冰与火之歌》</li>\n<li>《哈利波特》</li>\n<li>《书剑恩仇录》</li>\n<li>《雪山飞狐》</li>\n<li>《李自成》</li>\n</ul>\n<h2><span id=\"关于工程师和qa的思考\">关于工程师和QA的思考</span></h2>\n<p>当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。</p>\n<p>在这样的管理方式下，整个项目组的人员演变，将变成：</p>\n<ul>\n<li>工程师任务太重，所以减少编写单元测试的时间</li>\n<li>招聘QA来编写测试代码</li>\n<li>工程师发现单元测试可有可无，于是不再写单元测试</li>\n<li>招聘更多QA</li>\n</ul>\n<p>以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。</p>\n<p>很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。</p>\n<h1><span id=\"技术和创意\">技术和创意</span></h1>\n<h2><span id=\"server-render-和-pwa\">server render 和 pwa</span></h2>\n<p>spa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。<br>\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的<strong>必须</strong>资源，一次返回给客户端，以加速首屏渲染效率。</p>\n<p>pwa（progress web application）通过 server-worker 和 cache，将静态文件<strong>存储</strong>在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。</p>\n<p>结合 spa 和 pwa，app 的<strong>启动速度</strong>将得到质的飞跃。</p>\n<h2><span id=\"web-component\">web component</span></h2>\n<p>web component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如<strong>微前端</strong>：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。</p>\n<h2><span id=\"material-design\">material design</span></h2>\n<p>我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。</p>\n<h2><span id=\"创意\">创意</span></h2>\n<blockquote>\n<p>没实现的创意，那只是脑洞<br>\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。</p>\n</blockquote>\n<p>世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：</p>\n<ol>\n<li>hexo 主题 - remind<br>\n<a href=\"https://baike.baidu.com/item/remind/10466250?fr=aladdin#5\" target=\"_blank\" rel=\"noopener\">remind</a> 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。</li>\n<li>boli - local 资源文件编辑器<br>\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。<br>\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。</li>\n<li>更简单的私人博客<br>\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：</li>\n<li>想玩，比如我<br>\n2.想要自己的独立地址</li>\n</ol>\n<p>对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？</p>\n<p>（全文结束）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>跳出程序员的思维</h1>\n<h2>做“出格”的事</h2>\n<p>很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。<br>\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。<br>\n<strong>所以，我现在偏好做“出格”的事情</strong>。</p>\n<blockquote>\n<p>要掌握一件东西，必须先了解它。</p>\n</blockquote>\n<p>要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。<br>\n然后，<strong>必须去沟通</strong>。<br>\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。<br>\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。<br>\n最后，<strong>还得学会关键对话</strong>。<br>\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。</p>\n<p>当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。</p>\n<h2>看书</h2>\n<p>做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。</p>\n<ul>\n<li>《品牌的起源》</li>\n<li>《淘宝十年产品事》</li>\n<li>《产品经理入门攻略》</li>\n<li>《腾讯产品法》</li>\n<li>《产品经理方法论》</li>\n<li>《产品的视角：从热闹到门道》</li>\n<li>《人人都是产品经理》</li>\n<li>《破茧成蝶-用户体验设计师的成长之路》</li>\n<li>《关键对话》</li>\n</ul>\n<p>作为业余放松，我也看小说。目前已读完的：</p>\n<ul>\n<li>《三体》</li>\n<li>《大明1566》</li>\n<li>《天龙八部》</li>\n<li>《射雕英雄传》</li>\n<li>《神雕侠侣》</li>\n<li>《倚天屠龙记》</li>\n<li>《碧血剑》</li>\n<li>《鹿鼎记》</li>\n<li>《连城诀》</li>\n<li>《七种武器》</li>\n</ul>\n<p>在读和计划的：</p>\n<ul>\n<li>《冰与火之歌》</li>\n<li>《哈利波特》</li>\n<li>《书剑恩仇录》</li>\n<li>《雪山飞狐》</li>\n<li>《李自成》</li>\n</ul>\n<h2>关于工程师和QA的思考</h2>\n<p>当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。</p>\n<p>在这样的管理方式下，整个项目组的人员演变，将变成：</p>\n<ul>\n<li>工程师任务太重，所以减少编写单元测试的时间</li>\n<li>招聘QA来编写测试代码</li>\n<li>工程师发现单元测试可有可无，于是不再写单元测试</li>\n<li>招聘更多QA</li>\n</ul>\n<p>以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。</p>\n<p>很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。</p>\n<h1>技术和创意</h1>\n<h2>server render 和 pwa</h2>\n<p>spa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。<br>\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的<strong>必须</strong>资源，一次返回给客户端，以加速首屏渲染效率。</p>\n<p>pwa（progress web application）通过 server-worker 和 cache，将静态文件<strong>存储</strong>在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。</p>\n<p>结合 spa 和 pwa，app 的<strong>启动速度</strong>将得到质的飞跃。</p>\n<h2>web component</h2>\n<p>web component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如<strong>微前端</strong>：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。</p>\n<h2>material design</h2>\n<p>我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。</p>\n<h2>创意</h2>\n<blockquote>\n<p>没实现的创意，那只是脑洞<br>\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。</p>\n</blockquote>\n<p>世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：</p>\n<ol>\n<li>hexo 主题 - remind<br>\n<a href=\"https://baike.baidu.com/item/remind/10466250?fr=aladdin#5\" target=\"_blank\" rel=\"noopener\">remind</a> 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。</li>\n<li>boli - local 资源文件编辑器<br>\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。<br>\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。</li>\n<li>更简单的私人博客<br>\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：</li>\n<li>想玩，比如我<br>\n2.想要自己的独立地址</li>\n</ol>\n<p>对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？</p>\n<p>（全文结束）</p>\n"}],"PostAsset":[{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","slug":"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","post":"cjr8zycvp000jdwx7lmv1uq56","modified":1,"renderable":0},{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","slug":"lycs-lycs-744230-unsplash.jpg","post":"cjr8zycv90009dwx7aietkt5p","modified":1,"renderable":0},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","slug":"home-bg-2-dark.png","post":"cjr8zycvb000bdwx7wsyvps8l","modified":1,"renderable":0},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/chrome-extension-tinyurl.jpg","post":"cjr8zycuq0008dwx7ja2ukg6u","slug":"chrome-extension-tinyurl.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/iPad-Mini-iPhone.jpg","slug":"iPad-Mini-iPhone.jpg","post":"cjr8zycuq0008dwx7ja2ukg6u","modified":1,"renderable":0},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","post":"cjr8zycvp000jdwx7lmv1uq56","slug":"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","modified":1,"renderable":1},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/cache-api-browser-compatibility.PNG","post":"cjr8zycuk0006dwx7j2po35ya","slug":"cache-api-browser-compatibility.PNG","modified":1,"renderable":1},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/header.jpg","slug":"header.jpg","post":"cjr8zycuk0006dwx7j2po35ya","modified":1,"renderable":0},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/s-b-vonlanthen-546859-unsplash.jpg","slug":"s-b-vonlanthen-546859-unsplash.jpg","post":"cjr8zycuk0006dwx7j2po35ya","modified":1,"renderable":0},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","post":"cjr8zycuk0006dwx7j2po35ya","slug":"samsung-galaxy-mini-s5570.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2018-12-29-summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","slug":"stockvault-abstract-person-with-cogwheels209083.jpg","post":"cjr8zycw5001bdwx7g4hjmk19","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjr8zycu30001dwx709vokp33","tag_id":"cjr8zycue0005dwx7ihm5sz1w","_id":"cjr8zycvm000fdwx73lh7duni"},{"post_id":"cjr8zycu30001dwx709vokp33","tag_id":"cjr8zycva000adwx7z5n3hxgn","_id":"cjr8zycvo000hdwx7bjaumjd6"},{"post_id":"cjr8zycub0003dwx7h1tzbdsq","tag_id":"cjr8zycue0005dwx7ihm5sz1w","_id":"cjr8zycvq000ldwx7rzu5hwto"},{"post_id":"cjr8zycub0003dwx7h1tzbdsq","tag_id":"cjr8zycva000adwx7z5n3hxgn","_id":"cjr8zycvr000mdwx7g4zazmh0"},{"post_id":"cjr8zycuk0006dwx7j2po35ya","tag_id":"cjr8zycvq000kdwx7km7kmkdz","_id":"cjr8zycvs000rdwx7oq01c4rd"},{"post_id":"cjr8zycuk0006dwx7j2po35ya","tag_id":"cjr8zycvr000ndwx7s82fda78","_id":"cjr8zycvt000sdwx7jwh6n0d7"},{"post_id":"cjr8zycuk0006dwx7j2po35ya","tag_id":"cjr8zycvr000odwx7y8icyeyk","_id":"cjr8zycvt000udwx7h6h2bgnm"},{"post_id":"cjr8zycuk0006dwx7j2po35ya","tag_id":"cjr8zycvs000pdwx7waeoq08f","_id":"cjr8zycvt000vdwx7hrasq3nr"},{"post_id":"cjr8zycuq0008dwx7ja2ukg6u","tag_id":"cjr8zycvs000qdwx7gtqlaw8t","_id":"cjr8zycvu000xdwx7ism1i926"},{"post_id":"cjr8zycuq0008dwx7ja2ukg6u","tag_id":"cjr8zycvt000tdwx78ukqmmtn","_id":"cjr8zycvu000ydwx704wuietl"},{"post_id":"cjr8zycv90009dwx7aietkt5p","tag_id":"cjr8zycvt000wdwx722vsic23","_id":"cjr8zycvu0010dwx7h8ipvctk"},{"post_id":"cjr8zycvb000bdwx7wsyvps8l","tag_id":"cjr8zycvu000zdwx707fvml5f","_id":"cjr8zycvx0013dwx75yane1n5"},{"post_id":"cjr8zycvb000bdwx7wsyvps8l","tag_id":"cjr8zycvu0011dwx77m03if43","_id":"cjr8zycvx0014dwx74pi0kstp"},{"post_id":"cjr8zycvf000cdwx7jjjvk63r","tag_id":"cjr8zycvw0012dwx7ln2lkaju","_id":"cjr8zycvy0017dwx7e7z8kks6"},{"post_id":"cjr8zycvf000cdwx7jjjvk63r","tag_id":"cjr8zycvx0015dwx7fsdez7ub","_id":"cjr8zycvy0018dwx724xs6wlg"},{"post_id":"cjr8zycvf000cdwx7jjjvk63r","tag_id":"cjr8zycva000adwx7z5n3hxgn","_id":"cjr8zycvz0019dwx7kmbhmdx3"},{"post_id":"cjr8zycvp000jdwx7lmv1uq56","tag_id":"cjr8zycvy0016dwx7dkrw17lt","_id":"cjr8zycvz001adwx7obbpl9rf"},{"post_id":"cjr8zycw5001bdwx7g4hjmk19","tag_id":"cjr8zycw8001cdwx7sf4cxti1","_id":"cjr8zycwl001gdwx74ar0s1tm"},{"post_id":"cjr8zycw5001bdwx7g4hjmk19","tag_id":"cjr8zycwk001ddwx7l6cyteig","_id":"cjr8zycwm001hdwx7cmed1zzl"},{"post_id":"cjr8zycw5001bdwx7g4hjmk19","tag_id":"cjr8zycwk001edwx7u817bnyd","_id":"cjr8zycwm001idwx7g5z7a609"},{"post_id":"cjr8zycw5001bdwx7g4hjmk19","tag_id":"cjr8zycwl001fdwx7sxizc0de","_id":"cjr8zycwm001jdwx7bqto31xf"}],"Tag":[{"name":"gulp","_id":"cjr8zycue0005dwx7ihm5sz1w"},{"name":"前端工程","_id":"cjr8zycva000adwx7z5n3hxgn"},{"name":"web app","_id":"cjr8zycvq000kdwx7km7kmkdz"},{"name":"pwa","_id":"cjr8zycvr000ndwx7s82fda78"},{"name":"小程序","_id":"cjr8zycvr000odwx7y8icyeyk"},{"name":"hybrid app","_id":"cjr8zycvs000pdwx7waeoq08f"},{"name":"tiny-url","_id":"cjr8zycvs000qdwx7gtqlaw8t"},{"name":"url-shortener","_id":"cjr8zycvt000tdwx78ukqmmtn"},{"name":"restful-api","_id":"cjr8zycvt000wdwx722vsic23"},{"name":"文件上传","_id":"cjr8zycvu000zdwx707fvml5f"},{"name":"http","_id":"cjr8zycvu0011dwx77m03if43"},{"name":"ejs","_id":"cjr8zycvw0012dwx7ln2lkaju"},{"name":"模板引擎","_id":"cjr8zycvx0015dwx7fsdez7ub"},{"name":"micro service","_id":"cjr8zycvy0016dwx7dkrw17lt"},{"name":"思考","_id":"cjr8zycw8001cdwx7sf4cxti1"},{"name":"总结","_id":"cjr8zycwk001ddwx7l6cyteig"},{"name":"沟通能力","_id":"cjr8zycwk001edwx7u817bnyd"},{"name":"职业发展","_id":"cjr8zycwl001fdwx7sxizc0de"}]}}