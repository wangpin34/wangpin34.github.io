{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-remind/source/css/reset.styl","path":"css/reset.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-remind/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-remind/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-remind/source/css/wigets.styl","path":"css/wigets.styl","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","path":"img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","path":"img/header_img/reed-xia-790819-unsplash.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/forrest.jpeg","path":"img/header_img/forrest.jpeg","modified":0,"renderable":0},{"_id":"source/img/s-b-vonlanthen-546859-unsplash.jpg","path":"img/s-b-vonlanthen-546859-unsplash.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-remind/_config.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566467759396},{"_id":"source/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1546580545361},{"_id":"themes/hexo-theme-remind/README.md","hash":"4a4a8f02bdd8b0e9e54f23a27648fa611fb914d6","modified":1566467759396},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1546580545361},{"_id":"themes/hexo-theme-remind/languages/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566467759397},{"_id":"source/about/index.md","hash":"6d34280407269e4abf1ee6f083b4773dbb78b50d","modified":1566469645723},{"_id":"source/_posts/2018-12-26-gulp-series-2-glob.md","hash":"a2086bfc28c2ceb4225eb19064b9c24b564a1d2d","modified":1546580545362},{"_id":"source/archive/index.md","hash":"8aae18ca407df5101dd31957068be67b799d29e4","modified":1548235683071},{"_id":"source/_posts/2018-12-20-gulp-series-1.md","hash":"87cd505fb3cae85180b28ed52684beded34b2a2e","modified":1546580545361},{"_id":"source/_posts/2018-12-29-summary-of-2018.md","hash":"161160ab8810ea875dae818680bf63f4d789b807","modified":1546580545362},{"_id":"source/_posts/2019-01-08-what-web-cannot-do.md","hash":"c9543d6c48ed6ec0b1354ec3275d08c4325a193c","modified":1566544153875},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl.md","hash":"6bc5cba181a605e63da8c78c099f4124aabf8d8a","modified":1566468745571},{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design.md","hash":"1ec005d3e64d7cd938271a24f29b083f80a5dcbc","modified":1548236332577},{"_id":"source/_posts/2019-05-10-shared-dev-tools.md","hash":"eb51d7fd6688fccc70aa642456e277cd718f9a1b","modified":1558944987143},{"_id":"source/_posts/2019-05-27-configure-env-variables-without-tears.md","hash":"00fca360a7615e3e9f03a20d711a315838c36f80","modified":1558950694372},{"_id":"source/_posts/about-file-upload-1.md","hash":"410aa62941124c174ddcc0a8a41b4adfe16f60c4","modified":1566468536103},{"_id":"source/_posts/golang-package-etc.md","hash":"84028c24adf16ab23a1684f25e6b53e76f969c9e","modified":1546580545382},{"_id":"source/_posts/get-started-ejs.md","hash":"edb5e3bddf7eeceb73b3ee5660f74b947d3bdf41","modified":1546580545381},{"_id":"source/_posts/get-started-of-golang-with-mongodb.md","hash":"3993d7c9a7f7c216182cce875e98ef98514bdf2f","modified":1546580545381},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","hash":"745dbeff5ffdcddd7d9c593f05cb4b2af0998e23","modified":1566468427933},{"_id":"themes/hexo-theme-remind/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1566467759386},{"_id":"source/tags/index.md","hash":"e79b7dc92303106ae14f4333f2c6d0278923a8eb","modified":1548235683074},{"_id":"source/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1546580545533},{"_id":"themes/hexo-theme-remind/.git/config","hash":"806b28297342cc97666f0576815099e0595b6b86","modified":1566467759392},{"_id":"themes/hexo-theme-remind/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1566467754750},{"_id":"themes/hexo-theme-remind/.git/index","hash":"7f0e294c23ace96c785b3682413f13c5a9cdf244","modified":1566467759410},{"_id":"themes/hexo-theme-remind/.git/packed-refs","hash":"8bcee4c5ef619cfed9f555583012cf409e9f0a77","modified":1566467759378},{"_id":"themes/hexo-theme-remind/languages/en.yaml","hash":"922dd2f2afa5efb1dccfeebe74c213926a1411e8","modified":1566467759398},{"_id":"themes/hexo-theme-remind/languages/zh-CN.yaml","hash":"215ad55e8af481e3a52bf39b6fbe5c3c44013847","modified":1566467759398},{"_id":"themes/hexo-theme-remind/layout/about.pug","hash":"f0e8c8f0139d7c3b6432ff84b96aa2fbb514747c","modified":1566467759399},{"_id":"themes/hexo-theme-remind/layout/archive.pug","hash":"1ba5e001c5a71b9a6b6f9bbe07fabf52cbd8e5b2","modified":1566467759400},{"_id":"themes/hexo-theme-remind/layout/category.pug","hash":"47f2e4531c887ca72ff85d9b4d20b00adfc03169","modified":1566467759401},{"_id":"themes/hexo-theme-remind/layout/index.pug","hash":"bb57a564a25d66a27908243ba296357fc0f1873b","modified":1566467759403},{"_id":"themes/hexo-theme-remind/layout/layout.pug","hash":"258aabd9917dcefae7e455bbcd3737955b895f59","modified":1566467759405},{"_id":"themes/hexo-theme-remind/layout/post.pug","hash":"6090cd415616518d0395b67f26ca06e07d0456e3","modified":1566467759407},{"_id":"themes/hexo-theme-remind/layout/page.pug","hash":"5880f4d9062729382191ba4a28904c41c261d2cd","modified":1566467759406},{"_id":"themes/hexo-theme-remind/layout/tag.pug","hash":"9d8dd180c65a8ffdba00db1da85e58fea23d9191","modified":1566467759407},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","hash":"094b871e1da4b46b467a26225ff98a63e3602667","modified":1548235683064},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/chrome-extension-tinyurl.jpg","hash":"1e8d2043d3e1c0a50951f2538985bf9be6f69191","modified":1548235683065},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1546580545398},{"_id":"themes/hexo-theme-remind/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1566467754755},{"_id":"themes/hexo-theme-remind/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1566467754752},{"_id":"themes/hexo-theme-remind/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1566467754756},{"_id":"themes/hexo-theme-remind/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1566467754758},{"_id":"themes/hexo-theme-remind/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1566467754759},{"_id":"themes/hexo-theme-remind/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1566467754754},{"_id":"themes/hexo-theme-remind/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1566467754759},{"_id":"themes/hexo-theme-remind/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1566467754753},{"_id":"themes/hexo-theme-remind/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1566467754757},{"_id":"themes/hexo-theme-remind/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1566467754757},{"_id":"themes/hexo-theme-remind/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1566467754760},{"_id":"themes/hexo-theme-remind/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1566467754748},{"_id":"themes/hexo-theme-remind/.git/logs/HEAD","hash":"e952e1496c469123c9725569dd6d5d10ac9dff1f","modified":1566467759388},{"_id":"themes/hexo-theme-remind/source/css/reset.styl","hash":"f448d9d9c910b7a86125b103ef4b2db4c112463a","modified":1566467759408},{"_id":"themes/hexo-theme-remind/source/css/index.styl","hash":"897c8bdad36d4977324dd9559f77ceb4021eb9b3","modified":1566467759408},{"_id":"themes/hexo-theme-remind/source/css/variables.styl","hash":"3d625aefb08faa3a3ee64ff72d8b9567ef815c43","modified":1566467759409},{"_id":"themes/hexo-theme-remind/source/css/wigets.styl","hash":"2a1378560110366f1739aafad99816c1dd7a4b6b","modified":1566467759409},{"_id":"themes/hexo-theme-remind/layout/includes/footer.pug","hash":"ac90d03b797994cbabe821a39fe3f008dfd3af00","modified":1566467759402},{"_id":"themes/hexo-theme-remind/layout/includes/nav.pug","hash":"a31fbd278fe6c80acfc05d75b049eeb4f55850cc","modified":1566467759403},{"_id":"themes/hexo-theme-remind/layout/includes/head-seo.pug","hash":"a239fbe96d4191c379aa1a32f757291d4f724915","modified":1566467759402},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/cache-api-browser-compatibility.PNG","hash":"4957ba0d3f993035281b5cc03e606c0f99332dd9","modified":1548235683038},{"_id":"source/_posts/2019-05-10-shared-dev-tools/regex100.png","hash":"7f6be3d187a27b7d301e31c65287e6e8f81662f4","modified":1557465281056},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1546580545393},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1546580545390},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1546580545407},{"_id":"themes/hexo-theme-remind/.git/objects/pack/pack-487809a22d739f92f1f6c98811bf0f01db80dfb8.pack","hash":"33d0400841ffb49f69a4176ee6fde3d3834ddc03","modified":1566467759364},{"_id":"themes/hexo-theme-remind/.git/objects/pack/pack-487809a22d739f92f1f6c98811bf0f01db80dfb8.idx","hash":"78cf26398d858b451a0657a806e7c4e53109b290","modified":1566467759366},{"_id":"themes/hexo-theme-remind/.git/refs/heads/master","hash":"d3211732be93254eb26f95aced20e972bad557ac","modified":1566467759387},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1546580545391},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1546580545532},{"_id":"source/_posts/2019-05-10-shared-dev-tools/repl-nodejs.png","hash":"90fae0307054181af04429e90e0f915c422370c3","modified":1557466922233},{"_id":"source/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","hash":"4fb2c727df4e148ca7eb6271741c51e06fef3e64","modified":1548235683074},{"_id":"themes/hexo-theme-remind/.git/logs/refs/heads/master","hash":"e952e1496c469123c9725569dd6d5d10ac9dff1f","modified":1566467759388},{"_id":"themes/hexo-theme-remind/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1566467759385},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1546580545395},{"_id":"source/_posts/2019-05-10-shared-dev-tools/codepen-1.png","hash":"97c965cfcc3b5bc15b28f86f301645e31e3915cd","modified":1557466422153},{"_id":"themes/hexo-theme-remind/.git/logs/refs/remotes/origin/HEAD","hash":"e952e1496c469123c9725569dd6d5d10ac9dff1f","modified":1566467759385},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/iPad-Mini-iPhone.jpg","hash":"b0a26f4497c528d29af9482dbfbbf7864946a381","modified":1548235683070},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1546580545525},{"_id":"source/_posts/2018-12-29-summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","hash":"faa6adeb7ab81fa49c68e6f672e40ecac2174f50","modified":1546580545370},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1546580545530},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/header.jpg","hash":"238b28f52e4ade27b1fc8dd6ecc8b9f8a5598eb7","modified":1548235683047},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1546580545388},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1546580545380},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/s-b-vonlanthen-546859-unsplash.jpg","hash":"02d03917a2ececac9e5c734aecae969064ef0648","modified":1548235683063},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1546580545418},{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","hash":"a0d4f84c0b7eb1402063de408ba569814859908b","modified":1548236218677},{"_id":"source/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1546580545503},{"_id":"public/post-sitemap.xml","hash":"1248069b94367de1fd76b4d92c1165538659efcc","modified":1566544192215},{"_id":"public/page-sitemap.xml","hash":"fbca6a65f66229dde200ed7cf30170d70983c966","modified":1566544192407},{"_id":"public/tag-sitemap.xml","hash":"03d0445975285915049ef07c25ace2b4e6ca6989","modified":1566544192601},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1566467795750},{"_id":"public/sitemap.xml","hash":"c21871315157b8f81c00c351c3d83ddb6094ca66","modified":1566544194235},{"_id":"public/404.html","hash":"a744127affb8f6c73798b3fe68092328a01c4ff3","modified":1566467939970},{"_id":"public/about/index.html","hash":"1217f4fed3d720f72945a1328add2d2caec27ad0","modified":1566544194275},{"_id":"public/archive/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566467939970},{"_id":"public/tags/index.html","hash":"a744127affb8f6c73798b3fe68092328a01c4ff3","modified":1566467939971},{"_id":"public/2019/05/27/configure-env-variables-without-tears/index.html","hash":"f0d9cf359361670adae961ac0acaa74afc254c89","modified":1566467939971},{"_id":"public/2019/05/10/shared-dev-tools/index.html","hash":"be0bd3ff8e6729d99fb7b20bded59184334b7711","modified":1566467939971},{"_id":"public/2019/01/23/three-points-of-restful-api-design/index.html","hash":"fce7b6b2e7f39752d02361d65e770d7faf9ca8a2","modified":1566467939971},{"_id":"public/2019/01/11/start-to-use-tinyurl/index.html","hash":"6be4cbf5de3e5f55f28feac6c474f4eef8c4350c","modified":1566544194278},{"_id":"public/2019/01/08/what-web-cannot-do/index.html","hash":"8f6a26f60a9a11bdc59394a9ce41d5f9bbd9928f","modified":1566544194279},{"_id":"public/2018/12/29/summary-of-2018/index.html","hash":"1107728bacb337b53b44fdeda9582296889dccc2","modified":1566467939971},{"_id":"public/2018/12/26/gulp-series-2-glob/index.html","hash":"ffba5a6ac39e5b4eae6010c045686654b920d826","modified":1566467939973},{"_id":"public/2018/12/20/gulp-series-1/index.html","hash":"b842d8619f3ffb848bcc09b0c1ecb3ef2c9c918a","modified":1566467939971},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/index.html","hash":"182850b3717d0e9b67e999e0d7b3cf2209b25dfd","modified":1566544194338},{"_id":"public/2018/02/05/golang-package-etc/index.html","hash":"8caa4c174a052538510f76383b82b446ef50863c","modified":1566467939971},{"_id":"public/2018/02/02/get-started-of-golang-with-mongodb/index.html","hash":"1093b954f23eb4a8fc35c49053ed25388be37612","modified":1566467939971},{"_id":"public/2018/02/02/get-started-ejs/index.html","hash":"73ca739522cdf8290cc7bba307150da29afed811","modified":1566467939971},{"_id":"public/2015/11/20/about-file-upload-1/index.html","hash":"41676c61b75d966c89ed00e87a353a6d7ff5ca1a","modified":1566544194339},{"_id":"public/index.html","hash":"c2b5ade4c1e3e697d1d91697dd8f7a57ffced27d","modified":1566544194339},{"_id":"public/archives/2/index.html","hash":"566800cd8e929d4bf873c745bdebacb5e1fea4b1","modified":1566544194341},{"_id":"public/archives/index.html","hash":"6619d2d1724cc31f820eff1b1d33fe4e5a6b9b19","modified":1566544194339},{"_id":"public/archives/archives/2/index.html","hash":"e2b6b3b9001d534fdd851911b01faf0d3bcf5886","modified":1566544194339},{"_id":"public/archives/2015/index.html","hash":"e79d62ed1d3f84d38d62f9cd7c05f32cf56043e8","modified":1566467939972},{"_id":"public/archives/2015/11/index.html","hash":"e79d62ed1d3f84d38d62f9cd7c05f32cf56043e8","modified":1566467939972},{"_id":"public/archives/2018/index.html","hash":"209e56abdbc522b420a6b68d54794d6250a516c1","modified":1566467939972},{"_id":"public/archives/2018/02/index.html","hash":"8804975472298a267283e402e018789f4a239e2f","modified":1566467939972},{"_id":"public/archives/2018/06/index.html","hash":"c38f935a6e0a1b6f2cd51d42ec98c97d01f7351e","modified":1566467939972},{"_id":"public/archives/2018/12/index.html","hash":"273ae0ee7b077f1b9bbd06f756eeb8a99d1fa050","modified":1566467939972},{"_id":"public/archives/2019/index.html","hash":"9b28e572f0750507ee90907f28b951be227f803f","modified":1566544194341},{"_id":"public/archives/2019/01/index.html","hash":"b3b272152fbd3ac60007d489592c55fa252c6161","modified":1566467939972},{"_id":"public/archives/2019/05/index.html","hash":"e9a50982a9ee70330bda2a6486f523dd637e7b2e","modified":1566544194341},{"_id":"public/tags/gulp/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/前端工程/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/tiny-url/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/url-shortener/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/web-app/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/pwa/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/小程序/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/hybrid-app/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/restful-api/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939972},{"_id":"public/tags/工欲善其事/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/create-react-app/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/文件上传/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/http/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/ejs/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/模板引擎/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/micro-service/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/思考/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/总结/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/沟通能力/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/tags/职业发展/index.html","hash":"ae064bbee06b6dd9235f43633986a74d74f5709c","modified":1566467939973},{"_id":"public/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1566467795795},{"_id":"public/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1566467795795},{"_id":"public/2019/01/11/start-to-use-tinyurl/chrome-extension-tinyurl.jpg","hash":"1e8d2043d3e1c0a50951f2538985bf9be6f69191","modified":1566467795795},{"_id":"public/2019/01/08/what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","hash":"094b871e1da4b46b467a26225ff98a63e3602667","modified":1566467795795},{"_id":"public/2019/01/08/what-web-cannot-do/cache-api-browser-compatibility.PNG","hash":"4957ba0d3f993035281b5cc03e606c0f99332dd9","modified":1566467796145},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566467796167},{"_id":"public/css/reset.css","hash":"8142d3ae65136cc13afdfca6de8cfb5614ac64ae","modified":1566467796167},{"_id":"public/css/wigets.css","hash":"7148ccdf74605aa435bfbf5b086e6918e4d926e8","modified":1566467796167},{"_id":"public/css/index.css","hash":"682bd8abb6b844c7b283512ad686ee0e5e2a83fc","modified":1566467796167},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1566467796167},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1566467796167},{"_id":"public/2019/05/10/shared-dev-tools/regex100.png","hash":"7f6be3d187a27b7d301e31c65287e6e8f81662f4","modified":1566467796167},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1566467796239},{"_id":"public/img/header_img/tumblr_og2psdFWXX1tomxvuo6_1280.jpg","hash":"4fb2c727df4e148ca7eb6271741c51e06fef3e64","modified":1566467796267},{"_id":"public/2019/05/10/shared-dev-tools/repl-nodejs.png","hash":"90fae0307054181af04429e90e0f915c422370c3","modified":1566467796267},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1566467796268},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1566467796304},{"_id":"public/2019/05/10/shared-dev-tools/codepen-1.png","hash":"97c965cfcc3b5bc15b28f86f301645e31e3915cd","modified":1566467796304},{"_id":"public/2019/01/11/start-to-use-tinyurl/iPad-Mini-iPhone.jpg","hash":"b0a26f4497c528d29af9482dbfbbf7864946a381","modified":1566467796524},{"_id":"public/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1566467796524},{"_id":"public/2018/12/29/summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","hash":"faa6adeb7ab81fa49c68e6f672e40ecac2174f50","modified":1566467796532},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1566467796568},{"_id":"public/2019/01/08/what-web-cannot-do/header.jpg","hash":"238b28f52e4ade27b1fc8dd6ecc8b9f8a5598eb7","modified":1566467796580},{"_id":"public/2015/11/20/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1566467796597},{"_id":"public/2019/01/08/what-web-cannot-do/s-b-vonlanthen-546859-unsplash.jpg","hash":"02d03917a2ececac9e5c734aecae969064ef0648","modified":1566467796603},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1566467796682},{"_id":"public/2019/01/23/three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","hash":"a0d4f84c0b7eb1402063de408ba569814859908b","modified":1566467796739},{"_id":"public/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1566467796887},{"_id":"source/projects/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566468090293},{"_id":"source/img/s-b-vonlanthen-546859-unsplash.jpg","hash":"02d03917a2ececac9e5c734aecae969064ef0648","modified":1566469011063},{"_id":"public/projects/index.html","hash":"46ff42fbe8c5b507add72438e9bb8f708643b8cf","modified":1566544194338}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-01-04T05:42:25.361Z","updated":"2019-01-04T05:42:25.361Z","path":"404.html","title":"","comments":1,"_id":"cjzmih96l00000n82pfdp4tb1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"关于我","icon":"fa-user","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/reed-xia-790819-unsplash.jpg","comments":1,"_content":"\n网络工程毕业，曾经梦想进入华为或者中兴，却被 Infosys 的 HR 忽悠到杭州，干了两年多 EBS。然而对 EBS 的唯一印象是，这界面 TM 卡啊，这 table 真 TM 复杂。\n\n跌跌撞撞地做了几个 EBS 项目，越来越觉得毫无趣味。于是开始捣鼓 java tool，在办公室不能自由上网的条件下，硬是用 awt + jdbc 做了一个可以批量 query 并将数据保存为 excel 的小工具，据说，我离职后同事们依然用它来跑任务。这让我得意了很长一段时间，同时也让我颇受感动：只要能解决问题，就不怕没人用。做软件的真谛也即是如此。后来我辗转几家公司，反复寻觅的也是愿意踏踏实实解决问题的团队和项目。我的大部分业余时间也是奉献给了相关的事情。\n\n后来，离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 **java** 。虽然在此之前， 我的所有 **java** 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。\n\n当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”\n\n如果不是后来阴差阳错，又转而做起了 **js**，我的人生可能又会是另一番模样。谁知道呢？\n\n# 和 js 的缘分\n\n参加工作以来，经历过两段**闲的蛋疼**的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。\n\n![phone.jpg](samsung-galaxy-mini-s5570.jpg)\n\n第二段则是在第二家公司，也就是那家中国公司。\n\n进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 **tab**，**dropdown** ，当然顺便也学了 **html** 和 **css** 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 **java** 写工具，深知 **layout** 和 **event listener** 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：\n\n![happy.jpg](s-b-vonlanthen-546859-unsplash.jpg)\n\n从此以后，我就“义无反顾”的加入了前端大军。\n\n我喜欢看小说，尤其是历史小说，如《明朝那些事儿》，《大明1566》。于我而言，这些历史事件历史人物，是可以审视交流的鲜活的声明。很多人说历史是死的，是过去的事情，但过去的事情未必不会重演，未来的人也未必不会重蹈覆辙。很多闪光的瞬间也未必会随着其人的逝去而再无踪迹。\n\n一般情况下，我的所有文章都会发布到这个博客。不仅是技术文，也包括各种读书笔记，感想，甚至影评，时事评论。也会转载我在其他平台发布的文章，或者值得记录下来的知识问答（知乎）。\n\n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于我\"\nicon: fa-user # the font awesome icon used for this page\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img:  \"img/header_img/reed-xia-790819-unsplash.jpg\"\ncomments: true\n---\n\n网络工程毕业，曾经梦想进入华为或者中兴，却被 Infosys 的 HR 忽悠到杭州，干了两年多 EBS。然而对 EBS 的唯一印象是，这界面 TM 卡啊，这 table 真 TM 复杂。\n\n跌跌撞撞地做了几个 EBS 项目，越来越觉得毫无趣味。于是开始捣鼓 java tool，在办公室不能自由上网的条件下，硬是用 awt + jdbc 做了一个可以批量 query 并将数据保存为 excel 的小工具，据说，我离职后同事们依然用它来跑任务。这让我得意了很长一段时间，同时也让我颇受感动：只要能解决问题，就不怕没人用。做软件的真谛也即是如此。后来我辗转几家公司，反复寻觅的也是愿意踏踏实实解决问题的团队和项目。我的大部分业余时间也是奉献给了相关的事情。\n\n后来，离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 **java** 。虽然在此之前， 我的所有 **java** 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。\n\n当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”\n\n如果不是后来阴差阳错，又转而做起了 **js**，我的人生可能又会是另一番模样。谁知道呢？\n\n# 和 js 的缘分\n\n参加工作以来，经历过两段**闲的蛋疼**的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。\n\n![phone.jpg](samsung-galaxy-mini-s5570.jpg)\n\n第二段则是在第二家公司，也就是那家中国公司。\n\n进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 **tab**，**dropdown** ，当然顺便也学了 **html** 和 **css** 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 **java** 写工具，深知 **layout** 和 **event listener** 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：\n\n![happy.jpg](s-b-vonlanthen-546859-unsplash.jpg)\n\n从此以后，我就“义无反顾”的加入了前端大军。\n\n我喜欢看小说，尤其是历史小说，如《明朝那些事儿》，《大明1566》。于我而言，这些历史事件历史人物，是可以审视交流的鲜活的声明。很多人说历史是死的，是过去的事情，但过去的事情未必不会重演，未来的人也未必不会重蹈覆辙。很多闪光的瞬间也未必会随着其人的逝去而再无踪迹。\n\n一般情况下，我的所有文章都会发布到这个博客。不仅是技术文，也包括各种读书笔记，感想，甚至影评，时事评论。也会转载我在其他平台发布的文章，或者值得记录下来的知识问答（知乎）。\n\n\n\n","updated":"2019-08-22T10:27:25.723Z","path":"about/index.html","_id":"cjzmih97d00010n82h3nefz8d","content":"<p>网络工程毕业，曾经梦想进入华为或者中兴，却被 Infosys 的 HR 忽悠到杭州，干了两年多 EBS。然而对 EBS 的唯一印象是，这界面 TM 卡啊，这 table 真 TM 复杂。</p>\n<p>跌跌撞撞地做了几个 EBS 项目，越来越觉得毫无趣味。于是开始捣鼓 java tool，在办公室不能自由上网的条件下，硬是用 awt + jdbc 做了一个可以批量 query 并将数据保存为 excel 的小工具，据说，我离职后同事们依然用它来跑任务。这让我得意了很长一段时间，同时也让我颇受感动：只要能解决问题，就不怕没人用。做软件的真谛也即是如此。后来我辗转几家公司，反复寻觅的也是愿意踏踏实实解决问题的团队和项目。我的大部分业余时间也是奉献给了相关的事情。</p>\n<p>后来，离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 <strong>java</strong> 。虽然在此之前， 我的所有 <strong>java</strong> 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。</p>\n<p>当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。<br>\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”</p>\n<p>如果不是后来阴差阳错，又转而做起了 <strong>js</strong>，我的人生可能又会是另一番模样。谁知道呢？</p>\n<h1><span id=\"和-js-的缘分\">和 js 的缘分</span></h1>\n<p>参加工作以来，经历过两段<strong>闲的蛋疼</strong>的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。</p>\n<p><img src=\"samsung-galaxy-mini-s5570.jpg\" alt=\"phone.jpg\"></p>\n<p>第二段则是在第二家公司，也就是那家中国公司。</p>\n<p>进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 <strong>tab</strong>，<strong>dropdown</strong> ，当然顺便也学了 <strong>html</strong> 和 <strong>css</strong> 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 <strong>java</strong> 写工具，深知 <strong>layout</strong> 和 <strong>event listener</strong> 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：</p>\n<p><img src=\"s-b-vonlanthen-546859-unsplash.jpg\" alt=\"happy.jpg\"></p>\n<p>从此以后，我就“义无反顾”的加入了前端大军。</p>\n<p>我喜欢看小说，尤其是历史小说，如《明朝那些事儿》，《大明1566》。于我而言，这些历史事件历史人物，是可以审视交流的鲜活的声明。很多人说历史是死的，是过去的事情，但过去的事情未必不会重演，未来的人也未必不会重蹈覆辙。很多闪光的瞬间也未必会随着其人的逝去而再无踪迹。</p>\n<p>一般情况下，我的所有文章都会发布到这个博客。不仅是技术文，也包括各种读书笔记，感想，甚至影评，时事评论。也会转载我在其他平台发布的文章，或者值得记录下来的知识问答（知乎）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>网络工程毕业，曾经梦想进入华为或者中兴，却被 Infosys 的 HR 忽悠到杭州，干了两年多 EBS。然而对 EBS 的唯一印象是，这界面 TM 卡啊，这 table 真 TM 复杂。</p>\n<p>跌跌撞撞地做了几个 EBS 项目，越来越觉得毫无趣味。于是开始捣鼓 java tool，在办公室不能自由上网的条件下，硬是用 awt + jdbc 做了一个可以批量 query 并将数据保存为 excel 的小工具，据说，我离职后同事们依然用它来跑任务。这让我得意了很长一段时间，同时也让我颇受感动：只要能解决问题，就不怕没人用。做软件的真谛也即是如此。后来我辗转几家公司，反复寻觅的也是愿意踏踏实实解决问题的团队和项目。我的大部分业余时间也是奉献给了相关的事情。</p>\n<p>后来，离开了那家做 EBS 的公司，选择进入一家中国软件公司，做 <strong>java</strong> 。虽然在此之前， 我的所有 <strong>java</strong> 的所有经验几乎都来自于业余练习，但凭着能说会道（会忽悠）外加技术确实不错（在第一家公司造了一些轮子），还是成功拿到了 offer，而且不止一份。最终选择家中国软件公司，完全是因为我想换个口味。</p>\n<p>当然，我拒绝其他 offer 的时候，完全又是另一副冠冕堂皇的嘴脸。<br>\n“对不起，我深思熟虑后，觉得自己不适合贵公司。非常抱歉。”</p>\n<p>如果不是后来阴差阳错，又转而做起了 <strong>js</strong>，我的人生可能又会是另一番模样。谁知道呢？</p>\n<h1>和 js 的缘分</h1>\n<p>参加工作以来，经历过两段<strong>闲的蛋疼</strong>的日子。第一段是在第一家公司实习混日子的时候，天天聊天打屁看小说，《明朝那些事儿》就是那段时间用人生中第一部智能手机刷完的。</p>\n<p><img src=\"samsung-galaxy-mini-s5570.jpg\" alt=\"phone.jpg\"></p>\n<p>第二段则是在第二家公司，也就是那家中国公司。</p>\n<p>进入第二家公司后，大概 4 个月没什么正事，可是项目源码都翻烂了。百无聊赖，就开始学 js。语法很简单，可是光看语法写 1 + 1 有什么意思呢？ 于是就开始造各种东西。那时候做前端控件还是用 jquery，于是就自己写了诸如 <strong>tab</strong>，<strong>dropdown</strong> ，当然顺便也学了 <strong>html</strong> 和 <strong>css</strong> 。即使以当时的眼光来看，这些作品也算不上精致。但我乐在其中。因为一直以来，我用 <strong>java</strong> 写工具，深知 <strong>layout</strong> 和 <strong>event listener</strong> 的繁琐，调试也及其不方便。而运行在浏览器里的 js 太方便了，我要做的只是改代码，刷新，就可以立马看到效果了。我当时心情如下：</p>\n<p><img src=\"s-b-vonlanthen-546859-unsplash.jpg\" alt=\"happy.jpg\"></p>\n<p>从此以后，我就“义无反顾”的加入了前端大军。</p>\n<p>我喜欢看小说，尤其是历史小说，如《明朝那些事儿》，《大明1566》。于我而言，这些历史事件历史人物，是可以审视交流的鲜活的声明。很多人说历史是死的，是过去的事情，但过去的事情未必不会重演，未来的人也未必不会重蹈覆辙。很多闪光的瞬间也未必会随着其人的逝去而再无踪迹。</p>\n<p>一般情况下，我的所有文章都会发布到这个博客。不仅是技术文，也包括各种读书笔记，感想，甚至影评，时事评论。也会转载我在其他平台发布的文章，或者值得记录下来的知识问答（知乎）。</p>\n"},{"layout":"archive","title":"归档","icon":"fa-folder","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"归档\"\nicon: fa-folder # the font awesome icon used for this page\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-01-23T09:28:03.071Z","path":"archive/index.html","_id":"cjzmih97k00030n829hjxrvnx","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"标签","icon":"fa-flag","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"标签\"\nicon: fa-flag # the font awesome icon used for this page\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2019-01-23T09:28:03.074Z","updated":"2019-01-23T09:28:03.074Z","path":"tags/index.html","comments":1,"_id":"cjzmih97q00060n8274jqupr6","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"projects/index.md","raw":"","date":"2019-08-22T10:01:30.293Z","updated":"2019-08-22T10:01:30.293Z","path":"projects/index.html","title":"","comments":1,"layout":"page","_id":"cjznryi9h0000mw82zcdjtckj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"gulp 拾遗 (2) - 认识 glob","catalog":true,"date":"2018-12-26T09:05:16.000Z","subtitle":"一直纠结于书写各种文件查找脚本，直到遇见 glob","header-img":null,"_content":"# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","source":"_posts/2018-12-26-gulp-series-2-glob.md","raw":"---\ntitle: gulp 拾遗 (2) - 认识 glob \ncatalog: true\ndate: 2018-12-26 17:05:16\nsubtitle: 一直纠结于书写各种文件查找脚本，直到遇见 glob\nheader-img:\ntags: [gulp,前端工程]\n---\n# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","slug":"gulp-series-2-glob","published":1,"updated":"2019-01-04T05:42:25.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih97e00020n82injxq07e","content":"<h1><span id=\"为什么要用-glob\">为什么要用 glob</span></h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1><span id=\"node-glob\">node-glob</span></h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"pattern\">pattern</span></h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2><span id=\"options\">options</span></h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3><span id=\"cwd\">cwd</span></h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3><span id=\"ignore\">ignore</span></h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1><span id=\"gulp-中的-glob\">gulp 中的 glob</span></h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1><span id=\"其他脚本中的-glob\">其他脚本中的 glob</span></h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1><span id=\"总结\">总结</span></h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>为什么要用 glob</h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1>node-glob</h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2>pattern</h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2>options</h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3>cwd</h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3>ignore</h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1>gulp 中的 glob</h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1>其他脚本中的 glob</h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1>总结</h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n"},{"title":"gulp 拾遗 - nodejs/配置文件/环境变量","catalog":true,"date":"2018-12-20T06:38:57.000Z","subtitle":"在学习之前，有必要夯实基础","header-img":null,"_content":"## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","source":"_posts/2018-12-20-gulp-series-1.md","raw":"---\ntitle: gulp 拾遗 - nodejs/配置文件/环境变量\ncatalog: true\ndate: 2018-12-20 14:38:57\nsubtitle: 在学习之前，有必要夯实基础\nheader-img: \ntags: [gulp,前端工程]\n---\n## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","slug":"gulp-series-1","published":1,"updated":"2019-01-04T05:42:25.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih97l00040n820rwwe460","content":"<h2><span id=\"楔子\">楔子</span></h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2><span id=\"nodejs\">Nodejs</span></h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"gulp-任务\">gulp 任务</span></h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"配制文件\">配制文件</span></h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2><span id=\"环境变量\">环境变量</span></h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>楔子</h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2>Nodejs</h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2>gulp 任务</h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2>配制文件</h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2>环境变量</h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2>总结</h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n"},{"title":"tiny url - 相见恨晚","catalog":true,"date":"2019-01-11T06:30:54.000Z","subtitle":null,"header-img":"iPad-Mini-iPhone.jpg","summary":"url 越来越长，阅读和传播都很不方便。tinyurl 可以随机生成一个短 url，帮你自动跳转到原始 url，完美解决了这个生活难题。","_content":"\n# 楔子\n刚开始做 **scrum master** 的时候，经常要发邮件广播 **user story** 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 **search query** 来搜索指定的内容。通常，我会将这些 **user store** 的 **search query** 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 **display text**，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。\n\n我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。\n\n这就是 **tiny url**。\n\n# tiny url\n**tiny url** 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。\n\n这是 [tiny url 官网](https://tinyurl.com/)，以及首页简介。\n> Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you've come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.\n\ntiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 [rebrandly](https://developers.rebrandly.com/)，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 [tinyurl](https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en)。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。\n\n![chrome-extension-tinyurl.jpg](chrome-extension-tinyurl.jpg)\n\n# 应用场景\n1. 使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 **tiny url** 是个不错的办法。\n2. 在某通讯工具中其假想敌的产品链接。[知乎上有过类似讨论](https://www.zhihu.com/question/37871221)。\n\n# tiny product\ntiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。**不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地**。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-01-11-start-to-use-tinyurl.md","raw":"---\ntitle: tiny url - 相见恨晚\ncatalog: true\ndate: 2019-01-11 14:30:54\nsubtitle:\nheader-img: iPad-Mini-iPhone.jpg\ntags: [tiny-url, url-shortener]\nsummary: url 越来越长，阅读和传播都很不方便。tinyurl 可以随机生成一个短 url，帮你自动跳转到原始 url，完美解决了这个生活难题。\n---\n\n# 楔子\n刚开始做 **scrum master** 的时候，经常要发邮件广播 **user story** 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 **search query** 来搜索指定的内容。通常，我会将这些 **user store** 的 **search query** 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 **display text**，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。\n\n我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。\n\n这就是 **tiny url**。\n\n# tiny url\n**tiny url** 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。\n\n这是 [tiny url 官网](https://tinyurl.com/)，以及首页简介。\n> Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you've come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.\n\ntiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 [rebrandly](https://developers.rebrandly.com/)，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 [tinyurl](https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en)。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。\n\n![chrome-extension-tinyurl.jpg](chrome-extension-tinyurl.jpg)\n\n# 应用场景\n1. 使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 **tiny url** 是个不错的办法。\n2. 在某通讯工具中其假想敌的产品链接。[知乎上有过类似讨论](https://www.zhihu.com/question/37871221)。\n\n# tiny product\ntiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。**不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地**。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。\n\n\n\n\n\n\n\n\n\n\n","slug":"start-to-use-tinyurl","published":1,"updated":"2019-08-22T10:12:25.571Z","_id":"cjzmih97q00070n820i91cq4y","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"楔子\">楔子</span></h1>\n<p>刚开始做 <strong>scrum master</strong> 的时候，经常要发邮件广播 <strong>user story</strong> 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 <strong>search query</strong> 来搜索指定的内容。通常，我会将这些 <strong>user store</strong> 的 <strong>search query</strong> 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 <strong>display text</strong>，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。</p>\n<p>我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。</p>\n<p>这就是 <strong>tiny url</strong>。</p>\n<h1><span id=\"tiny-url\">tiny url</span></h1>\n<p><strong>tiny url</strong> 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。</p>\n<p>这是 <a href=\"https://tinyurl.com/\" target=\"_blank\" rel=\"noopener\">tiny url 官网</a>，以及首页简介。</p>\n<blockquote>\n<p>Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you’ve come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.</p>\n</blockquote>\n<p>tiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 <a href=\"https://developers.rebrandly.com/\" target=\"_blank\" rel=\"noopener\">rebrandly</a>，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en\" target=\"_blank\" rel=\"noopener\">tinyurl</a>。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。</p>\n<p><img src=\"chrome-extension-tinyurl.jpg\" alt=\"chrome-extension-tinyurl.jpg\"></p>\n<h1><span id=\"应用场景\">应用场景</span></h1>\n<ol>\n<li>使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 <strong>tiny url</strong> 是个不错的办法。</li>\n<li>在某通讯工具中其假想敌的产品链接。<a href=\"https://www.zhihu.com/question/37871221\" target=\"_blank\" rel=\"noopener\">知乎上有过类似讨论</a>。</li>\n</ol>\n<h1><span id=\"tiny-product\">tiny product</span></h1>\n<p>tiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。<strong>不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地</strong>。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>楔子</h1>\n<p>刚开始做 <strong>scrum master</strong> 的时候，经常要发邮件广播 <strong>user story</strong> 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 <strong>search query</strong> 来搜索指定的内容。通常，我会将这些 <strong>user store</strong> 的 <strong>search query</strong> 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 <strong>display text</strong>，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。</p>\n<p>我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。</p>\n<p>这就是 <strong>tiny url</strong>。</p>\n<h1>tiny url</h1>\n<p><strong>tiny url</strong> 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。</p>\n<p>这是 <a href=\"https://tinyurl.com/\" target=\"_blank\" rel=\"noopener\">tiny url 官网</a>，以及首页简介。</p>\n<blockquote>\n<p>Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you’ve come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.</p>\n</blockquote>\n<p>tiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 <a href=\"https://developers.rebrandly.com/\" target=\"_blank\" rel=\"noopener\">rebrandly</a>，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en\" target=\"_blank\" rel=\"noopener\">tinyurl</a>。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。</p>\n<p><img src=\"chrome-extension-tinyurl.jpg\" alt=\"chrome-extension-tinyurl.jpg\"></p>\n<h1>应用场景</h1>\n<ol>\n<li>使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 <strong>tiny url</strong> 是个不错的办法。</li>\n<li>在某通讯工具中其假想敌的产品链接。<a href=\"https://www.zhihu.com/question/37871221\" target=\"_blank\" rel=\"noopener\">知乎上有过类似讨论</a>。</li>\n</ol>\n<h1>tiny product</h1>\n<p>tiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。<strong>不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地</strong>。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。</p>\n"},{"title":"震惊，web app 不能做的 N 件事","catalog":true,"date":"2019-01-08T08:45:37.000Z","subtitle":null,"header-img":"header.jpg","summary":"web app 开发和维护的成本相对较低，这是很多内容创业公司刚开始都会选择 web 的原因，是它固有的优势。它的劣势也很多，无法充分利用 cpu，ui 效率不高，等等。","_content":"\n# web app 的优势\n我理解的**web app**其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如20世纪初涌现的各大门户网站。而**web app** 则两者相辅相成，甚至完全以媲美原生应用的交互体验为主（比如 teambition）。\n\n原生应用（**native app**）指的是需要安装到系统上才能使用的应用。说到 web app 的优势，一般都要历数 native app 的各种「罪状」，如安装麻烦，兼容性差，升级不便。似乎 web app 的诞生就是以取代 native app 为目标的。\n\n不相信吗？那我们一个一个说。\n\n## 无需安装\nnative app 需要安装，这是显而易见的。熟知的 qq，微信，office，乃至各类大小型游戏，想要使用它们，必须经历枯燥的下载 -》 安装，中间过程比我们肉眼所见更为复杂。更别提寻找可靠的安装文件所要花费的精力。如果不小心安装了流氓软件，后续的卸载清理也是不小的工程。\n\nweb app 完全不需要这么麻烦。你需要的时候，只需要打开任何一个浏览器，输入地址或者打开收藏夹找到对应的链接，就可以开始使用了。不需要了，关掉对应的标签或者窗口。理论上讲，在别的电脑上使用这些 web app 也是一样的容易。你不必像使用 native app 一样反复的安装。\n\n随着浏览器功能的增强和丰富，web app 开始蚕食 native app 的领地。图像处理，文本编辑，web app 在这些方面汇集了双方的优势，变得越来越不可忽视。以我为例，做一些简单的测试或者原型，会使用诸如 repl，codesandbox，codepen 这些 web app。功能够用并且足够傻瓜。\n\n## 无缝更新 \n上面说 web app 无需安装，从技术上来讲，这是不准确的。web app 也有代码，资源文件，在实际运行之前，也需要等待这些文件下载完成。只不过相比于 native app 庞大的安装包来说，web app 所依赖的「安装包」，从体积上来说，足够轻量。这是因为，native app 需要很多额外的 sdk/lib 来提供必要的支持，而浏览器本身已经准备好了「足够」的支持。web app 运行于浏览器之上，自不需要再像 native app 一样「自力更生」。\n\n浏览器之于 web app，就像操作系统+sdk之于 native app。\n\n从这里看，web app 并非不需要更新，而是它的更新太简单了 - 服务器端部署新代码，客户浏览器打开 web app 下载到新代码所赋予的更新。搭配上合理的缓存机制，web app 的十分安静，所谓「无缝更新」。而 native app 必须要下载一个相对较大的安装包，来取代已经安装的应用。这个过程牵涉到系统的权限，存储，所以并不「安静」。所以，web app 频繁的更新并不稀奇，native app 则应该尽量避免太频繁的更新，因为过度打扰用户不是好事。\n\n## 跨平台\n我们已经知道 web app 运行于浏览器（或者浏览器环境）之上，所以 web app 的跨平台指的并不是跨操作系统平台，而是跨浏览器。早期并不存在跨浏览器这个说法，事实上那个年代也不需要，因为 web app 还未诞生。直到 js 成为浏览器事实上的编程语言，跨浏览器才成为一个需要去解决的难题。我们看到现在跨浏览器并不是什么值得大说特说的价值，因为这个难题已经几乎解决了。怎么解决的呢？一般我说到这里的时候要列出三个阶段。\n\n1 蛮荒时代\nweb 早期，浏览器环境差异极大，比较出名的是 event binder 上的差异。js 语言天生的灵活性在处理这种差异的时候得心应手，并且足够简单直接。这是 web 的蛮荒时代，也是百花齐放的时代。我曾经就收集了很多这样的代码片段，文件，即便是现在看起来，也会被前辈们的聪明才智所深深折服。\n2 jquery \njquery 最杀手级的功能，是它完全复刻了 css selector。早期的 js 搜索 dom 的 api 相当简陋，尤其是不能按照层级关系搜索 dom（而有一定经验的 css writer 一定会大量的使用后代或者兄弟 selector）。jquery selector 填补了这片空白，而且做的很棒。初次之外，jquery 优秀的 api 设计，效率，都深刻的影响着后来者，和它的追随者。比如我以前写 lib 就不由自主的模仿 jquery 导出 instance 的方式。\n3 殊途同归\n时至今日，jquery 已经不再是舞台上的 super star。一方面是因为强调交互的 web app 迫切的需要高开发效率的 mvvm 支持，另一方面，是浏览器们越来越同质化，已经不需要 jquery 夹在中间做 middle ware。现在，大部分时候，你都不需要在花太多的心思处理浏览器差异，写复杂的 dom selecter，原生 js 完全够用了。\n\n<hr/>\n\n所以，web app 的跨平台不是大风刮来的，也不是一蹴而就的。\n\n但是，web app 和 native app 跨平台的难度确实是不同的，这显而易见。这就是浏览器作为中间承担跨平台底层工作，而向上提供「比较」跨平台的接口。这和 java 虚拟机的跨平台方式有相似之处。\n\n# 优势的另一面\n换一个角度，优势就变成劣势了。还是一个一个来。\n## 不能离线使用\n浏览器并不提供文件存储功能，所以，web app 想要模仿 native app 做到安装之后离线使用，是不可能的（PWA是个好东西）。浏览器就像一个传统的电视机，你要看电视，转到对应的频道就可以。看到不错的节目想保存下来以后看，对不起，人家做不到。\n\n## 不能访问本地资源\nnative app 可以依托系统资源完成功能，比如更好看的系统相册，文本阅读器，通过摄像头，麦克风录入信息（比如淘宝，京东的拍物搜索，声音搜索）。web app 受限于浏览器的安全设置，只能卡在外面看风景。\n\n## js 的黑暗面\n前端之所以入门简单，就在 js 的异步模型。写过 java swing，甚至 android 都知道使用多个线程处理事件的繁琐和难以调试，但又不得不用否则app就无法正常工作。而写 web app 则完全不需要考虑多线程，你只需要这样那样拼好项目，不管是 listen 用户指令，还是后台相应，都不担心互相影响。当然，前提是每段代码都足够快速。\n\n但有些情况下，代码运行速度会变慢，比如复杂的数据计算。js 在运行的时候浏览器，GUI渲染线程和事件触发线程不工作，所以如果js长事件运行，web app 就会变得卡顿。所以如果必须执行这样的代码，请务必了解以下 web workers。它会启动几个后台线程来运行 js。\n\n而且，js 本身的效率也并不优秀，这方面可以期望的方案是 [web assembly](https://webassembly.org/)，通过将 c++ 代码的编译结果加载到浏览器以提供更优秀的执行效率。js 在图形图像上的尴尬兴许也可以寄希望于 web assembly 的「超能力」。\n\n## 安全性\nweb app 的开放特性使得被「别有用心」的坏人利用或者伤害的门槛极低。很多黑客将矛头对准了漏洞百出的 web app，而受到威胁的 web app 的所有者们也开始武装自己。攻防双方持久对峙的结果是，一系列的安全策略，规范，被发明和广泛的利用起来，双方的内部损耗也相应变多。如何安全跨域，cros 和 window.postMessage，解决安全风险的同时，安全的通过安检也变成了不可忽视的成本。\n\n# 现实和未来\n\n现实中， web 和 native app 两者并非竞争关系，更像是相互协助的好基友。有时两者分别承担不同的用户阶段，比如 web app 负责前期的宣传，比较消耗性能或者必须利用系统资源而不得不采用 native app 的时候，由 web app 引导用户安装 native app。有时 web app 化为 native app 的一部分存在（webview），帮助 native app 完成复杂且变动频繁的界面交互（hybird app）。\n\n另外一个值得注意的是 web app native 化方案。目前主流的有 react-native，electron（其他概念类似的都不列举了），可以看出行业的发展趋势或者说最大众化的诉求，还是梦想着可以结合 web app 和 native app 的优势。特别是，在人工成本居高不下，而 AI 自动开发还遥不可期的时代，仅仅是「一次编写多平台运行」这个跨平台特性，就使得 web app native 成为一股不可忽视的声音。而只要可以跨平台而开发效率不难看，大部分人还是不怎么在乎是不是用 web 三件套的（html/css/js），比如最近火的一塌糊涂的 flutter。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-01-08-what-web-cannot-do.md","raw":"---\ntitle: 震惊，web app 不能做的 N 件事\ncatalog: true\ndate: 2019-01-08 16:45:37\nsubtitle:\nheader-img: header.jpg\ntags: [web app, pwa, 小程序, hybrid app]\nsummary: web app 开发和维护的成本相对较低，这是很多内容创业公司刚开始都会选择 web 的原因，是它固有的优势。它的劣势也很多，无法充分利用 cpu，ui 效率不高，等等。\n---\n\n# web app 的优势\n我理解的**web app**其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如20世纪初涌现的各大门户网站。而**web app** 则两者相辅相成，甚至完全以媲美原生应用的交互体验为主（比如 teambition）。\n\n原生应用（**native app**）指的是需要安装到系统上才能使用的应用。说到 web app 的优势，一般都要历数 native app 的各种「罪状」，如安装麻烦，兼容性差，升级不便。似乎 web app 的诞生就是以取代 native app 为目标的。\n\n不相信吗？那我们一个一个说。\n\n## 无需安装\nnative app 需要安装，这是显而易见的。熟知的 qq，微信，office，乃至各类大小型游戏，想要使用它们，必须经历枯燥的下载 -》 安装，中间过程比我们肉眼所见更为复杂。更别提寻找可靠的安装文件所要花费的精力。如果不小心安装了流氓软件，后续的卸载清理也是不小的工程。\n\nweb app 完全不需要这么麻烦。你需要的时候，只需要打开任何一个浏览器，输入地址或者打开收藏夹找到对应的链接，就可以开始使用了。不需要了，关掉对应的标签或者窗口。理论上讲，在别的电脑上使用这些 web app 也是一样的容易。你不必像使用 native app 一样反复的安装。\n\n随着浏览器功能的增强和丰富，web app 开始蚕食 native app 的领地。图像处理，文本编辑，web app 在这些方面汇集了双方的优势，变得越来越不可忽视。以我为例，做一些简单的测试或者原型，会使用诸如 repl，codesandbox，codepen 这些 web app。功能够用并且足够傻瓜。\n\n## 无缝更新 \n上面说 web app 无需安装，从技术上来讲，这是不准确的。web app 也有代码，资源文件，在实际运行之前，也需要等待这些文件下载完成。只不过相比于 native app 庞大的安装包来说，web app 所依赖的「安装包」，从体积上来说，足够轻量。这是因为，native app 需要很多额外的 sdk/lib 来提供必要的支持，而浏览器本身已经准备好了「足够」的支持。web app 运行于浏览器之上，自不需要再像 native app 一样「自力更生」。\n\n浏览器之于 web app，就像操作系统+sdk之于 native app。\n\n从这里看，web app 并非不需要更新，而是它的更新太简单了 - 服务器端部署新代码，客户浏览器打开 web app 下载到新代码所赋予的更新。搭配上合理的缓存机制，web app 的十分安静，所谓「无缝更新」。而 native app 必须要下载一个相对较大的安装包，来取代已经安装的应用。这个过程牵涉到系统的权限，存储，所以并不「安静」。所以，web app 频繁的更新并不稀奇，native app 则应该尽量避免太频繁的更新，因为过度打扰用户不是好事。\n\n## 跨平台\n我们已经知道 web app 运行于浏览器（或者浏览器环境）之上，所以 web app 的跨平台指的并不是跨操作系统平台，而是跨浏览器。早期并不存在跨浏览器这个说法，事实上那个年代也不需要，因为 web app 还未诞生。直到 js 成为浏览器事实上的编程语言，跨浏览器才成为一个需要去解决的难题。我们看到现在跨浏览器并不是什么值得大说特说的价值，因为这个难题已经几乎解决了。怎么解决的呢？一般我说到这里的时候要列出三个阶段。\n\n1 蛮荒时代\nweb 早期，浏览器环境差异极大，比较出名的是 event binder 上的差异。js 语言天生的灵活性在处理这种差异的时候得心应手，并且足够简单直接。这是 web 的蛮荒时代，也是百花齐放的时代。我曾经就收集了很多这样的代码片段，文件，即便是现在看起来，也会被前辈们的聪明才智所深深折服。\n2 jquery \njquery 最杀手级的功能，是它完全复刻了 css selector。早期的 js 搜索 dom 的 api 相当简陋，尤其是不能按照层级关系搜索 dom（而有一定经验的 css writer 一定会大量的使用后代或者兄弟 selector）。jquery selector 填补了这片空白，而且做的很棒。初次之外，jquery 优秀的 api 设计，效率，都深刻的影响着后来者，和它的追随者。比如我以前写 lib 就不由自主的模仿 jquery 导出 instance 的方式。\n3 殊途同归\n时至今日，jquery 已经不再是舞台上的 super star。一方面是因为强调交互的 web app 迫切的需要高开发效率的 mvvm 支持，另一方面，是浏览器们越来越同质化，已经不需要 jquery 夹在中间做 middle ware。现在，大部分时候，你都不需要在花太多的心思处理浏览器差异，写复杂的 dom selecter，原生 js 完全够用了。\n\n<hr/>\n\n所以，web app 的跨平台不是大风刮来的，也不是一蹴而就的。\n\n但是，web app 和 native app 跨平台的难度确实是不同的，这显而易见。这就是浏览器作为中间承担跨平台底层工作，而向上提供「比较」跨平台的接口。这和 java 虚拟机的跨平台方式有相似之处。\n\n# 优势的另一面\n换一个角度，优势就变成劣势了。还是一个一个来。\n## 不能离线使用\n浏览器并不提供文件存储功能，所以，web app 想要模仿 native app 做到安装之后离线使用，是不可能的（PWA是个好东西）。浏览器就像一个传统的电视机，你要看电视，转到对应的频道就可以。看到不错的节目想保存下来以后看，对不起，人家做不到。\n\n## 不能访问本地资源\nnative app 可以依托系统资源完成功能，比如更好看的系统相册，文本阅读器，通过摄像头，麦克风录入信息（比如淘宝，京东的拍物搜索，声音搜索）。web app 受限于浏览器的安全设置，只能卡在外面看风景。\n\n## js 的黑暗面\n前端之所以入门简单，就在 js 的异步模型。写过 java swing，甚至 android 都知道使用多个线程处理事件的繁琐和难以调试，但又不得不用否则app就无法正常工作。而写 web app 则完全不需要考虑多线程，你只需要这样那样拼好项目，不管是 listen 用户指令，还是后台相应，都不担心互相影响。当然，前提是每段代码都足够快速。\n\n但有些情况下，代码运行速度会变慢，比如复杂的数据计算。js 在运行的时候浏览器，GUI渲染线程和事件触发线程不工作，所以如果js长事件运行，web app 就会变得卡顿。所以如果必须执行这样的代码，请务必了解以下 web workers。它会启动几个后台线程来运行 js。\n\n而且，js 本身的效率也并不优秀，这方面可以期望的方案是 [web assembly](https://webassembly.org/)，通过将 c++ 代码的编译结果加载到浏览器以提供更优秀的执行效率。js 在图形图像上的尴尬兴许也可以寄希望于 web assembly 的「超能力」。\n\n## 安全性\nweb app 的开放特性使得被「别有用心」的坏人利用或者伤害的门槛极低。很多黑客将矛头对准了漏洞百出的 web app，而受到威胁的 web app 的所有者们也开始武装自己。攻防双方持久对峙的结果是，一系列的安全策略，规范，被发明和广泛的利用起来，双方的内部损耗也相应变多。如何安全跨域，cros 和 window.postMessage，解决安全风险的同时，安全的通过安检也变成了不可忽视的成本。\n\n# 现实和未来\n\n现实中， web 和 native app 两者并非竞争关系，更像是相互协助的好基友。有时两者分别承担不同的用户阶段，比如 web app 负责前期的宣传，比较消耗性能或者必须利用系统资源而不得不采用 native app 的时候，由 web app 引导用户安装 native app。有时 web app 化为 native app 的一部分存在（webview），帮助 native app 完成复杂且变动频繁的界面交互（hybird app）。\n\n另外一个值得注意的是 web app native 化方案。目前主流的有 react-native，electron（其他概念类似的都不列举了），可以看出行业的发展趋势或者说最大众化的诉求，还是梦想着可以结合 web app 和 native app 的优势。特别是，在人工成本居高不下，而 AI 自动开发还遥不可期的时代，仅仅是「一次编写多平台运行」这个跨平台特性，就使得 web app native 成为一股不可忽视的声音。而只要可以跨平台而开发效率不难看，大部分人还是不怎么在乎是不是用 web 三件套的（html/css/js），比如最近火的一塌糊涂的 flutter。\n\n\n\n\n\n\n\n\n\n\n","slug":"what-web-cannot-do","published":1,"updated":"2019-08-23T07:09:13.875Z","_id":"cjzmih97w00080n825te6mvfp","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"web-app-的优势\">web app 的优势</span></h1>\n<p>我理解的<strong>web app</strong>其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如20世纪初涌现的各大门户网站。而<strong>web app</strong> 则两者相辅相成，甚至完全以媲美原生应用的交互体验为主（比如 teambition）。</p>\n<p>原生应用（<strong>native app</strong>）指的是需要安装到系统上才能使用的应用。说到 web app 的优势，一般都要历数 native app 的各种「罪状」，如安装麻烦，兼容性差，升级不便。似乎 web app 的诞生就是以取代 native app 为目标的。</p>\n<p>不相信吗？那我们一个一个说。</p>\n<h2><span id=\"无需安装\">无需安装</span></h2>\n<p>native app 需要安装，这是显而易见的。熟知的 qq，微信，office，乃至各类大小型游戏，想要使用它们，必须经历枯燥的下载 -》 安装，中间过程比我们肉眼所见更为复杂。更别提寻找可靠的安装文件所要花费的精力。如果不小心安装了流氓软件，后续的卸载清理也是不小的工程。</p>\n<p>web app 完全不需要这么麻烦。你需要的时候，只需要打开任何一个浏览器，输入地址或者打开收藏夹找到对应的链接，就可以开始使用了。不需要了，关掉对应的标签或者窗口。理论上讲，在别的电脑上使用这些 web app 也是一样的容易。你不必像使用 native app 一样反复的安装。</p>\n<p>随着浏览器功能的增强和丰富，web app 开始蚕食 native app 的领地。图像处理，文本编辑，web app 在这些方面汇集了双方的优势，变得越来越不可忽视。以我为例，做一些简单的测试或者原型，会使用诸如 repl，codesandbox，codepen 这些 web app。功能够用并且足够傻瓜。</p>\n<h2><span id=\"无缝更新\">无缝更新</span></h2>\n<p>上面说 web app 无需安装，从技术上来讲，这是不准确的。web app 也有代码，资源文件，在实际运行之前，也需要等待这些文件下载完成。只不过相比于 native app 庞大的安装包来说，web app 所依赖的「安装包」，从体积上来说，足够轻量。这是因为，native app 需要很多额外的 sdk/lib 来提供必要的支持，而浏览器本身已经准备好了「足够」的支持。web app 运行于浏览器之上，自不需要再像 native app 一样「自力更生」。</p>\n<p>浏览器之于 web app，就像操作系统+sdk之于 native app。</p>\n<p>从这里看，web app 并非不需要更新，而是它的更新太简单了 - 服务器端部署新代码，客户浏览器打开 web app 下载到新代码所赋予的更新。搭配上合理的缓存机制，web app 的十分安静，所谓「无缝更新」。而 native app 必须要下载一个相对较大的安装包，来取代已经安装的应用。这个过程牵涉到系统的权限，存储，所以并不「安静」。所以，web app 频繁的更新并不稀奇，native app 则应该尽量避免太频繁的更新，因为过度打扰用户不是好事。</p>\n<h2><span id=\"跨平台\">跨平台</span></h2>\n<p>我们已经知道 web app 运行于浏览器（或者浏览器环境）之上，所以 web app 的跨平台指的并不是跨操作系统平台，而是跨浏览器。早期并不存在跨浏览器这个说法，事实上那个年代也不需要，因为 web app 还未诞生。直到 js 成为浏览器事实上的编程语言，跨浏览器才成为一个需要去解决的难题。我们看到现在跨浏览器并不是什么值得大说特说的价值，因为这个难题已经几乎解决了。怎么解决的呢？一般我说到这里的时候要列出三个阶段。</p>\n<p>1 蛮荒时代<br>\nweb 早期，浏览器环境差异极大，比较出名的是 event binder 上的差异。js 语言天生的灵活性在处理这种差异的时候得心应手，并且足够简单直接。这是 web 的蛮荒时代，也是百花齐放的时代。我曾经就收集了很多这样的代码片段，文件，即便是现在看起来，也会被前辈们的聪明才智所深深折服。<br>\n2 jquery<br>\njquery 最杀手级的功能，是它完全复刻了 css selector。早期的 js 搜索 dom 的 api 相当简陋，尤其是不能按照层级关系搜索 dom（而有一定经验的 css writer 一定会大量的使用后代或者兄弟 selector）。jquery selector 填补了这片空白，而且做的很棒。初次之外，jquery 优秀的 api 设计，效率，都深刻的影响着后来者，和它的追随者。比如我以前写 lib 就不由自主的模仿 jquery 导出 instance 的方式。<br>\n3 殊途同归<br>\n时至今日，jquery 已经不再是舞台上的 super star。一方面是因为强调交互的 web app 迫切的需要高开发效率的 mvvm 支持，另一方面，是浏览器们越来越同质化，已经不需要 jquery 夹在中间做 middle ware。现在，大部分时候，你都不需要在花太多的心思处理浏览器差异，写复杂的 dom selecter，原生 js 完全够用了。</p>\n<hr>\n<p>所以，web app 的跨平台不是大风刮来的，也不是一蹴而就的。</p>\n<p>但是，web app 和 native app 跨平台的难度确实是不同的，这显而易见。这就是浏览器作为中间承担跨平台底层工作，而向上提供「比较」跨平台的接口。这和 java 虚拟机的跨平台方式有相似之处。</p>\n<h1><span id=\"优势的另一面\">优势的另一面</span></h1>\n<p>换一个角度，优势就变成劣势了。还是一个一个来。</p>\n<h2><span id=\"不能离线使用\">不能离线使用</span></h2>\n<p>浏览器并不提供文件存储功能，所以，web app 想要模仿 native app 做到安装之后离线使用，是不可能的（PWA是个好东西）。浏览器就像一个传统的电视机，你要看电视，转到对应的频道就可以。看到不错的节目想保存下来以后看，对不起，人家做不到。</p>\n<h2><span id=\"不能访问本地资源\">不能访问本地资源</span></h2>\n<p>native app 可以依托系统资源完成功能，比如更好看的系统相册，文本阅读器，通过摄像头，麦克风录入信息（比如淘宝，京东的拍物搜索，声音搜索）。web app 受限于浏览器的安全设置，只能卡在外面看风景。</p>\n<h2><span id=\"js-的黑暗面\">js 的黑暗面</span></h2>\n<p>前端之所以入门简单，就在 js 的异步模型。写过 java swing，甚至 android 都知道使用多个线程处理事件的繁琐和难以调试，但又不得不用否则app就无法正常工作。而写 web app 则完全不需要考虑多线程，你只需要这样那样拼好项目，不管是 listen 用户指令，还是后台相应，都不担心互相影响。当然，前提是每段代码都足够快速。</p>\n<p>但有些情况下，代码运行速度会变慢，比如复杂的数据计算。js 在运行的时候浏览器，GUI渲染线程和事件触发线程不工作，所以如果js长事件运行，web app 就会变得卡顿。所以如果必须执行这样的代码，请务必了解以下 web workers。它会启动几个后台线程来运行 js。</p>\n<p>而且，js 本身的效率也并不优秀，这方面可以期望的方案是 <a href=\"https://webassembly.org/\" target=\"_blank\" rel=\"noopener\">web assembly</a>，通过将 c++ 代码的编译结果加载到浏览器以提供更优秀的执行效率。js 在图形图像上的尴尬兴许也可以寄希望于 web assembly 的「超能力」。</p>\n<h2><span id=\"安全性\">安全性</span></h2>\n<p>web app 的开放特性使得被「别有用心」的坏人利用或者伤害的门槛极低。很多黑客将矛头对准了漏洞百出的 web app，而受到威胁的 web app 的所有者们也开始武装自己。攻防双方持久对峙的结果是，一系列的安全策略，规范，被发明和广泛的利用起来，双方的内部损耗也相应变多。如何安全跨域，cros 和 window.postMessage，解决安全风险的同时，安全的通过安检也变成了不可忽视的成本。</p>\n<h1><span id=\"现实和未来\">现实和未来</span></h1>\n<p>现实中， web 和 native app 两者并非竞争关系，更像是相互协助的好基友。有时两者分别承担不同的用户阶段，比如 web app 负责前期的宣传，比较消耗性能或者必须利用系统资源而不得不采用 native app 的时候，由 web app 引导用户安装 native app。有时 web app 化为 native app 的一部分存在（webview），帮助 native app 完成复杂且变动频繁的界面交互（hybird app）。</p>\n<p>另外一个值得注意的是 web app native 化方案。目前主流的有 react-native，electron（其他概念类似的都不列举了），可以看出行业的发展趋势或者说最大众化的诉求，还是梦想着可以结合 web app 和 native app 的优势。特别是，在人工成本居高不下，而 AI 自动开发还遥不可期的时代，仅仅是「一次编写多平台运行」这个跨平台特性，就使得 web app native 成为一股不可忽视的声音。而只要可以跨平台而开发效率不难看，大部分人还是不怎么在乎是不是用 web 三件套的（html/css/js），比如最近火的一塌糊涂的 flutter。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>web app 的优势</h1>\n<p>我理解的<strong>web app</strong>其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如20世纪初涌现的各大门户网站。而<strong>web app</strong> 则两者相辅相成，甚至完全以媲美原生应用的交互体验为主（比如 teambition）。</p>\n<p>原生应用（<strong>native app</strong>）指的是需要安装到系统上才能使用的应用。说到 web app 的优势，一般都要历数 native app 的各种「罪状」，如安装麻烦，兼容性差，升级不便。似乎 web app 的诞生就是以取代 native app 为目标的。</p>\n<p>不相信吗？那我们一个一个说。</p>\n<h2>无需安装</h2>\n<p>native app 需要安装，这是显而易见的。熟知的 qq，微信，office，乃至各类大小型游戏，想要使用它们，必须经历枯燥的下载 -》 安装，中间过程比我们肉眼所见更为复杂。更别提寻找可靠的安装文件所要花费的精力。如果不小心安装了流氓软件，后续的卸载清理也是不小的工程。</p>\n<p>web app 完全不需要这么麻烦。你需要的时候，只需要打开任何一个浏览器，输入地址或者打开收藏夹找到对应的链接，就可以开始使用了。不需要了，关掉对应的标签或者窗口。理论上讲，在别的电脑上使用这些 web app 也是一样的容易。你不必像使用 native app 一样反复的安装。</p>\n<p>随着浏览器功能的增强和丰富，web app 开始蚕食 native app 的领地。图像处理，文本编辑，web app 在这些方面汇集了双方的优势，变得越来越不可忽视。以我为例，做一些简单的测试或者原型，会使用诸如 repl，codesandbox，codepen 这些 web app。功能够用并且足够傻瓜。</p>\n<h2>无缝更新</h2>\n<p>上面说 web app 无需安装，从技术上来讲，这是不准确的。web app 也有代码，资源文件，在实际运行之前，也需要等待这些文件下载完成。只不过相比于 native app 庞大的安装包来说，web app 所依赖的「安装包」，从体积上来说，足够轻量。这是因为，native app 需要很多额外的 sdk/lib 来提供必要的支持，而浏览器本身已经准备好了「足够」的支持。web app 运行于浏览器之上，自不需要再像 native app 一样「自力更生」。</p>\n<p>浏览器之于 web app，就像操作系统+sdk之于 native app。</p>\n<p>从这里看，web app 并非不需要更新，而是它的更新太简单了 - 服务器端部署新代码，客户浏览器打开 web app 下载到新代码所赋予的更新。搭配上合理的缓存机制，web app 的十分安静，所谓「无缝更新」。而 native app 必须要下载一个相对较大的安装包，来取代已经安装的应用。这个过程牵涉到系统的权限，存储，所以并不「安静」。所以，web app 频繁的更新并不稀奇，native app 则应该尽量避免太频繁的更新，因为过度打扰用户不是好事。</p>\n<h2>跨平台</h2>\n<p>我们已经知道 web app 运行于浏览器（或者浏览器环境）之上，所以 web app 的跨平台指的并不是跨操作系统平台，而是跨浏览器。早期并不存在跨浏览器这个说法，事实上那个年代也不需要，因为 web app 还未诞生。直到 js 成为浏览器事实上的编程语言，跨浏览器才成为一个需要去解决的难题。我们看到现在跨浏览器并不是什么值得大说特说的价值，因为这个难题已经几乎解决了。怎么解决的呢？一般我说到这里的时候要列出三个阶段。</p>\n<p>1 蛮荒时代<br>\nweb 早期，浏览器环境差异极大，比较出名的是 event binder 上的差异。js 语言天生的灵活性在处理这种差异的时候得心应手，并且足够简单直接。这是 web 的蛮荒时代，也是百花齐放的时代。我曾经就收集了很多这样的代码片段，文件，即便是现在看起来，也会被前辈们的聪明才智所深深折服。<br>\n2 jquery<br>\njquery 最杀手级的功能，是它完全复刻了 css selector。早期的 js 搜索 dom 的 api 相当简陋，尤其是不能按照层级关系搜索 dom（而有一定经验的 css writer 一定会大量的使用后代或者兄弟 selector）。jquery selector 填补了这片空白，而且做的很棒。初次之外，jquery 优秀的 api 设计，效率，都深刻的影响着后来者，和它的追随者。比如我以前写 lib 就不由自主的模仿 jquery 导出 instance 的方式。<br>\n3 殊途同归<br>\n时至今日，jquery 已经不再是舞台上的 super star。一方面是因为强调交互的 web app 迫切的需要高开发效率的 mvvm 支持，另一方面，是浏览器们越来越同质化，已经不需要 jquery 夹在中间做 middle ware。现在，大部分时候，你都不需要在花太多的心思处理浏览器差异，写复杂的 dom selecter，原生 js 完全够用了。</p>\n<hr>\n<p>所以，web app 的跨平台不是大风刮来的，也不是一蹴而就的。</p>\n<p>但是，web app 和 native app 跨平台的难度确实是不同的，这显而易见。这就是浏览器作为中间承担跨平台底层工作，而向上提供「比较」跨平台的接口。这和 java 虚拟机的跨平台方式有相似之处。</p>\n<h1>优势的另一面</h1>\n<p>换一个角度，优势就变成劣势了。还是一个一个来。</p>\n<h2>不能离线使用</h2>\n<p>浏览器并不提供文件存储功能，所以，web app 想要模仿 native app 做到安装之后离线使用，是不可能的（PWA是个好东西）。浏览器就像一个传统的电视机，你要看电视，转到对应的频道就可以。看到不错的节目想保存下来以后看，对不起，人家做不到。</p>\n<h2>不能访问本地资源</h2>\n<p>native app 可以依托系统资源完成功能，比如更好看的系统相册，文本阅读器，通过摄像头，麦克风录入信息（比如淘宝，京东的拍物搜索，声音搜索）。web app 受限于浏览器的安全设置，只能卡在外面看风景。</p>\n<h2>js 的黑暗面</h2>\n<p>前端之所以入门简单，就在 js 的异步模型。写过 java swing，甚至 android 都知道使用多个线程处理事件的繁琐和难以调试，但又不得不用否则app就无法正常工作。而写 web app 则完全不需要考虑多线程，你只需要这样那样拼好项目，不管是 listen 用户指令，还是后台相应，都不担心互相影响。当然，前提是每段代码都足够快速。</p>\n<p>但有些情况下，代码运行速度会变慢，比如复杂的数据计算。js 在运行的时候浏览器，GUI渲染线程和事件触发线程不工作，所以如果js长事件运行，web app 就会变得卡顿。所以如果必须执行这样的代码，请务必了解以下 web workers。它会启动几个后台线程来运行 js。</p>\n<p>而且，js 本身的效率也并不优秀，这方面可以期望的方案是 <a href=\"https://webassembly.org/\" target=\"_blank\" rel=\"noopener\">web assembly</a>，通过将 c++ 代码的编译结果加载到浏览器以提供更优秀的执行效率。js 在图形图像上的尴尬兴许也可以寄希望于 web assembly 的「超能力」。</p>\n<h2>安全性</h2>\n<p>web app 的开放特性使得被「别有用心」的坏人利用或者伤害的门槛极低。很多黑客将矛头对准了漏洞百出的 web app，而受到威胁的 web app 的所有者们也开始武装自己。攻防双方持久对峙的结果是，一系列的安全策略，规范，被发明和广泛的利用起来，双方的内部损耗也相应变多。如何安全跨域，cros 和 window.postMessage，解决安全风险的同时，安全的通过安检也变成了不可忽视的成本。</p>\n<h1>现实和未来</h1>\n<p>现实中， web 和 native app 两者并非竞争关系，更像是相互协助的好基友。有时两者分别承担不同的用户阶段，比如 web app 负责前期的宣传，比较消耗性能或者必须利用系统资源而不得不采用 native app 的时候，由 web app 引导用户安装 native app。有时 web app 化为 native app 的一部分存在（webview），帮助 native app 完成复杂且变动频繁的界面交互（hybird app）。</p>\n<p>另外一个值得注意的是 web app native 化方案。目前主流的有 react-native，electron（其他概念类似的都不列举了），可以看出行业的发展趋势或者说最大众化的诉求，还是梦想着可以结合 web app 和 native app 的优势。特别是，在人工成本居高不下，而 AI 自动开发还遥不可期的时代，仅仅是「一次编写多平台运行」这个跨平台特性，就使得 web app native 成为一股不可忽视的声音。而只要可以跨平台而开发效率不难看，大部分人还是不怎么在乎是不是用 web 三件套的（html/css/js），比如最近火的一塌糊涂的 flutter。</p>\n"},{"title":"Restful API 设计的三点经验之谈","catalog":true,"date":"2019-01-23T09:29:03.000Z","subtitle":null,"header-img":"lycs-lycs-744230-unsplash.jpg","_content":"2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。\n\n## Status code\n基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。\n\n那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。\n\n* 401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.\n* 403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。\n* 404 - not found，不存在。\n\n总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。\n\n服务端自身错误则包含两类情况：\n* io 错误，比如读写文件，访问数据库\n* 自身逻辑错误，比如内存泄漏。\n\n第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但**最好**有个兜底的错误处理以免程序挂掉。\n\n我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：\n\n```\n400 bad request\n{\n  \"code\": 123,\n  \"message\": \"Name is required\"\n}\n```\n\n## List API\nGET /orders\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [...]\n}\n```\n对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回\n```\n404 NotFound\n```\n难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [] // 空数组\n}\n```\n\n所以对于 List API 来说，没有 404。\n## Parent resource\nrestful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。\n```\n/users/{user_id}/addresses/\n```\n那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？\n\n用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。\n\n所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。 \n","source":"_posts/2019-01-23-three-points-of-restful-api-design.md","raw":"---\ntitle: Restful API 设计的三点经验之谈\ncatalog: true\ndate: 2019-01-23 17:29:03\nsubtitle:\nheader-img: lycs-lycs-744230-unsplash.jpg\ntags: restful-api\n---\n2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。\n\n## Status code\n基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。\n\n那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。\n\n* 401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.\n* 403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。\n* 404 - not found，不存在。\n\n总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。\n\n服务端自身错误则包含两类情况：\n* io 错误，比如读写文件，访问数据库\n* 自身逻辑错误，比如内存泄漏。\n\n第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但**最好**有个兜底的错误处理以免程序挂掉。\n\n我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：\n\n```\n400 bad request\n{\n  \"code\": 123,\n  \"message\": \"Name is required\"\n}\n```\n\n## List API\nGET /orders\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [...]\n}\n```\n对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回\n```\n404 NotFound\n```\n难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：\n```\n200 OK\n{\n \"offset\": 0,\n \"limit\": 20,\n \"count\": 100,\n \"elements\": [] // 空数组\n}\n```\n\n所以对于 List API 来说，没有 404。\n## Parent resource\nrestful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。\n```\n/users/{user_id}/addresses/\n```\n那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？\n\n用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。\n\n所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。 \n","slug":"three-points-of-restful-api-design","published":1,"updated":"2019-01-23T09:38:52.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih98f00090n82prr79foo","content":"<p>2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。</p>\n<h2><span id=\"status-code\">Status code</span></h2>\n<p>基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。</p>\n<p>那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。</p>\n<ul>\n<li>401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.</li>\n<li>403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。</li>\n<li>404 - not found，不存在。</li>\n</ul>\n<p>总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。</p>\n<p>服务端自身错误则包含两类情况：</p>\n<ul>\n<li>io 错误，比如读写文件，访问数据库</li>\n<li>自身逻辑错误，比如内存泄漏。</li>\n</ul>\n<p>第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但<strong>最好</strong>有个兜底的错误处理以免程序挂掉。</p>\n<p>我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">400</span> <span class=\"keyword\">bad </span>request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"code\"</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">  <span class=\"string\">\"message\"</span>: <span class=\"string\">\"Name is required\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"list-api\">List API</span></h2>\n<p>GET /orders</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: <span class=\"string\">[...]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">404 </span>NotFound</span><br></pre></td></tr></table></figure>\n<p>难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: [] <span class=\"comment\">// 空数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于 List API 来说，没有 404。</p>\n<h2><span id=\"parent-resource\">Parent resource</span></h2>\n<p>restful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/users/</span>&#123;user_id&#125;<span class=\"regexp\">/addresses/</span></span><br></pre></td></tr></table></figure>\n<p>那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？</p>\n<p>用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。</p>\n<p>所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。</p>\n<h2>Status code</h2>\n<p>基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。</p>\n<p>那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。</p>\n<ul>\n<li>401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.</li>\n<li>403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。</li>\n<li>404 - not found，不存在。</li>\n</ul>\n<p>总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。</p>\n<p>服务端自身错误则包含两类情况：</p>\n<ul>\n<li>io 错误，比如读写文件，访问数据库</li>\n<li>自身逻辑错误，比如内存泄漏。</li>\n</ul>\n<p>第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但<strong>最好</strong>有个兜底的错误处理以免程序挂掉。</p>\n<p>我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">400</span> <span class=\"keyword\">bad </span>request</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"code\"</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">  <span class=\"string\">\"message\"</span>: <span class=\"string\">\"Name is required\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>List API</h2>\n<p>GET /orders</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: <span class=\"string\">[...]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">404 </span>NotFound</span><br></pre></td></tr></table></figure>\n<p>难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"offset\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">\"limit\"</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\"> <span class=\"string\">\"count\"</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\"> <span class=\"string\">\"elements\"</span>: [] <span class=\"comment\">// 空数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于 List API 来说，没有 404。</p>\n<h2>Parent resource</h2>\n<p>restful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/users/</span>&#123;user_id&#125;<span class=\"regexp\">/addresses/</span></span><br></pre></td></tr></table></figure>\n<p>那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？</p>\n<p>用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。</p>\n<p>所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。</p>\n"},{"title":"不再为折腾环境变量而哭泣","catalog":true,"date":"2019-05-27T08:25:07.000Z","subtitle":"create-react-app 环境变量","header-img":null,"_content":"\ncreate-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：\n* .env ： 默认变量\n* .env.development: 开发环境变量\n* .env.production: 线上环境变量\n\n上面的结构很适合只需要区分开发环境和线上环境的业务场景，也只能适用于这种场景。而实际的情况可能更加复杂，比如，我现在所负责的项目，线上环境就有四个，分别是 dev/qa/stg/prod（称为 stack）。cra 提供的方法完全不够用。事实上，create-react-app 在 github 上的 issue 中就有讨论过相关的 topic，当然，目前还没有定论。否则，我也不会在折腾半天无果后，只能自己造轮子，然后写下这篇造后感。\n\n## idea of spring\n**遇到前端工程问题，不妨看看后端有什么现成的解法**。刚好我用过 spring，它引入一种概念叫做 profile，一个 sprint app 可以包含多个 profile，每个 profile 是一份配置文件。可以在主配置文件中设置当前启用哪个 profile。比如，对于我们的项目，可以配置 dev/qa/stg/prod 四个 profile。实际应用中，spring app 从环境变量中读取当前启用的 profile 的名字。比如，虚拟机中设置一个环境变量 profile=dev，则 dev profile 被启用。\n\n## cra 能做什么\n看完 spring 的 idea，来分析下 create-react-app 的现状。\n1. cra 预置 NODE_ENV 作为环境变量，当运行 start 命令时，值为 development，当运行 build 时，值为 production。但我们要区分 4 个线上环境，所以，无用。\n2. cra 设置了复杂的配置文件优先级策略，详见官网，结论依然是无用。我个人倾向于简洁直白，每个环境需要的变量最好全部写清楚，不需要**继承**或者**组合**。\n\n所以，cra本身的高级机制我们统统不用，只需要知道 cra 会读取 .env 文件，无论是 development 还是 production。\n\n## 模仿 spring\n先准备好四个 profile 文件：\n* .env.dev\n* .env.qa\n* .env.stg\n* .env.prod\n.env.dev 中内容，其他 profile 结构类似：\n```ini\napi_path: http://api.dev.com\n```\n然后，根据环境变量 profile 切换 .env，即动态生成 .env 文件。\n\nenv.js\n```js\n\nconst fs = require('fs')\nconst ini = require('ini')\nconst dotenv = require('dotenv')\nconst path = require('path')\n\nfunction load() {\n  if (process.env.profile) {\n    return dotenv.config({ path: path.join(__dirname, '..', `.env.${process.env.profile}`) })\n  }\n  return dotenv.config()\n}\n\nconst result = load()\n\nif (result.error) {\n  throw result.error\n}\n\nconsole.log(result.parsed)\n\nfs.writeFileSync('./.env', ini.stringify(result.parsed))\n```\n\n修改 package.json 中 start 和 build 命令：\n\n```json\n  \"start\": \"profile=dev node env.js && react-scripts start\",\n  \"build\": \"node env.js && react-scripts build\",\n```\n\n可以看到我为本地开发配置的 profile 是 dev。production 上所用的 profile 以构建系统（jenkins虚拟机）所提供的 profile 为准。\n\n## 可以提升的点。\n未来，如果有时间的话，还可以做一些提升。\n\n相对容易的，在 build 结束后删除 .env 文件。简单的做法是, build 完成后再调用删除命令。\n```json\n\"build\": \"node env.js && react-scripts build && node env.js cleanup\",\n```\n\n复杂一点的，完全弃用 .env 文件，通过子进程来调用 build 脚本，同时设置环境变量。\n\n```js\nrequire('child_process').exec('api_path=xxx react-scripts build')\n```\n\n## 总结和感想\ncra 官方只提供了区分开发和线上的环境变量管理办法，其实一开始就已经表明了他们绝对无法支持多线上环境这个现实，但是我还是愚蠢的尝试了几个小时，试图从多种配置文件的组合中寻找一种可以利用的模式，现在看起来这注定是要失败的。\n\n我现在所“发明”的这种方式，其实就是简单的改变了思路：既然 cra 不支持多 profile，那我利用外部脚本按需生成 env 文件然后提供给 cra 不是一样解决问题吗？当然，到底要利用 lib 本身还是外部服务（脚本，其他lib）来解决问题，要综合考虑时间成本，可靠性。\n","source":"_posts/2019-05-27-configure-env-variables-without-tears.md","raw":"---\ntitle: 不再为折腾环境变量而哭泣\ncatalog: true\ndate: 2019-05-27 16:25:07\nsubtitle: create-react-app 环境变量\nheader-img:\ntags: create-react-app\n---\n\ncreate-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：\n* .env ： 默认变量\n* .env.development: 开发环境变量\n* .env.production: 线上环境变量\n\n上面的结构很适合只需要区分开发环境和线上环境的业务场景，也只能适用于这种场景。而实际的情况可能更加复杂，比如，我现在所负责的项目，线上环境就有四个，分别是 dev/qa/stg/prod（称为 stack）。cra 提供的方法完全不够用。事实上，create-react-app 在 github 上的 issue 中就有讨论过相关的 topic，当然，目前还没有定论。否则，我也不会在折腾半天无果后，只能自己造轮子，然后写下这篇造后感。\n\n## idea of spring\n**遇到前端工程问题，不妨看看后端有什么现成的解法**。刚好我用过 spring，它引入一种概念叫做 profile，一个 sprint app 可以包含多个 profile，每个 profile 是一份配置文件。可以在主配置文件中设置当前启用哪个 profile。比如，对于我们的项目，可以配置 dev/qa/stg/prod 四个 profile。实际应用中，spring app 从环境变量中读取当前启用的 profile 的名字。比如，虚拟机中设置一个环境变量 profile=dev，则 dev profile 被启用。\n\n## cra 能做什么\n看完 spring 的 idea，来分析下 create-react-app 的现状。\n1. cra 预置 NODE_ENV 作为环境变量，当运行 start 命令时，值为 development，当运行 build 时，值为 production。但我们要区分 4 个线上环境，所以，无用。\n2. cra 设置了复杂的配置文件优先级策略，详见官网，结论依然是无用。我个人倾向于简洁直白，每个环境需要的变量最好全部写清楚，不需要**继承**或者**组合**。\n\n所以，cra本身的高级机制我们统统不用，只需要知道 cra 会读取 .env 文件，无论是 development 还是 production。\n\n## 模仿 spring\n先准备好四个 profile 文件：\n* .env.dev\n* .env.qa\n* .env.stg\n* .env.prod\n.env.dev 中内容，其他 profile 结构类似：\n```ini\napi_path: http://api.dev.com\n```\n然后，根据环境变量 profile 切换 .env，即动态生成 .env 文件。\n\nenv.js\n```js\n\nconst fs = require('fs')\nconst ini = require('ini')\nconst dotenv = require('dotenv')\nconst path = require('path')\n\nfunction load() {\n  if (process.env.profile) {\n    return dotenv.config({ path: path.join(__dirname, '..', `.env.${process.env.profile}`) })\n  }\n  return dotenv.config()\n}\n\nconst result = load()\n\nif (result.error) {\n  throw result.error\n}\n\nconsole.log(result.parsed)\n\nfs.writeFileSync('./.env', ini.stringify(result.parsed))\n```\n\n修改 package.json 中 start 和 build 命令：\n\n```json\n  \"start\": \"profile=dev node env.js && react-scripts start\",\n  \"build\": \"node env.js && react-scripts build\",\n```\n\n可以看到我为本地开发配置的 profile 是 dev。production 上所用的 profile 以构建系统（jenkins虚拟机）所提供的 profile 为准。\n\n## 可以提升的点。\n未来，如果有时间的话，还可以做一些提升。\n\n相对容易的，在 build 结束后删除 .env 文件。简单的做法是, build 完成后再调用删除命令。\n```json\n\"build\": \"node env.js && react-scripts build && node env.js cleanup\",\n```\n\n复杂一点的，完全弃用 .env 文件，通过子进程来调用 build 脚本，同时设置环境变量。\n\n```js\nrequire('child_process').exec('api_path=xxx react-scripts build')\n```\n\n## 总结和感想\ncra 官方只提供了区分开发和线上的环境变量管理办法，其实一开始就已经表明了他们绝对无法支持多线上环境这个现实，但是我还是愚蠢的尝试了几个小时，试图从多种配置文件的组合中寻找一种可以利用的模式，现在看起来这注定是要失败的。\n\n我现在所“发明”的这种方式，其实就是简单的改变了思路：既然 cra 不支持多 profile，那我利用外部脚本按需生成 env 文件然后提供给 cra 不是一样解决问题吗？当然，到底要利用 lib 本身还是外部服务（脚本，其他lib）来解决问题，要综合考虑时间成本，可靠性。\n","slug":"configure-env-variables-without-tears","published":1,"updated":"2019-05-27T09:51:34.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih98l000c0n826blcklr7","content":"<p>create-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：</p>\n<ul>\n<li>.env ： 默认变量</li>\n<li>.env.development: 开发环境变量</li>\n<li>.env.production: 线上环境变量</li>\n</ul>\n<p>上面的结构很适合只需要区分开发环境和线上环境的业务场景，也只能适用于这种场景。而实际的情况可能更加复杂，比如，我现在所负责的项目，线上环境就有四个，分别是 dev/qa/stg/prod（称为 stack）。cra 提供的方法完全不够用。事实上，create-react-app 在 github 上的 issue 中就有讨论过相关的 topic，当然，目前还没有定论。否则，我也不会在折腾半天无果后，只能自己造轮子，然后写下这篇造后感。</p>\n<h2><span id=\"idea-of-spring\">idea of spring</span></h2>\n<p><strong>遇到前端工程问题，不妨看看后端有什么现成的解法</strong>。刚好我用过 spring，它引入一种概念叫做 profile，一个 sprint app 可以包含多个 profile，每个 profile 是一份配置文件。可以在主配置文件中设置当前启用哪个 profile。比如，对于我们的项目，可以配置 dev/qa/stg/prod 四个 profile。实际应用中，spring app 从环境变量中读取当前启用的 profile 的名字。比如，虚拟机中设置一个环境变量 profile=dev，则 dev profile 被启用。</p>\n<h2><span id=\"cra-能做什么\">cra 能做什么</span></h2>\n<p>看完 spring 的 idea，来分析下 create-react-app 的现状。</p>\n<ol>\n<li>cra 预置 NODE_ENV 作为环境变量，当运行 start 命令时，值为 development，当运行 build 时，值为 production。但我们要区分 4 个线上环境，所以，无用。</li>\n<li>cra 设置了复杂的配置文件优先级策略，详见官网，结论依然是无用。我个人倾向于简洁直白，每个环境需要的变量最好全部写清楚，不需要<strong>继承</strong>或者<strong>组合</strong>。</li>\n</ol>\n<p>所以，cra本身的高级机制我们统统不用，只需要知道 cra 会读取 .env 文件，无论是 development 还是 production。</p>\n<h2><span id=\"模仿-spring\">模仿 spring</span></h2>\n<p>先准备好四个 profile 文件：</p>\n<ul>\n<li>.env.dev</li>\n<li>.env.qa</li>\n<li>.env.stg</li>\n<li>.env.prod<br>\n.env.dev 中内容，其他 profile 结构类似：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_path: http://api.dev.com</span><br></pre></td></tr></table></figure>\n<p>然后，根据环境变量 profile 切换 .env，即动态生成 .env 文件。</p>\n<p>env.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> ini = <span class=\"built_in\">require</span>(<span class=\"string\">'ini'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dotenv = <span class=\"built_in\">require</span>(<span class=\"string\">'dotenv'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.profile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dotenv.config(&#123; <span class=\"attr\">path</span>: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">`.env.<span class=\"subst\">$&#123;process.env.profile&#125;</span>`</span>) &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dotenv.config()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = load()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (result.error) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> result.error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.parsed)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./.env'</span>, ini.stringify(result.parsed))</span><br></pre></td></tr></table></figure>\n<p>修改 package.json 中 start 和 build 命令：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"start\": \"profile=dev node env.js &amp;&amp; react-scripts start\",</span><br><span class=\"line\">\"build\": \"node env.js &amp;&amp; react-scripts build\",</span><br></pre></td></tr></table></figure>\n<p>可以看到我为本地开发配置的 profile 是 dev。production 上所用的 profile 以构建系统（jenkins虚拟机）所提供的 profile 为准。</p>\n<h2><span id=\"可以提升的点\">可以提升的点。</span></h2>\n<p>未来，如果有时间的话，还可以做一些提升。</p>\n<p>相对容易的，在 build 结束后删除 .env 文件。简单的做法是, build 完成后再调用删除命令。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"build\": \"node env.js &amp;&amp; react-scripts build &amp;&amp; node env.js cleanup\",</span><br></pre></td></tr></table></figure>\n<p>复杂一点的，完全弃用 .env 文件，通过子进程来调用 build 脚本，同时设置环境变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).exec(<span class=\"string\">'api_path=xxx react-scripts build'</span>)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"总结和感想\">总结和感想</span></h2>\n<p>cra 官方只提供了区分开发和线上的环境变量管理办法，其实一开始就已经表明了他们绝对无法支持多线上环境这个现实，但是我还是愚蠢的尝试了几个小时，试图从多种配置文件的组合中寻找一种可以利用的模式，现在看起来这注定是要失败的。</p>\n<p>我现在所“发明”的这种方式，其实就是简单的改变了思路：既然 cra 不支持多 profile，那我利用外部脚本按需生成 env 文件然后提供给 cra 不是一样解决问题吗？当然，到底要利用 lib 本身还是外部服务（脚本，其他lib）来解决问题，要综合考虑时间成本，可靠性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>create-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：</p>\n<ul>\n<li>.env ： 默认变量</li>\n<li>.env.development: 开发环境变量</li>\n<li>.env.production: 线上环境变量</li>\n</ul>\n<p>上面的结构很适合只需要区分开发环境和线上环境的业务场景，也只能适用于这种场景。而实际的情况可能更加复杂，比如，我现在所负责的项目，线上环境就有四个，分别是 dev/qa/stg/prod（称为 stack）。cra 提供的方法完全不够用。事实上，create-react-app 在 github 上的 issue 中就有讨论过相关的 topic，当然，目前还没有定论。否则，我也不会在折腾半天无果后，只能自己造轮子，然后写下这篇造后感。</p>\n<h2>idea of spring</h2>\n<p><strong>遇到前端工程问题，不妨看看后端有什么现成的解法</strong>。刚好我用过 spring，它引入一种概念叫做 profile，一个 sprint app 可以包含多个 profile，每个 profile 是一份配置文件。可以在主配置文件中设置当前启用哪个 profile。比如，对于我们的项目，可以配置 dev/qa/stg/prod 四个 profile。实际应用中，spring app 从环境变量中读取当前启用的 profile 的名字。比如，虚拟机中设置一个环境变量 profile=dev，则 dev profile 被启用。</p>\n<h2>cra 能做什么</h2>\n<p>看完 spring 的 idea，来分析下 create-react-app 的现状。</p>\n<ol>\n<li>cra 预置 NODE_ENV 作为环境变量，当运行 start 命令时，值为 development，当运行 build 时，值为 production。但我们要区分 4 个线上环境，所以，无用。</li>\n<li>cra 设置了复杂的配置文件优先级策略，详见官网，结论依然是无用。我个人倾向于简洁直白，每个环境需要的变量最好全部写清楚，不需要<strong>继承</strong>或者<strong>组合</strong>。</li>\n</ol>\n<p>所以，cra本身的高级机制我们统统不用，只需要知道 cra 会读取 .env 文件，无论是 development 还是 production。</p>\n<h2>模仿 spring</h2>\n<p>先准备好四个 profile 文件：</p>\n<ul>\n<li>.env.dev</li>\n<li>.env.qa</li>\n<li>.env.stg</li>\n<li>.env.prod<br>\n.env.dev 中内容，其他 profile 结构类似：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_path: http://api.dev.com</span><br></pre></td></tr></table></figure>\n<p>然后，根据环境变量 profile 切换 .env，即动态生成 .env 文件。</p>\n<p>env.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> ini = <span class=\"built_in\">require</span>(<span class=\"string\">'ini'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dotenv = <span class=\"built_in\">require</span>(<span class=\"string\">'dotenv'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.profile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dotenv.config(&#123; <span class=\"attr\">path</span>: path.join(__dirname, <span class=\"string\">'..'</span>, <span class=\"string\">`.env.<span class=\"subst\">$&#123;process.env.profile&#125;</span>`</span>) &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dotenv.config()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = load()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (result.error) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> result.error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.parsed)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./.env'</span>, ini.stringify(result.parsed))</span><br></pre></td></tr></table></figure>\n<p>修改 package.json 中 start 和 build 命令：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"start\": \"profile=dev node env.js &amp;&amp; react-scripts start\",</span><br><span class=\"line\">\"build\": \"node env.js &amp;&amp; react-scripts build\",</span><br></pre></td></tr></table></figure>\n<p>可以看到我为本地开发配置的 profile 是 dev。production 上所用的 profile 以构建系统（jenkins虚拟机）所提供的 profile 为准。</p>\n<h2>可以提升的点。</h2>\n<p>未来，如果有时间的话，还可以做一些提升。</p>\n<p>相对容易的，在 build 结束后删除 .env 文件。简单的做法是, build 完成后再调用删除命令。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"build\": \"node env.js &amp;&amp; react-scripts build &amp;&amp; node env.js cleanup\",</span><br></pre></td></tr></table></figure>\n<p>复杂一点的，完全弃用 .env 文件，通过子进程来调用 build 脚本，同时设置环境变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).exec(<span class=\"string\">'api_path=xxx react-scripts build'</span>)</span><br></pre></td></tr></table></figure>\n<h2>总结和感想</h2>\n<p>cra 官方只提供了区分开发和线上的环境变量管理办法，其实一开始就已经表明了他们绝对无法支持多线上环境这个现实，但是我还是愚蠢的尝试了几个小时，试图从多种配置文件的组合中寻找一种可以利用的模式，现在看起来这注定是要失败的。</p>\n<p>我现在所“发明”的这种方式，其实就是简单的改变了思路：既然 cra 不支持多 profile，那我利用外部脚本按需生成 env 文件然后提供给 cra 不是一样解决问题吗？当然，到底要利用 lib 本身还是外部服务（脚本，其他lib）来解决问题，要综合考虑时间成本，可靠性。</p>\n"},{"title":"文件上传二三事","catalog":true,"date":"2015-11-20T10:05:52.000Z","subtitle":null,"header-img":"home-bg-2-dark.png","summary":null,"_content":"# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","source":"_posts/about-file-upload-1.md","raw":"---\ntitle: 文件上传二三事\ncatalog: true\ndate: 2015-11-20 18:05:52\nsubtitle:\nheader-img: home-bg-2-dark.png\ntags: [文件上传,http]\nsummary: \n---\n# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","slug":"about-file-upload-1","published":1,"updated":"2019-08-22T10:08:56.103Z","_id":"cjzmih98o000e0n82i92kw456","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"引子\">引子</span></h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1><span id=\"选择文件\">选择文件</span></h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1><span id=\"如何上传\">如何上传</span></h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1><span id=\"增强实现\">增强实现</span></h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2><span id=\"美化选择按钮\">美化选择按钮</span></h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2><span id=\"不想刷新页面\">不想刷新页面</span></h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> <span class=\"params\">(result)</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">...</span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">window.uploadSuccess('xxxxxx');</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">...</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2><span id=\"formdataajax文件上传\">FormData，ajax文件上传</span></h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1><span id=\"文件验证\">文件验证</span></h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2><span id=\"前端\">前端</span></h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2><span id=\"后端\">后端</span></h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1><span id=\"为什么叫二三事\">为什么叫二三事</span></h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1><span id=\"后记\">后记</span></h1>\n<h2><span id=\"补充\">补充</span></h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>引子</h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1>选择文件</h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1>如何上传</h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1>增强实现</h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2>美化选择按钮</h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2>不想刷新页面</h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> <span class=\"params\">(result)</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">...</span></span><br><span class=\"line\"><span class=\"xml\"></span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">window.uploadSuccess('xxxxxx');</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">...</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2>FormData，ajax文件上传</h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1>文件验证</h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2>前端</h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2>后端</h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1>为什么叫二三事</h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1>后记</h1>\n<h2>补充</h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n"},{"title":"ejs 入门","catalog":true,"date":"2018-02-02T05:21:32.000Z","subtitle":"熟练掌握一种模板引擎可以极大的提高页面开发效率","header-img":null,"_content":"## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","source":"_posts/get-started-ejs.md","raw":"---\ntitle: ejs 入门\ncatalog: true\ndate: 2018-02-02 13:21:32\nsubtitle: 熟练掌握一种模板引擎可以极大的提高页面开发效率\nheader-img: \ntags: [ejs,模板引擎,前端工程]\n---\n## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","slug":"get-started-ejs","published":1,"updated":"2019-01-04T05:42:25.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih98p000g0n8271cmpmed","content":"<h2><span id=\"为什么要学习模板引擎\">为什么要学习模板引擎</span></h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2><span id=\"安装\">安装</span></h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2><span id=\"基本语法要素\">基本语法要素</span></h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"标签\">标签</span></h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2><span id=\"包含-includes\">包含 Includes</span></h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2><span id=\"定制分隔符\">定制分隔符</span></h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"参考文档\">参考文档</span></h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>为什么要学习模板引擎</h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2>安装</h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2>基本语法要素</h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>标签</h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2>包含 Includes</h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2>定制分隔符</h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2>参考文档</h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n"},{"title":"Golang 与 MongoDB：入门篇","catalog":true,"date":"2018-02-02T07:47:08.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/get-started-of-golang-with-mongodb.md","raw":"---\ntitle: Golang 与 MongoDB：入门篇\ncatalog: true\ndate: 2018-02-02 15:47:08\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"get-started-of-golang-with-mongodb","published":1,"updated":"2019-01-04T05:42:25.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih98r000j0n82wkunnsfi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Golang：package 和 访问权限，以及其他基本知识总结","catalog":true,"date":"2018-02-05T07:46:05.000Z","subtitle":null,"header-img":null,"_content":"## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","source":"_posts/golang-package-etc.md","raw":"---\ntitle: Golang：package 和 访问权限，以及其他基本知识总结\ncatalog: true\ndate: 2018-02-05 15:46:05\nsubtitle: \nheader-img:\ntags:\n---\n## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","slug":"golang-package-etc","published":1,"updated":"2019-01-04T05:42:25.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih98s000k0n82wqyexl57","content":"<h2><span id=\"引子\">引子</span></h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2><span id=\"项目结构\">项目结构</span></h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2><span id=\"访问权限\">访问权限</span></h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"安装-lib\">安装 lib</span></h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2><span id=\"管理依赖\">管理依赖</span></h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2><span id=\"常用的-libweb-service-开发小知识\">常用的 lib（web service 开发），小知识</span></h2>\n<h3><span id=\"web-框架路由\">web 框架，路由</span></h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3><span id=\"yaml-文件解析\">yaml 文件解析</span></h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>引子</h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2>项目结构</h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2>访问权限</h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2>安装 lib</h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2>管理依赖</h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2>常用的 lib（web service 开发），小知识</h2>\n<h3>web 框架，路由</h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3>yaml 文件解析</h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n"},{"title":"译-构建微服务面临的挑战","catalog":true,"date":"2018-06-12T02:30:51.000Z","subtitle":null,"header-img":null,"summary":"没有什么技术是万能解药。理论上讲，任何技术都是有阴暗面的（dark side）。","_content":"原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","source":"_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","raw":"---\ntitle: 译-构建微服务面临的挑战\ncatalog: true\ndate: 2018-06-12 10:30:51\nsubtitle: \nheader-img:\ntags: micro service\nsummary: 没有什么技术是万能解药。理论上讲，任何技术都是有阴暗面的（dark side）。\n---\n原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","slug":"translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices","published":1,"updated":"2019-08-22T10:07:07.933Z","_id":"cjzmih98t000m0n82600ed82t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2><span id=\"六个问题\">六个问题</span></h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3><span id=\"组织架构\">组织架构</span></h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3><span id=\"更容易出错\">更容易出错</span></h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3><span id=\"资源竞争\">资源竞争</span></h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3><span id=\"对微服务的误解\">对微服务的误解</span></h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3><span id=\"技术债务\">技术债务</span></h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3><span id=\"缺乏信任\">缺乏信任</span></h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2><span id=\"解决办法\">解决办法</span></h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3><span id=\"需要标准化\">需要标准化</span></h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3><span id=\"production-ready-的微服务架构\">production ready 的微服务架构</span></h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3><span id=\"稳定性和可靠性\">稳定性和可靠性</span></h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3><span id=\"可扩展性和性能\">可扩展性和性能</span></h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3><span id=\"容错和灾难防护\">容错和灾难防护</span></h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3><span id=\"监控\">监控</span></h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3><span id=\"文档\">文档</span></h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2><span id=\"更多内容\">更多内容</span></h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2>六个问题</h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3>组织架构</h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3>更容易出错</h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3>资源竞争</h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3>对微服务的误解</h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3>技术债务</h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3>缺乏信任</h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2>解决办法</h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3>需要标准化</h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3>production ready 的微服务架构</h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3>稳定性和可靠性</h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3>可扩展性和性能</h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3>容错和灾难防护</h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3>监控</h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3>文档</h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2>更多内容</h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n"},{"title":"Wang Pin's 2018 总结 - thinking more，doing the best","catalog":true,"date":"2018-12-29T09:00:53.000Z","subtitle":"跳出程序员思维，读书，实践，思考","header-img":"stockvault-abstract-person-with-cogwheels209083.jpg","_content":"# 跳出程序员的思维\n## 做“出格”的事\n很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。\n**所以，我现在偏好做“出格”的事情**。\n>要掌握一件东西，必须先了解它。\n\n要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。\n然后，**必须去沟通**。\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。\n最后，**还得学会关键对话**。\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。\n\n当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。\n\n## 看书\n做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。\n* 《品牌的起源》\n* 《淘宝十年产品事》\n* 《产品经理入门攻略》\n* 《腾讯产品法》\n* 《产品经理方法论》\n* 《产品的视角：从热闹到门道》\n* 《人人都是产品经理》\n* 《破茧成蝶-用户体验设计师的成长之路》\n* 《关键对话》\n\n作为业余放松，我也看小说。目前已读完的：\n* 《三体》\n* 《大明1566》\n* 《天龙八部》\n* 《射雕英雄传》\n* 《神雕侠侣》\n* 《倚天屠龙记》\n* 《碧血剑》\n* 《鹿鼎记》\n* 《连城诀》\n* 《七种武器》\n\n在读和计划的：\n* 《冰与火之歌》\n* 《哈利波特》\n* 《书剑恩仇录》\n* 《雪山飞狐》\n* 《李自成》\n\n## 关于工程师和QA的思考\n当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。\n\n在这样的管理方式下，整个项目组的人员演变，将变成：\n* 工程师任务太重，所以减少编写单元测试的时间\n* 招聘QA来编写测试代码\n* 工程师发现单元测试可有可无，于是不再写单元测试\n* 招聘更多QA\n\n以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。\n\n很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。\n\n# 技术和创意\n## server render 和 pwa\nspa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的**必须**资源，一次返回给客户端，以加速首屏渲染效率。\n\npwa（progress web application）通过 server-worker 和 cache，将静态文件**存储**在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。\n\n结合 spa 和 pwa，app 的**启动速度**将得到质的飞跃。\n\n## web component\nweb component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如**微前端**：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。\n\n## material design\n我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。\n\n## 创意\n> 没实现的创意，那只是脑洞\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。\n\n世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：\n\n1. hexo 主题 - remind\n[remind](https://baike.baidu.com/item/remind/10466250?fr=aladdin#5) 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。\n2. boli - local 资源文件编辑器\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。\n3. 更简单的私人博客\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：\n1. 想玩，比如我\n2.想要自己的独立地址\n\n对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？\n\n（全文结束）\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018-12-29-summary-of-2018.md","raw":"---\ntitle: Wang Pin's 2018 总结 - thinking more，doing the best\ncatalog: true\ndate: 2018-12-29 17:00:53\nsubtitle: 跳出程序员思维，读书，实践，思考\nheader-img: stockvault-abstract-person-with-cogwheels209083.jpg\ntags: [思考,总结,沟通能力,职业发展]\n---\n# 跳出程序员的思维\n## 做“出格”的事\n很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。\n**所以，我现在偏好做“出格”的事情**。\n>要掌握一件东西，必须先了解它。\n\n要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。\n然后，**必须去沟通**。\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。\n最后，**还得学会关键对话**。\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。\n\n当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。\n\n## 看书\n做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。\n* 《品牌的起源》\n* 《淘宝十年产品事》\n* 《产品经理入门攻略》\n* 《腾讯产品法》\n* 《产品经理方法论》\n* 《产品的视角：从热闹到门道》\n* 《人人都是产品经理》\n* 《破茧成蝶-用户体验设计师的成长之路》\n* 《关键对话》\n\n作为业余放松，我也看小说。目前已读完的：\n* 《三体》\n* 《大明1566》\n* 《天龙八部》\n* 《射雕英雄传》\n* 《神雕侠侣》\n* 《倚天屠龙记》\n* 《碧血剑》\n* 《鹿鼎记》\n* 《连城诀》\n* 《七种武器》\n\n在读和计划的：\n* 《冰与火之歌》\n* 《哈利波特》\n* 《书剑恩仇录》\n* 《雪山飞狐》\n* 《李自成》\n\n## 关于工程师和QA的思考\n当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。\n\n在这样的管理方式下，整个项目组的人员演变，将变成：\n* 工程师任务太重，所以减少编写单元测试的时间\n* 招聘QA来编写测试代码\n* 工程师发现单元测试可有可无，于是不再写单元测试\n* 招聘更多QA\n\n以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。\n\n很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。\n\n# 技术和创意\n## server render 和 pwa\nspa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的**必须**资源，一次返回给客户端，以加速首屏渲染效率。\n\npwa（progress web application）通过 server-worker 和 cache，将静态文件**存储**在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。\n\n结合 spa 和 pwa，app 的**启动速度**将得到质的飞跃。\n\n## web component\nweb component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如**微前端**：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。\n\n## material design\n我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。\n\n## 创意\n> 没实现的创意，那只是脑洞\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。\n\n世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：\n\n1. hexo 主题 - remind\n[remind](https://baike.baidu.com/item/remind/10466250?fr=aladdin#5) 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。\n2. boli - local 资源文件编辑器\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。\n3. 更简单的私人博客\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：\n1. 想玩，比如我\n2.想要自己的独立地址\n\n对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？\n\n（全文结束）\n\n\n\n\n\n\n\n\n\n\n","slug":"summary-of-2018","published":1,"updated":"2019-01-04T05:42:25.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzmih997001h0n82kvvf8flq","content":"<h1><span id=\"跳出程序员的思维\">跳出程序员的思维</span></h1>\n<h2><span id=\"做出格的事\">做“出格”的事</span></h2>\n<p>很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。<br>\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。<br>\n<strong>所以，我现在偏好做“出格”的事情</strong>。</p>\n<blockquote>\n<p>要掌握一件东西，必须先了解它。</p>\n</blockquote>\n<p>要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。<br>\n然后，<strong>必须去沟通</strong>。<br>\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。<br>\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。<br>\n最后，<strong>还得学会关键对话</strong>。<br>\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。</p>\n<p>当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。</p>\n<h2><span id=\"看书\">看书</span></h2>\n<p>做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。</p>\n<ul>\n<li>《品牌的起源》</li>\n<li>《淘宝十年产品事》</li>\n<li>《产品经理入门攻略》</li>\n<li>《腾讯产品法》</li>\n<li>《产品经理方法论》</li>\n<li>《产品的视角：从热闹到门道》</li>\n<li>《人人都是产品经理》</li>\n<li>《破茧成蝶-用户体验设计师的成长之路》</li>\n<li>《关键对话》</li>\n</ul>\n<p>作为业余放松，我也看小说。目前已读完的：</p>\n<ul>\n<li>《三体》</li>\n<li>《大明1566》</li>\n<li>《天龙八部》</li>\n<li>《射雕英雄传》</li>\n<li>《神雕侠侣》</li>\n<li>《倚天屠龙记》</li>\n<li>《碧血剑》</li>\n<li>《鹿鼎记》</li>\n<li>《连城诀》</li>\n<li>《七种武器》</li>\n</ul>\n<p>在读和计划的：</p>\n<ul>\n<li>《冰与火之歌》</li>\n<li>《哈利波特》</li>\n<li>《书剑恩仇录》</li>\n<li>《雪山飞狐》</li>\n<li>《李自成》</li>\n</ul>\n<h2><span id=\"关于工程师和qa的思考\">关于工程师和QA的思考</span></h2>\n<p>当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。</p>\n<p>在这样的管理方式下，整个项目组的人员演变，将变成：</p>\n<ul>\n<li>工程师任务太重，所以减少编写单元测试的时间</li>\n<li>招聘QA来编写测试代码</li>\n<li>工程师发现单元测试可有可无，于是不再写单元测试</li>\n<li>招聘更多QA</li>\n</ul>\n<p>以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。</p>\n<p>很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。</p>\n<h1><span id=\"技术和创意\">技术和创意</span></h1>\n<h2><span id=\"server-render-和-pwa\">server render 和 pwa</span></h2>\n<p>spa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。<br>\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的<strong>必须</strong>资源，一次返回给客户端，以加速首屏渲染效率。</p>\n<p>pwa（progress web application）通过 server-worker 和 cache，将静态文件<strong>存储</strong>在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。</p>\n<p>结合 spa 和 pwa，app 的<strong>启动速度</strong>将得到质的飞跃。</p>\n<h2><span id=\"web-component\">web component</span></h2>\n<p>web component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如<strong>微前端</strong>：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。</p>\n<h2><span id=\"material-design\">material design</span></h2>\n<p>我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。</p>\n<h2><span id=\"创意\">创意</span></h2>\n<blockquote>\n<p>没实现的创意，那只是脑洞<br>\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。</p>\n</blockquote>\n<p>世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：</p>\n<ol>\n<li>hexo 主题 - remind<br>\n<a href=\"https://baike.baidu.com/item/remind/10466250?fr=aladdin#5\" target=\"_blank\" rel=\"noopener\">remind</a> 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。</li>\n<li>boli - local 资源文件编辑器<br>\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。<br>\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。</li>\n<li>更简单的私人博客<br>\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：</li>\n<li>想玩，比如我<br>\n2.想要自己的独立地址</li>\n</ol>\n<p>对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？</p>\n<p>（全文结束）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>跳出程序员的思维</h1>\n<h2>做“出格”的事</h2>\n<p>很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。<br>\n但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。<br>\n<strong>所以，我现在偏好做“出格”的事情</strong>。</p>\n<blockquote>\n<p>要掌握一件东西，必须先了解它。</p>\n</blockquote>\n<p>要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。<br>\n然后，<strong>必须去沟通</strong>。<br>\n得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。<br>\n得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。<br>\n最后，<strong>还得学会关键对话</strong>。<br>\n当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。</p>\n<p>当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。</p>\n<h2>看书</h2>\n<p>做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。</p>\n<ul>\n<li>《品牌的起源》</li>\n<li>《淘宝十年产品事》</li>\n<li>《产品经理入门攻略》</li>\n<li>《腾讯产品法》</li>\n<li>《产品经理方法论》</li>\n<li>《产品的视角：从热闹到门道》</li>\n<li>《人人都是产品经理》</li>\n<li>《破茧成蝶-用户体验设计师的成长之路》</li>\n<li>《关键对话》</li>\n</ul>\n<p>作为业余放松，我也看小说。目前已读完的：</p>\n<ul>\n<li>《三体》</li>\n<li>《大明1566》</li>\n<li>《天龙八部》</li>\n<li>《射雕英雄传》</li>\n<li>《神雕侠侣》</li>\n<li>《倚天屠龙记》</li>\n<li>《碧血剑》</li>\n<li>《鹿鼎记》</li>\n<li>《连城诀》</li>\n<li>《七种武器》</li>\n</ul>\n<p>在读和计划的：</p>\n<ul>\n<li>《冰与火之歌》</li>\n<li>《哈利波特》</li>\n<li>《书剑恩仇录》</li>\n<li>《雪山飞狐》</li>\n<li>《李自成》</li>\n</ul>\n<h2>关于工程师和QA的思考</h2>\n<p>当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。</p>\n<p>在这样的管理方式下，整个项目组的人员演变，将变成：</p>\n<ul>\n<li>工程师任务太重，所以减少编写单元测试的时间</li>\n<li>招聘QA来编写测试代码</li>\n<li>工程师发现单元测试可有可无，于是不再写单元测试</li>\n<li>招聘更多QA</li>\n</ul>\n<p>以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。</p>\n<p>很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。</p>\n<h1>技术和创意</h1>\n<h2>server render 和 pwa</h2>\n<p>spa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。<br>\nserver render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的<strong>必须</strong>资源，一次返回给客户端，以加速首屏渲染效率。</p>\n<p>pwa（progress web application）通过 server-worker 和 cache，将静态文件<strong>存储</strong>在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。</p>\n<p>结合 spa 和 pwa，app 的<strong>启动速度</strong>将得到质的飞跃。</p>\n<h2>web component</h2>\n<p>web component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如<strong>微前端</strong>：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。</p>\n<h2>material design</h2>\n<p>我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。</p>\n<h2>创意</h2>\n<blockquote>\n<p>没实现的创意，那只是脑洞<br>\n饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。</p>\n</blockquote>\n<p>世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：</p>\n<ol>\n<li>hexo 主题 - remind<br>\n<a href=\"https://baike.baidu.com/item/remind/10466250?fr=aladdin#5\" target=\"_blank\" rel=\"noopener\">remind</a> 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。</li>\n<li>boli - local 资源文件编辑器<br>\n从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。<br>\n但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。</li>\n<li>更简单的私人博客<br>\n很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：</li>\n<li>想玩，比如我<br>\n2.想要自己的独立地址</li>\n</ol>\n<p>对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？</p>\n<p>（全文结束）</p>\n"}],"PostAsset":[{"_id":"source/_posts/2019-01-23-three-points-of-restful-api-design/lycs-lycs-744230-unsplash.jpg","slug":"lycs-lycs-744230-unsplash.jpg","post":"cjzmih98f00090n82prr79foo","modified":0,"renderable":0},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","slug":"home-bg-2-dark.png","post":"cjzmih98o000e0n82i92kw456","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/chrome-extension-tinyurl.jpg","slug":"chrome-extension-tinyurl.jpg","post":"cjzmih97q00070n820i91cq4y","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-11-start-to-use-tinyurl/iPad-Mini-iPhone.jpg","slug":"iPad-Mini-iPhone.jpg","post":"cjzmih97q00070n820i91cq4y","modified":0,"renderable":0},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","slug":"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","post":"cjzmih98t000m0n82600ed82t","modified":0,"renderable":0},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","slug":"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","post":"cjzmih98t000m0n82600ed82t","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/cache-api-browser-compatibility.PNG","slug":"cache-api-browser-compatibility.PNG","post":"cjzmih97w00080n825te6mvfp","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/header.jpg","slug":"header.jpg","post":"cjzmih97w00080n825te6mvfp","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-08-what-web-cannot-do/samsung-galaxy-mini-s5570.jpg","slug":"samsung-galaxy-mini-s5570.jpg","post":"cjzmih97w00080n825te6mvfp","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-29-summary-of-2018/stockvault-abstract-person-with-cogwheels209083.jpg","slug":"stockvault-abstract-person-with-cogwheels209083.jpg","post":"cjzmih997001h0n82kvvf8flq","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjzmih97e00020n82injxq07e","tag_id":"cjzmih97o00050n82rjsf0229","_id":"cjzmih98p000f0n82uwtvcz3b"},{"post_id":"cjzmih97e00020n82injxq07e","tag_id":"cjzmih98g000a0n827456o9yj","_id":"cjzmih98q000h0n82y9bu2z45"},{"post_id":"cjzmih97l00040n820rwwe460","tag_id":"cjzmih97o00050n82rjsf0229","_id":"cjzmih98u000n0n82bs945u79"},{"post_id":"cjzmih97l00040n820rwwe460","tag_id":"cjzmih98g000a0n827456o9yj","_id":"cjzmih98u000o0n82jsgu487r"},{"post_id":"cjzmih97q00070n820i91cq4y","tag_id":"cjzmih98t000l0n824ii74rb9","_id":"cjzmih98w000r0n82mu1jvsqr"},{"post_id":"cjzmih97q00070n820i91cq4y","tag_id":"cjzmih98v000p0n82mvpvzfg6","_id":"cjzmih98w000s0n826xknzvk7"},{"post_id":"cjzmih97w00080n825te6mvfp","tag_id":"cjzmih98v000q0n82526fq2yn","_id":"cjzmih98x000x0n82y5daglul"},{"post_id":"cjzmih97w00080n825te6mvfp","tag_id":"cjzmih98w000t0n82a6tm5mp7","_id":"cjzmih98x000y0n82do0qj9bs"},{"post_id":"cjzmih97w00080n825te6mvfp","tag_id":"cjzmih98w000u0n82vqp6jfs0","_id":"cjzmih98x00100n82anwftiwm"},{"post_id":"cjzmih97w00080n825te6mvfp","tag_id":"cjzmih98x000v0n828f6mq7va","_id":"cjzmih98y00110n82uqecc04i"},{"post_id":"cjzmih98f00090n82prr79foo","tag_id":"cjzmih98x000w0n82fjbwf0av","_id":"cjzmih98y00130n82k1fu7g0w"},{"post_id":"cjzmih98l000c0n826blcklr7","tag_id":"cjzmih98y00120n828ss499eq","_id":"cjzmih98y00160n82svijg11k"},{"post_id":"cjzmih98o000e0n82i92kw456","tag_id":"cjzmih98y00150n82rajngvk4","_id":"cjzmih98z00190n82f1obczbv"},{"post_id":"cjzmih98o000e0n82i92kw456","tag_id":"cjzmih98z00170n829d1v3vpz","_id":"cjzmih98z001a0n82l8nar8p9"},{"post_id":"cjzmih98p000g0n8271cmpmed","tag_id":"cjzmih98z00180n82ejakpcke","_id":"cjzmih990001d0n823bz0jjmm"},{"post_id":"cjzmih98p000g0n8271cmpmed","tag_id":"cjzmih98z001b0n82gpgb092k","_id":"cjzmih990001e0n82q384u27k"},{"post_id":"cjzmih98p000g0n8271cmpmed","tag_id":"cjzmih98g000a0n827456o9yj","_id":"cjzmih991001f0n82k2ffefbh"},{"post_id":"cjzmih98t000m0n82600ed82t","tag_id":"cjzmih990001c0n82zz7e089d","_id":"cjzmih991001g0n820xlkaqid"},{"post_id":"cjzmih997001h0n82kvvf8flq","tag_id":"cjzmih999001i0n82cbjimghc","_id":"cjzmih99d001m0n820m63rp86"},{"post_id":"cjzmih997001h0n82kvvf8flq","tag_id":"cjzmih99c001j0n820ub5jb4z","_id":"cjzmih99d001n0n8216rsccyr"},{"post_id":"cjzmih997001h0n82kvvf8flq","tag_id":"cjzmih99c001k0n826ledbv5u","_id":"cjzmih99d001o0n82wi99z34y"},{"post_id":"cjzmih997001h0n82kvvf8flq","tag_id":"cjzmih99d001l0n828zezc27v","_id":"cjzmih99d001p0n82wqb6wxa3"}],"Tag":[{"name":"gulp","_id":"cjzmih97o00050n82rjsf0229"},{"name":"前端工程","_id":"cjzmih98g000a0n827456o9yj"},{"name":"tiny-url","_id":"cjzmih98t000l0n824ii74rb9"},{"name":"url-shortener","_id":"cjzmih98v000p0n82mvpvzfg6"},{"name":"web app","_id":"cjzmih98v000q0n82526fq2yn"},{"name":"pwa","_id":"cjzmih98w000t0n82a6tm5mp7"},{"name":"小程序","_id":"cjzmih98w000u0n82vqp6jfs0"},{"name":"hybrid app","_id":"cjzmih98x000v0n828f6mq7va"},{"name":"restful-api","_id":"cjzmih98x000w0n82fjbwf0av"},{"name":"工欲善其事","_id":"cjzmih98x000z0n82y0uxxz4c"},{"name":"create-react-app","_id":"cjzmih98y00120n828ss499eq"},{"name":"文件上传","_id":"cjzmih98y00150n82rajngvk4"},{"name":"http","_id":"cjzmih98z00170n829d1v3vpz"},{"name":"ejs","_id":"cjzmih98z00180n82ejakpcke"},{"name":"模板引擎","_id":"cjzmih98z001b0n82gpgb092k"},{"name":"micro service","_id":"cjzmih990001c0n82zz7e089d"},{"name":"思考","_id":"cjzmih999001i0n82cbjimghc"},{"name":"总结","_id":"cjzmih99c001j0n820ub5jb4z"},{"name":"沟通能力","_id":"cjzmih99c001k0n826ledbv5u"},{"name":"职业发展","_id":"cjzmih99d001l0n828zezc27v"}]}}