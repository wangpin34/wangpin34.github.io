{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/ben.styl","path":"css/ben.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/post.styl","path":"css/post.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/css-dist/beantech.min.css","path":"css/css-dist/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/me.jpg","path":"css/images/me.jpg","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/uparrow.png","path":"css/images/uparrow.png","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","path":"img/header_img/reed-xia-790819-unsplash.jpg","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/forrest.jpeg","path":"img/header_img/forrest.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1545208846592},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1545208846593},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1545208846301},{"_id":"source/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1545208846302},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1545208846596},{"_id":"themes/beantech/layout/archive.ejs","hash":"89a5b2ff2e5ef204d06c7a2dc02ae49edb8d7c1c","modified":1545898858096},{"_id":"themes/beantech/layout/index.ejs","hash":"e1cb7d2d2e11f082903f5167a1dc16e5b8870660","modified":1545900378239},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1545208846598},{"_id":"themes/beantech/layout/keynote.ejs","hash":"7fe853b7bbcaa45f8b770314484df46d6871ed58","modified":1545900313155},{"_id":"themes/beantech/layout/layout.ejs","hash":"9df05fc62dd09934e6b641216c1914c1a4cd1bb1","modified":1545893974440},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1545208846599},{"_id":"themes/beantech/layout/post.ejs","hash":"f9feb77d0aa0674899bed78491268b6c799664ee","modified":1545893974440},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1545208846600},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1545208846593},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1545208846594},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1545208846594},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1545208846595},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1545208846595},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1545208846595},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1545208846595},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1545208846595},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1545208846596},{"_id":"source/_posts/2018-12-20-gulp-series-1.md","hash":"d5832ec8ec0d424e57a39f14fda2a1afd26faf52","modified":1545903397486},{"_id":"source/_posts/2018-12-26-gulp-series-2-glob.md","hash":"54b8fb3cfecdb98a790d33a0a5a1cf4200072284","modified":1545893974438},{"_id":"source/_posts/about-file-upload-1.md","hash":"67d7a2e5a53f1a101b0998799901896d1048beac","modified":1545382156898},{"_id":"source/_posts/get-started-ejs.md","hash":"3bf26edda87a788745e0bb1c0fa3232b49d73c2a","modified":1545904964844},{"_id":"source/_posts/get-started-of-golang-with-mongodb.md","hash":"3993d7c9a7f7c216182cce875e98ef98514bdf2f","modified":1545208846302},{"_id":"source/_posts/golang-package-etc.md","hash":"84028c24adf16ab23a1684f25e6b53e76f969c9e","modified":1545208846303},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","hash":"5b44ff6b70cd69dcbc3252d83378b249647b5d1b","modified":1545208846324},{"_id":"source/about/index.md","hash":"a86dfe641c0888efc4de2eca9d921bc4c69e5741","modified":1545382156922},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1545208846334},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1545208846590},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1545208846583},{"_id":"source/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1545208846584},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"11feb33cf824ecaa92c9ed8d337c8a53cb882fcb","modified":1545382156932},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"1aaf899dfb537bc1df75deee36d6319fd82d9ee1","modified":1545893974439},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"69858610e10b900b6c3a58d586c0bb3f10869c00","modified":1545898217567},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"bee6f82ed03fd4f5f9cf634e4ea8be5000facb10","modified":1545893974439},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1545208846597},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1545208846597},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1545208846597},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1545208846597},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1545208846598},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1545208846598},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1545208846598},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1545208846598},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1545208846598},{"_id":"themes/beantech/source/css/ben.styl","hash":"16a43a565f975ffc2b4ade03fc4ca9453aac63fb","modified":1545902306166},{"_id":"themes/beantech/source/css/archive.styl","hash":"9beb0218f199e99a87a7c7a6b49281e641c46ecb","modified":1545899107506},{"_id":"themes/beantech/source/css/beantech.css","hash":"7664103631edfe66b8ff5c5672431d31c8b55937","modified":1545893974440},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1545208846602},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1545208846602},{"_id":"themes/beantech/source/css/post.styl","hash":"062594dce3301b90a80f46c6d7483cddb8fc7b30","modified":1545903227614},{"_id":"themes/beantech/source/css/rocket.styl","hash":"4a7d3bcc353cc45e7cd7fb5553a5722cd751c2fb","modified":1545208846603},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1545208846603},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1545208846603},{"_id":"themes/beantech/source/css/variables.styl","hash":"0676c512bf824047fc2093296363d5f03c787ba0","modified":1545899887273},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1545208846604},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1545208846604},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1545208846607},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1545208846606},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1545208846607},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1545208846609},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1545208846609},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1545208846609},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1545208846614},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1545208846614},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1545208846614},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1545208846614},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1545208846337},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1545208846605},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1545208846608},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545208846613},{"_id":"themes/beantech/source/css/css-dist/beantech.min.css","hash":"b2d58439965743b9a06a84f13c1a39a418e2e5f5","modified":1545382156935},{"_id":"themes/beantech/source/css/images/me.jpg","hash":"707dfb5299ac612d6a762ad7012dcb5d65560720","modified":1545208846603},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1545208846603},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1545208846601},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1545208846602},{"_id":"themes/beantech/source/css/images/uparrow.png","hash":"dc0fc57fbdd20ff60a8ead63c84a38c3bfe3d786","modified":1545208846603},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1545208846321},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1545208846327},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1545208846351},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1545208846323},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1545208846583},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1545208846612},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1545208846333},{"_id":"source/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1545382156929},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1545208846347},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1545208846578},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1545208846317},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1545208846564},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1545208846545},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1545382156917},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1545208846370},{"_id":"source/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1545208846516},{"_id":"public/post-sitemap.xml","hash":"2960dd5c8aef674aa400f9d9417656bb0d736c19","modified":1545904982684},{"_id":"public/page-sitemap.xml","hash":"550216200cf4528ea073495479598ed99f84c5bd","modified":1545897183173},{"_id":"public/tag-sitemap.xml","hash":"aafd3048d7593821070ff996c927cedc7f11561f","modified":1545904982684},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1545897183454},{"_id":"public/sitemap.xml","hash":"cc4bcb02a5298608849db674aba927a4d533a92e","modified":1545904982870},{"_id":"public/404.html","hash":"58ce052f254025fe12f0a92631efe4ca4990ab27","modified":1545899755653},{"_id":"public/tags/index.html","hash":"58a69d5a54455332e76464da4efc56f21b4449a0","modified":1545904982945},{"_id":"public/2018/02/02/get-started-of-golang-with-mongodb/index.html","hash":"31c378faeb62aea90bccb132112ef5b352d28435","modified":1545897797847},{"_id":"public/about/index.html","hash":"50092d884156cd914aa791ee276173e16dc21add","modified":1545904982945},{"_id":"public/2018/12/26/gulp-series-2-glob/index.html","hash":"c99ec7984bbe5520e492faba4f90daafcb80676a","modified":1545904982946},{"_id":"public/2018/12/20/gulp-series-1/index.html","hash":"1186e6ad7626a71a5537269d6b581294a7c3f2ee","modified":1545904982946},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/index.html","hash":"6b99a8455c2c9dae950f5b646a1e93c2ec89274b","modified":1545904982946},{"_id":"public/2018/02/05/golang-package-etc/index.html","hash":"43c3094b849707e19d03a90b5ba0782ac166e670","modified":1545897797848},{"_id":"public/2018/02/02/get-started-ejs/index.html","hash":"64ea507687d7e706823112880aa9456adda4a9a1","modified":1545904982946},{"_id":"public/2015/11/20/about-file-upload-1/index.html","hash":"4842be8e2428a0fc4339e60c5bca4042e7df3afa","modified":1545897797849},{"_id":"public/archive/index.html","hash":"6982751bd201ba7e29afaea20b58d667f5f0a3fc","modified":1545904982945},{"_id":"public/index.html","hash":"646705d07aec2d94c8cd3bac28b5933945daffea","modified":1545904982946},{"_id":"public/tags/gulp/index.html","hash":"bf47c8462b488f0e103043f70490cd0f202e3057","modified":1545904982945},{"_id":"public/tags/micro-service/index.html","hash":"1c2bb935019368c99c1ce1f82258dd79e1d50423","modified":1545904982945},{"_id":"public/archives/index.html","hash":"6275fd4400458e7dd2d6d742c5a660eeecbf03a6","modified":1545904982945},{"_id":"public/archives/2015/index.html","hash":"7b49e7c03e7db8dd483c007364be5305049d5662","modified":1545904982946},{"_id":"public/archives/2015/11/index.html","hash":"3c922dc951848ac331b3a4054d5dc1f1d87add6a","modified":1545904982946},{"_id":"public/archives/2018/index.html","hash":"54dcd54ea3778752ec930a0dad9f8ccffb23610e","modified":1545904982946},{"_id":"public/archives/2018/02/index.html","hash":"658735a2c334fbf2c31078b190108340b99ccbd7","modified":1545904982946},{"_id":"public/archives/2018/06/index.html","hash":"92f8560785ab1aca3f4ad56b3f12494a527bf9da","modified":1545904982946},{"_id":"public/archives/2018/12/index.html","hash":"9c69678af10bb696656d75071e0221a86f9ebda7","modified":1545904982946},{"_id":"public/CNAME","hash":"f0f745e69d0cc6071700b91dedb02509acaeea1d","modified":1545897183545},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1545897183545},{"_id":"public/img/me.jpg","hash":"47c60e2f48f4f413694086b260872e1183c2e6a2","modified":1545897183545},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1545897183545},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1545897183545},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1545897183545},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1545897183545},{"_id":"public/css/images/me.jpg","hash":"707dfb5299ac612d6a762ad7012dcb5d65560720","modified":1545897183546},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1545897183546},{"_id":"public/css/images/uparrow.png","hash":"dc0fc57fbdd20ff60a8ead63c84a38c3bfe3d786","modified":1545897183546},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1545897183891},{"_id":"public/css/ben.css","hash":"52ce33d27a35b0ab2264fc568260dab2c17d1529","modified":1545902330272},{"_id":"public/css/archive.css","hash":"f3e2c93dc634f2350320587230bf8107fb644c53","modified":1545899755837},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1545897183897},{"_id":"public/css/rocket.css","hash":"88ed942e6b6f135d8b9c3731373890efbd0b5b2b","modified":1545897183897},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1545897183897},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1545897183897},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1545897183898},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1545897183898},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1545897183898},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1545897183898},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1545897183898},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1545897183898},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1545897183898},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545897183898},{"_id":"public/css/post.css","hash":"980d02d1cccd23dfe3c23533d9d45dee23258a17","modified":1545904983211},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1545897183899},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","hash":"2633e189062e9d1f9a0d7b0b6cd095c1a6cb4682","modified":1545897183899},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1545897183905},{"_id":"public/css/beantech.css","hash":"7664103631edfe66b8ff5c5672431d31c8b55937","modified":1545897183912},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1545897183912},{"_id":"public/css/css-dist/beantech.min.css","hash":"b2d58439965743b9a06a84f13c1a39a418e2e5f5","modified":1545897183912},{"_id":"public/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","hash":"953f434731b8642fbf48975358483ee0eb22407b","modified":1545897183912},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1545897183921},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1545897183922},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1545897183950},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545897183955},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1545897183962},{"_id":"public/img/header_img/reed-xia-790819-unsplash.jpg","hash":"f9b37fe9ff1950d88080cb68ae50608e80807b68","modified":1545897183967},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1545897183971},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1545897183981},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1545897183986},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1545897184006},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1545897184007},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1545897184009},{"_id":"public/2015/11/20/about-file-upload-1/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1545897184013},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1545897184020},{"_id":"public/img/header_img/forrest.jpeg","hash":"98b93dc4e9fa536b9d32174a048d2bf941f70d5c","modified":1545897184081},{"_id":"public/tags/ejs/index.html","hash":"5854ab0db1af7efb05745028a73b96233cfc7300","modified":1545904982945}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-12-19T08:40:46.301Z","updated":"2018-12-19T08:40:46.301Z","path":"404.html","title":"","comments":1,"_id":"cjq6b9n220000cdx7z2f286z5","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/reed-xia-790819-unsplash.jpg","comments":1,"_content":"\n\n图片来自：Photo by Reed Xia on Unsplash\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img:  \"img/header_img/reed-xia-790819-unsplash.jpg\"\ncomments: true\n---\n\n\n图片来自：Photo by Reed Xia on Unsplash\n\n","updated":"2018-12-21T08:49:16.922Z","path":"about/index.html","_id":"cjq6b9n430002cdx77khx0qtg","content":"<p>图片来自：Photo by Reed Xia on Unsplash</p>\n","site":{"data":{}},"excerpt":"","more":"<p>图片来自：Photo by Reed Xia on Unsplash</p>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-12-19T08:40:46.334Z","path":"archive/index.html","_id":"cjq6b9n4d0004cdx7vj6jm6dg","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-12-19T08:40:46.590Z","updated":"2018-12-19T08:40:46.590Z","path":"tags/index.html","comments":1,"_id":"cjq6b9n540007cdx7brhmqilb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"gulp 拾遗 - nodejs/配置文件/环境变量","catalog":true,"date":"2018-12-20T06:38:57.000Z","subtitle":"在学习之前，有必要夯实基础","header-img":null,"_content":"## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","source":"_posts/2018-12-20-gulp-series-1.md","raw":"---\ntitle: gulp 拾遗 - nodejs/配置文件/环境变量\ncatalog: true\ndate: 2018-12-20 14:38:57\nsubtitle: 在学习之前，有必要夯实基础\nheader-img: \ntags: gulp\n---\n## 楔子\n最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。\n\n当然，本文还是将话题限制在 [gulp](https://gulpjs.com/) 方面。\n\n负责过工程脚本的，对于 gulp，甚至在它之前的 [grunt](https://gruntjs.com/)，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 [browserfily](http://browserify.org/)/[webpack](https://webpack.js.org/)/[rollup](https://rollupjs.org/guide/en)/[parcel](https://parceljs.org/) ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。\n\n## Nodejs\n\n编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 [fs](https://nodejs.org/api/fs.html)（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 [path](https://nodejs.org/api/path.html) 模块。[process](https://nodejs.org/api/process.html) 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。 \n\n如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)，以便用户浏览器正确的解析你的文件。\n\n如果还需要调用某些远端 api 来更新数据，那就要借助 [request](https://github.com/request/request) 或者 [request-promise](https://github.com/request/request-promise)。\n\n```javascript\nrequest({url, method, body})\n```\n\n## gulp 任务\n从 gulp 4.x 开始，任务的编写方式变成定义function，如\n```javascript\nfunction deploy(){...}\n\nexports.deploy = deploy\n```\n\n而在此之前，编写任务使用下面的方式\n```javascript\ngulp.task('deploy', function(){...})\n```\n\n新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。**尽量少做，将自由留给用户**。另一个领域也奉行这个原则的是 reactjs。\n\n另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。\n```javascript\ngulp.series(task1, task2, ...)\ngulp.parallel(task1, task2, ...)\n```\n\n## 配制文件\n很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。\n```javascript\nrequire('config.json')\n```\njson 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。 \n\n## 环境变量\n有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。\n\n本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。\n\n有三种使用环境变量的方式：\n1. 修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。\n2. 在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。\n3. 保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 [dotenv](https://github.com/motdotla/dotenv)。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。\n\n综上，dotenv 是目前最好的方案。\n\n## 总结\n本文作为 gulp 系列的开篇，主要阐述下面几个观点。\n* gulp 是基础的任务管理工具。\n* 编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。\n* gulp 4.x 的任务编写更加简洁可扩展。\n* 使用 yaml  作为配置管理文件 。\n* 使用 dotenv 为本地开发提供环境变量。\n\n\n\n","slug":"gulp-series-1","published":1,"updated":"2018-12-27T09:36:37.486Z","_id":"cjq6b9n3u0001cdx76u94ojx7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"楔子\">楔子</span></h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2><span id=\"nodejs\">Nodejs</span></h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"gulp-任务\">gulp 任务</span></h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"配制文件\">配制文件</span></h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2><span id=\"环境变量\">环境变量</span></h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>楔子</h2>\n<p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p>\n<p>当然，本文还是将话题限制在 <a href=\"https://gulpjs.com/\" target=\"_blank\" rel=\"noopener\">gulp</a> 方面。</p>\n<p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href=\"https://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserfily</a>/<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a>/<a href=\"https://rollupjs.org/guide/en\" target=\"_blank\" rel=\"noopener\">rollup</a>/<a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noopener\">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p>\n<h2>Nodejs</h2>\n<p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\" rel=\"noopener\">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href=\"https://nodejs.org/api/path.html\" target=\"_blank\" rel=\"noopener\">path</a> 模块。<a href=\"https://nodejs.org/api/process.html\" target=\"_blank\" rel=\"noopener\">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p>\n<p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">mime type</a>，以便用户浏览器正确的解析你的文件。</p>\n<p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href=\"https://github.com/request/request\" target=\"_blank\" rel=\"noopener\">request</a> 或者 <a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure>\n<h2>gulp 任务</h2>\n<p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.deploy = deploy</span><br></pre></td></tr></table></figure>\n<p>而在此之前，编写任务使用下面的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'deploy'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p>\n<p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.series(task1, task2, ...)</span><br><span class=\"line\">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure>\n<h2>配制文件</h2>\n<p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'config.json'</span>)</span><br></pre></td></tr></table></figure>\n<p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p>\n<h2>环境变量</h2>\n<p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p>\n<p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p>\n<p>有三种使用环境变量的方式：</p>\n<ol>\n<li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li>\n<li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li>\n<li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noopener\">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li>\n</ol>\n<p>综上，dotenv 是目前最好的方案。</p>\n<h2>总结</h2>\n<p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p>\n<ul>\n<li>gulp 是基础的任务管理工具。</li>\n<li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li>\n<li>gulp 4.x 的任务编写更加简洁可扩展。</li>\n<li>使用 yaml  作为配置管理文件 。</li>\n<li>使用 dotenv 为本地开发提供环境变量。</li>\n</ul>\n"},{"title":"gulp 拾遗 (2) - 认识 glob","catalog":true,"date":"2018-12-26T09:05:16.000Z","subtitle":"一直纠结于书写各种文件查找脚本，直到遇见 glob","header-img":null,"_content":"# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","source":"_posts/2018-12-26-gulp-series-2-glob.md","raw":"---\ntitle: gulp 拾遗 (2) - 认识 glob \ncatalog: true\ndate: 2018-12-26 17:05:16\nsubtitle: 一直纠结于书写各种文件查找脚本，直到遇见 glob\nheader-img:\ntags: gulp\n---\n# 为什么要用 glob\ngulp 的 [task](https://gulpjs.com/docs/en/getting-started/creating-tasks) 函数一般起自于 [src](https://gulpjs.com/docs/en/api/src) ：\n```javascript\nconst { src, dest } = require('gulp');\n\nfunction copy() {\n  return src('input/*.js')\n    .pipe(dest('output/'));\n}\n```\n简单来说， **src** API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。\n```bash\nls ./input/*.js\n```\nglob 语句很容易理解，比如上面的 input/*.js，表示 input 目录下（不包含子目录），扩展名为 js 的**所有**文件。\n\n如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。\n\n# node-glob\n目前，glob 最好的实现应该是 [node-glob](https://github.com/isaacs/node-glob)。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。\n\n```javascript\nvar glob = require(\"glob\")\n\n// options is optional\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n  // If the `nonull` option is set, and nothing\n  // was found, then files is [\"**/*.js\"]\n  // er is an error object or null.\n})\n```\n\n## pattern\npattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。\n```\n* 匹配 0 或多个字符\n? 匹配 1 个字符\n[...] 匹配一系列字符，比如 [a-z], [0-9]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。\n!(pattern|pattern|pattern) 匹配不符合所有 pattern 的字符\n?(pattern|pattern|pattern) 匹配 0 或 1 个符合其中一个 pattern 的内容\n+(pattern|pattern|pattern) 匹配 1 或多个符合至少其中一个 pattern 的内容\n*(a|b|c) 匹配 0 或多个符合至少其中一个 pattern 的内容\n@(pattern|pat*|pat?erN) 匹配 1个至少符合其中一个 pattern 的内容\n** 两个星号匹配 0 或多个目录\n```\n上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。\n\n## options\n[options]((https://gulpjs.com/docs/en/api/src#options)) 中的选项很多，拣几个常用的讲一下。\n### cwd \ncwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：\n```bash\n/home/wangpin $ node index.js\n```\n此时，cwd 是 /home/wangpin。\n如果我们在 home 目录下启动 index.js：\n```bash\n/home $ node wangpin/index.js\n```\n此时，cwd 是 /home。\n\n简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。\n\n### ignore\n设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即\n```\nfiles -- pattern: include --> files -- ignore: exclude --> files\n```\n比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：\n```javascript\nglob('./input/*.js', {ignore: './input/*.min.js'})\n```\n\n# gulp 中的 glob\ngulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 [glob-stream](https://github.com/gulpjs/glob-stream)，[vinyl-fs](https://github.com/gulpjs/vinyl-fs) 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 [concepts](https://gulpjs.com/docs/en/api/)。\n\n# 其他脚本中的 glob\n编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：\n```javascript\nfunction deploy(src) {\n  let totalFiles = []\n  function listFiles(folder) {\n    return fs.readdirAsync(folder)\n      .then(function(list){\n        list = list.map(function(f){\n          return path.join(folder, f)\n        })\n        let files = list.filter(function(file){\n          return fs.statSync(file).isFile()\n        })\n        totalFiles = totalFiles.concat(files)\n        let folders = list.filter(function(file){\n          return fs.statSync(file).isDirectory()\n        })\n          .map(function(folder){\n            return listFiles(folder)\n          })\n        return Promise.all(folders)\n      })\n      .catch(function(e){\n        console.error(e)\n      })\n  }\n\n  return listFiles(src)\n    .then(function(){\n      return Promise.all(totalFiles.map(function(file){\n        return put(file, src)\n      }))\n    })\n}\n```\n这还没有涉及复杂的 include 和 exclude 规则，已经是比较**大**的函数了。\n如果用 glob 重构一下呢？\n```javascript\nfunction deploy(globs, opts) {\n  return (new Promise(function(resolve, reject){\n      glob(globs, opts, function(err, files){\n        if (err) {\n          reject(err)\n        }\n        resolve(files.filter(function(file){\n          return fs.statSync(file).isFile()\n        }))\n      })\n    }))\n    .then(function(files){\n      return Promise.all(files.map(function(file){\n        return put(file)\n      }))\n    })\n}\n```\n代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。\n\n# 总结\nglob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。\n\n文中提到的库，文档，及相关资料地址。\n* [node-glob](https://github.com/isaacs/node-glob)\n* [gulp concepts](https://gulpjs.com/docs/en/api/concepts)\n* [gulp expaining globs](https://gulpjs.com/docs/en/getting-started/explaining-globs)\n\n\n\n\n\n\n","slug":"gulp-series-2-glob","published":1,"updated":"2018-12-27T06:59:34.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6b9n460003cdx7alxa53y0","content":"<h1><span id=\"为什么要用-glob\">为什么要用 glob</span></h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1><span id=\"node-glob\">node-glob</span></h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"pattern\">pattern</span></h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2><span id=\"options\">options</span></h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3><span id=\"cwd\">cwd</span></h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3><span id=\"ignore\">ignore</span></h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1><span id=\"gulp-中的-glob\">gulp 中的 glob</span></h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1><span id=\"其他脚本中的-glob\">其他脚本中的 glob</span></h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1><span id=\"总结\">总结</span></h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>为什么要用 glob</h1>\n<p>gulp 的 <a href=\"https://gulpjs.com/docs/en/getting-started/creating-tasks\" target=\"_blank\" rel=\"noopener\">task</a> 函数一般起自于 <a href=\"https://gulpjs.com/docs/en/api/src\" target=\"_blank\" rel=\"noopener\">src</a> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; src, dest &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> src(<span class=\"string\">'input/*.js'</span>)</span><br><span class=\"line\">    .pipe(dest(<span class=\"string\">'output/'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls ./input/*.js</span><br></pre></td></tr></table></figure>\n<p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p>\n<p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p>\n<h1>node-glob</h1>\n<p>目前，glob 最好的实现应该是 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">\"glob\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// options is optional</span></span><br><span class=\"line\">glob(<span class=\"string\">\"**/*.js\"</span>, options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">er, files</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// files is an array of filenames.</span></span><br><span class=\"line\">  <span class=\"comment\">// If the `nonull` option is set, and nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// was found, then files is [\"**/*.js\"]</span></span><br><span class=\"line\">  <span class=\"comment\">// er is an error object or null.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2>pattern</h2>\n<p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 匹配 <span class=\"number\">0</span> 或多个字符</span><br><span class=\"line\">? 匹配 <span class=\"number\">1</span> 个字符</span><br><span class=\"line\">[...] 匹配一系列字符，比如 [a-z], [<span class=\"number\">0</span><span class=\"number\">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class=\"line\">!(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配不符合所有 <span class=\"built_in\">pattern</span> 的字符</span><br><span class=\"line\">?(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">0</span> 或 <span class=\"number\">1</span> 个符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">+(<span class=\"built_in\">pattern</span>|<span class=\"type\">pattern</span>|<span class=\"type\">pattern</span>) 匹配 <span class=\"number\">1</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">*(a|<span class=\"type\">b</span>|<span class=\"type\">c</span>) 匹配 <span class=\"number\">0</span> 或多个符合至少其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">@(<span class=\"built_in\">pattern</span>|<span class=\"type\">pat</span>*|<span class=\"type\">pat</span>?erN) 匹配 <span class=\"number\">1</span>个至少符合其中一个 <span class=\"built_in\">pattern</span> 的内容</span><br><span class=\"line\">** 两个星号匹配 <span class=\"number\">0</span> 或多个目录</span><br></pre></td></tr></table></figure>\n<p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p>\n<h2>options</h2>\n<p><a href=\"(https://gulpjs.com/docs/en/api/src#options)\">options</a> 中的选项很多，拣几个常用的讲一下。</p>\n<h3>cwd</h3>\n<p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home/wangpin。<br>\n如果我们在 home 目录下启动 index.js：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure>\n<p>此时，cwd 是 /home。</p>\n<p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p>\n<h3>ignore</h3>\n<p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">pattern:</span> <span class=\"comment\">include</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span> <span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">ignore:</span> <span class=\"comment\">exclude</span> <span class=\"literal\">-</span><span class=\"literal\">-</span>&gt; <span class=\"comment\">files</span></span><br></pre></td></tr></table></figure>\n<p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glob(<span class=\"string\">'./input/*.js'</span>, &#123;<span class=\"attr\">ignore</span>: <span class=\"string\">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h1>gulp 中的 glob</h1>\n<p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href=\"https://github.com/gulpjs/glob-stream\" target=\"_blank\" rel=\"noopener\">glob-stream</a>，<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"noopener\">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href=\"https://gulpjs.com/docs/en/api/\" target=\"_blank\" rel=\"noopener\">concepts</a>。</p>\n<h1>其他脚本中的 glob</h1>\n<p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> totalFiles = []</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listFiles</span>(<span class=\"params\">folder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readdirAsync(folder)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>)</span>&#123;</span><br><span class=\"line\">        list = list.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> path.join(folder, f)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> files = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        totalFiles = totalFiles.concat(files)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> folders = list.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isDirectory()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">          .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">folder</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> listFiles(folder)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(folders)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(e)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> listFiles(src)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(totalFiles.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file, src)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>\n如果用 glob 重构一下呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deploy</span>(<span class=\"params\">globs, opts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">      glob(globs, opts, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(files.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fs.statSync(file).isFile()</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(files.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> put(file)</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p>\n<h1>总结</h1>\n<p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p>\n<p>文中提到的库，文档，及相关资料地址。</p>\n<ul>\n<li><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">node-glob</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/api/concepts\" target=\"_blank\" rel=\"noopener\">gulp concepts</a></li>\n<li><a href=\"https://gulpjs.com/docs/en/getting-started/explaining-globs\" target=\"_blank\" rel=\"noopener\">gulp expaining globs</a></li>\n</ul>\n"},{"title":"文件上传二三事","catalog":true,"date":"2015-11-20T10:05:52.000Z","subtitle":null,"header-img":"home-bg-2-dark.png","_content":"# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","source":"_posts/about-file-upload-1.md","raw":"---\ntitle: 文件上传二三事\ncatalog: true\ndate: 2015-11-20 18:05:52\nsubtitle:\nheader-img: home-bg-2-dark.png\ntags:\n---\n# 引子\n\n其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。 \n\n--跟生孩子一样啊。\n# 选择文件\n\n谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。\n\n```\n<form name=\"uploadForm\" action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\nfile:<input type=\"file\" name=\"anyname\"/>\n</form>\n```\n\naction 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 **_multipart/form-data**_。\n\n具体的定义参见 [form](http://www.w3school.com.cn/tags/tag_form.asp)。\n\n下面是对应的页面，可以看到，有一个提示选择文件的按钮\n\n![file-upload](https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG)\n\n点击按钮，就可以选择文件啦。\n\n![choose-file](https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif)\n- 小贴士：文件选择好之后，可以通过 [FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 进行预览，或者简单的编辑。\n# 如何上传\n\n简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。\n# 增强实现\n\n上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。\n## 美化选择按钮\n\n浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。\n\n```\n.chooseFile{\n    min-width: 30px;\n    min-height: 15px;\n    width: 106px;\n    height: 29px;\n    background-color: #B6E2C9;\n    color: black;\n    font-family: monospace;\n    font-weight: 400;\n    border-color: white;\n    border-radius: 17px;\n    padding: 5px;\n    text-align: center;\n    vertical-align: middle;\n    cursor: pointer;\n}\n```\n\n记得把原来的form隐藏掉。\n\n接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。\n\n![custom-choose](https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif)\n## 不想刷新页面\n\n有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？\n\n第一个想出这个办法的肯定是个头脑灵活的家伙--使用隐藏的 iframe 上传。\n\n原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。\n\n当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。\n\n这个方案有个缺点，就是需要前后端协同工作。\n\n当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）\n\n比如，父页面须定义回调函数\n\n```\nfunction uploadSuccess (result){\n...\n}\n```\n\n后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。\n\n```\n<html>\n...\n<script>\nwindow.uploadSuccess('xxxxxx');\n</sript>\n...\n</html>\n```\n\n当然，如果你是**_全栈工程师**_,这都不算事。自己一个人搞，还约定个啥。\n## FormData，ajax文件上传\n\n你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？\n\n客官，看来你需要的是 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)。\n\nFormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。\n\n```\nvar data = new FormData();\ndata.append('file', fileObj);\n\n$.ajax({\n    url: '/upload',\n    type: 'POST',\n    data: data,\n    cache: false,\n    dataType: 'json',\n    processData: false, // Don't process the files\n    contentType: false, // Set content type to false as jQuery will tell the server its a query string request\n    success: function(data, textStatus, jqXHR) {\n        console.log(JSON.stringify(data, null, 4));\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n          //jqXHR may have no responseJSON in old jquery\n        console.log(JSON.stringify(jqXHR.responseJSON, null, 4));\n    }\n});\n```\n\n需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。\n\n一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。\n# 文件验证\n\n有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。\n## 前端\n\n前端获取这三个属性非常简单。\n\n```\nvar file = uploadForm.anyname.files[0];\nconsole.log(file.name);\nconsole.log(file.size);\nconsole.log(file.type);\n```\n\n更详细的介绍 [file api](https://developer.mozilla.org/zh-CN/docs/Web/API/File)\n## 后端\n\n相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。\n\nhttp 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。\n\nhttp 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome \n\n```\n------WebKitFormBoundarycKtZKQMmA6QfpeMW\nContent-Disposition: form-data; name=\"file\"; filename=\"bt.jpg\"\nContent-Type: image/jpeg\n\n\n------WebKitFormBoundarycKtZKQMmA6QfpeMW--\n```\n\n并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。\n\n后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。\n\n有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化--能不做，尽量不做。）。 \n# 为什么叫二三事\n\n也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 **_二三**_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。\n# 后记\n## 补充\n- 除了 file 表单，file对象还可以从拖拽事件中获取。\n\n```\ne.dataTransfer.files\n```\n- http body中，上传文件的边界可以由程序指定\n\n```\nvar boundary = 'fdfrefdrerefdfd';\nxhr.setRequestHeader(\"Content-Type\", \"multipart/form-data, boundary=\"+boundary); // simulate a file MIME POST request.  \nxhr.setRequestHeader(\"Content-Length\", fileSize);  \n\nvar body = '';  \nbody += \"--\" + boundary + \"\\r\\n\";  \nbody += \"Content-Disposition: form-data; name=\\\"\"+dropbox.getAttribute('name')+\"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";  \nbody += \"Content-Type: \"+fileType+\"\\r\\n\\r\\n\";  \nbody += fileData + \"\\r\\n\";  \nbody += \"--\" + boundary + \"--\\r\\n\";  \n\nxhr.sendAsBinary(body);  \n```\n","slug":"about-file-upload-1","published":1,"updated":"2018-12-21T08:49:16.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6b9n4z0006cdx7wt76n5u6","content":"<h1><span id=\"引子\">引子</span></h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1><span id=\"选择文件\">选择文件</span></h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1><span id=\"如何上传\">如何上传</span></h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1><span id=\"增强实现\">增强实现</span></h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2><span id=\"美化选择按钮\">美化选择按钮</span></h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2><span id=\"不想刷新页面\">不想刷新页面</span></h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> (<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"built_in\">window</span>.uploadSuccess(<span class=\"string\">'xxxxxx'</span>);</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"undefined\">...</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2><span id=\"formdataajax文件上传\">FormData，ajax文件上传</span></h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1><span id=\"文件验证\">文件验证</span></h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2><span id=\"前端\">前端</span></h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2><span id=\"后端\">后端</span></h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1><span id=\"为什么叫二三事\">为什么叫二三事</span></h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1><span id=\"后记\">后记</span></h1>\n<h2><span id=\"补充\">补充</span></h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>引子</h1>\n<p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p>\n<p>–跟生孩子一样啊。</p>\n<h1>选择文件</h1>\n<p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">form</span> name=<span class=\"string\">\"uploadForm\"</span> action=<span class=\"string\">\"/upload\"</span> method=<span class=\"string\">\"post\"</span> enctype=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">file</span>:&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">type</span>=<span class=\"string\">\"file\"</span> name=<span class=\"string\">\"anyname\"</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">form</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p>\n<p>具体的定义参见 <a href=\"http://www.w3school.com.cn/tags/tag_form.asp\" target=\"_blank\" rel=\"noopener\">form</a>。</p>\n<p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG\" alt=\"file-upload\"></p>\n<p>点击按钮，就可以选择文件啦。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif\" alt=\"choose-file\"></p>\n<ul>\n<li>小贴士：文件选择好之后，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">FileReader</a> 进行预览，或者简单的编辑。</li>\n</ul>\n<h1>如何上传</h1>\n<p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p>\n<h1>增强实现</h1>\n<p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p>\n<h2>美化选择按钮</h2>\n<p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.chooseFile</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">min-width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">min-height</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">106px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">29px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#B6E2C9</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: monospace;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: <span class=\"number\">400</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: white;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记得把原来的form隐藏掉。</p>\n<p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif\" alt=\"custom-choose\"></p>\n<h2>不想刷新页面</h2>\n<p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p>\n<p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p>\n<p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p>\n<p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p>\n<p>这个方案有个缺点，就是需要前后端协同工作。</p>\n<p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p>\n<p>比如，父页面须定义回调函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uploadSuccess</span> (<span class=\"params\">result</span>)</span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"built_in\">window</span>.uploadSuccess(<span class=\"string\">'xxxxxx'</span>);</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">sript</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"undefined\">...</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n<p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p>\n<h2>FormData，ajax文件上传</h2>\n<p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p>\n<p>客官，看来你需要的是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects\" target=\"_blank\" rel=\"noopener\">FormData</a>。</p>\n<p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">'file'</span>, fileObj);</span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'/upload'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">    processData: <span class=\"literal\">false</span>, <span class=\"comment\">// Don't process the files</span></span><br><span class=\"line\">    contentType: <span class=\"literal\">false</span>, <span class=\"comment\">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//jqXHR may have no responseJSON in old jquery</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(jqXHR.responseJSON, <span class=\"literal\">null</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p>\n<p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p>\n<h1>文件验证</h1>\n<p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p>\n<h2>前端</h2>\n<p>前端获取这三个属性非常简单。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">file</span> = uploadForm.anyname.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">name</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"built_in\">size</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"keyword\">file</span>.<span class=\"keyword\">type</span>);</span><br></pre></td></tr></table></figure>\n<p>更详细的介绍 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File\" target=\"_blank\" rel=\"noopener\">file api</a></p>\n<h2>后端</h2>\n<p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p>\n<p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p>\n<p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"bt.jpg\"</span></span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure>\n<p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p>\n<p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p>\n<p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p>\n<h1>为什么叫二三事</h1>\n<p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p>\n<h1>后记</h1>\n<h2>补充</h2>\n<ul>\n<li>除了 file 表单，file对象还可以从拖拽事件中获取。</li>\n</ul>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e<span class=\"selector-class\">.dataTransfer</span><span class=\"selector-class\">.files</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>http body中，上传文件的边界可以由程序指定</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boundary = 'fdfrefdrerefdfd';</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"multipart/form-data, boundary=\"</span>+boundary); <span class=\"comment\">// simulate a file MIME POST request.  </span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"Content-Length\"</span>, fileSize);  </span><br><span class=\"line\"></span><br><span class=\"line\">var body = '';  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Disposition: form-data; name=<span class=\"subst\">\\\"</span>\"</span>+dropbox.getAttribute('name')+<span class=\"string\">\"<span class=\"subst\">\\\"</span>; filename=<span class=\"subst\">\\\"</span>\"</span> + fileName + <span class=\"string\">\"<span class=\"subst\">\\\"</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"Content-Type: \"</span>+fileType+<span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += fileData + <span class=\"string\">\"\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\">body += <span class=\"string\">\"--\"</span> + boundary + <span class=\"string\">\"--\\r<span class=\"subst\">\\n</span>\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>\n"},{"title":"ejs 入门","catalog":true,"date":"2018-02-02T05:21:32.000Z","subtitle":"熟练掌握一种模板引擎可以极大的提高页面开发效率","header-img":null,"_content":"## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。首先，它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","source":"_posts/get-started-ejs.md","raw":"---\ntitle: ejs 入门\ncatalog: true\ndate: 2018-02-02 13:21:32\nsubtitle: 熟练掌握一种模板引擎可以极大的提高页面开发效率\nheader-img: \ntags: ejs\n---\n## 为什么要学习模板引擎\n在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。\n\n随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。\n\n回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。首先，它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。\n\n即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。\n\n今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。\n\n## 安装\n\nejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。\n\n通过 npm 安装：\n```\nnpm i ejs -S\n```\n\n也可以下载[独立版本](https://github.com/mde/ejs/releases/latest)。\n\n## 基本语法要素\nejs 的语法比较简单： 初始化模板->加载数据->渲染\n```javascript\n//str 模板内容，一般从 .ejs 模板文件读取\n//options 一些配置，比如分隔符，缓存，debug 输出，等等\nvar template = ejs.compile(str, options);\n\n//data 待渲染的数据\nvar html = template(data);\n```\n\n如果不需要复用模板，可以直接生成 html\n```javascript\nejs.render(str, data, options);\n```\n\n实际的例子：\ntemplate.ejs\n```ejs\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n<% } %>\n```\nindex.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30 } };\nvar template = ejs.compile(str);\nvar result = template(data);\n\nconsole.log(result);\n```\n\n输出结果:\n```\n <h2>wangpin</h2>\n```\n\n## 标签\n上面的 template 中，使用到 3 种标签。\n* <% 程序标签，控制流程，没有输出。比如这里的 if (user)\n* <%- 输出标签，不做转义\n* %> 结束标签\n\n还有其他 4 种类型，这里一一介绍。\n* <%= 输出标签，转义 html 字符，比如 < >\n* <%# 注释，不输出任何内容\n* <%% 输出 **<%**\n* -%> 结束便签，并删除最近的一个空行\n\n\n## 包含 Includes\n模板可以引用另一个模板的内容。\n```ejs\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n两个要点：\n* 不能转义模板内容，所以这里**必须**使用 **<%-**。\n* 初始化父 template 的时候，options 中必须指定 filename。\n\n简单的例子：\nsubTemplate.ejs\n```\n<a href=\"#\"><%- user.hometown %></a>\n```\ntemplate.ejs\n```\n<% if (user) { %>\n  <h2><%- user.name %></h2>\n  <%- include('./subTemplate', {user: user}); %>\n<% } %>\n```\n\ntest.js\n```javascript\nvar ejs = require('ejs');\nvar fs = require('fs');\n\nvar str = fs.readFileSync('template.ejs', {encoding: 'utf8'});\nvar data = { user: { name: 'wangpin', age: 30, hometown: 'weinan' } };\n// 指定 filename 为 template\nvar template = ejs.compile(str, { filename: 'template'});\nvar result = template(data);\n\nconsole.log(result);\n```\n\n指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。\n\n> Includes are relative to the template with the include call\n\n\n## 定制分隔符\n默认使用的分隔符是 **%**, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。\n\n```javascript\nvar ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// Just one template\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// Or globally\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n```\n\n## 参考文档\n[http://ejs.co/](http://ejs.co/)\n","slug":"get-started-ejs","published":1,"updated":"2018-12-27T10:02:44.844Z","_id":"cjq6b9n590008cdx7mbd2rc53","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"为什么要学习模板引擎\">为什么要学习模板引擎</span></h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。首先，它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2><span id=\"安装\">安装</span></h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2><span id=\"基本语法要素\">基本语法要素</span></h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"标签\">标签</span></h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2><span id=\"包含-includes\">包含 Includes</span></h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2><span id=\"定制分隔符\">定制分隔符</span></h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"参考文档\">参考文档</span></h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>为什么要学习模板引擎</h2>\n<p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p>\n<p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p>\n<p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。首先，它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p>\n<p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p>\n<p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p>\n<h2>安装</h2>\n<p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p>\n<p>通过 npm 安装：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"selector-tag\">i</span> ejs -S</span><br></pre></td></tr></table></figure>\n<p>也可以下载<a href=\"https://github.com/mde/ejs/releases/latest\" target=\"_blank\" rel=\"noopener\">独立版本</a>。</p>\n<h2>基本语法要素</h2>\n<p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class=\"line\"><span class=\"comment\">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, options);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//data 待渲染的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> html = template(data);</span><br></pre></td></tr></table></figure>\n<p>如果不需要复用模板，可以直接生成 html</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure>\n<p>实际的例子：<br>\ntemplate.ejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if (user) &#123; %&gt;</span><br><span class=\"line\">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>wangpin<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>标签</h2>\n<p>上面的 template 中，使用到 3 种标签。</p>\n<ul>\n<li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li>\n<li>&lt;%- 输出标签，不做转义</li>\n<li>%&gt; 结束标签</li>\n</ul>\n<p>还有其他 4 种类型，这里一一介绍。</p>\n<ul>\n<li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li>\n<li>&lt;%# 注释，不输出任何内容</li>\n<li>&lt;%% 输出 <strong>&lt;%</strong></li>\n<li>-%&gt; 结束便签，并删除最近的一个空行</li>\n</ul>\n<h2>包含 Includes</h2>\n<p>模板可以引用另一个模板的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class=\"line\">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class=\"line\">  &lt;% &#125;); %&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<p>两个要点：</p>\n<ul>\n<li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li>\n<li>初始化父 template 的时候，options 中必须指定 filename。</li>\n</ul>\n<p>简单的例子：<br>\nsubTemplate.ejs</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span> <span class=\"attr\">user.hometown</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>template.ejs</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> <span class=\"keyword\">if</span> (user) &#123; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> user.name </span><span class=\"xml\"><span class=\"tag\">%&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">%-</span></span></span><span class=\"ruby\"> <span class=\"keyword\">include</span>(<span class=\"string\">'./subTemplate'</span>, &#123;<span class=\"symbol\">user:</span> user&#125;); </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><span class=\"ruby\"> &#125; </span><span class=\"xml\"><span class=\"tag\">%&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = fs.readFileSync(<span class=\"string\">'template.ejs'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'wangpin'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>, <span class=\"attr\">hometown</span>: <span class=\"string\">'weinan'</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 指定 filename 为 template</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> template = ejs.compile(str, &#123; <span class=\"attr\">filename</span>: <span class=\"string\">'template'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = template(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n<p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p>\n<blockquote>\n<p>Includes are relative to the template with the include call</p>\n</blockquote>\n<h2>定制分隔符</h2>\n<p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>),</span><br><span class=\"line\">    users = [<span class=\"string\">'geddy'</span>, <span class=\"string\">'neil'</span>, <span class=\"string\">'alex'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Just one template</span></span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;?= users.join(\" | \"); ?&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">delimiter</span>: <span class=\"string\">'?'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 'geddy | neil | alex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Or globally</span></span><br><span class=\"line\">ejs.delimiter = <span class=\"string\">'$'</span>;</span><br><span class=\"line\">ejs.render(<span class=\"string\">'&lt;$= users.join(\" | \"); $&gt;'</span>, &#123;<span class=\"attr\">users</span>: users&#125;);</span><br></pre></td></tr></table></figure>\n<h2>参考文档</h2>\n<p><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"noopener\">http://ejs.co/</a></p>\n"},{"title":"Golang：package 和 访问权限，以及其他基本知识总结","catalog":true,"date":"2018-02-05T07:46:05.000Z","subtitle":null,"header-img":null,"_content":"## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","source":"_posts/golang-package-etc.md","raw":"---\ntitle: Golang：package 和 访问权限，以及其他基本知识总结\ncatalog: true\ndate: 2018-02-05 15:46:05\nsubtitle: \nheader-img:\ntags:\n---\n## 引子\n\n新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。\n\n## 项目结构\n\n如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。\n\n```\n-- apis\n   | \n     - user.go\n     - addresss.go\n-- conf\n   | \n     - conf.yml\n-- main.go\n-- router.go\n-- routes.go\n```\n类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。\n\nmain.go\n```\npackage main\n\nfunc init() {}\nfunc main() {}\n```\n\n运行项目\n```\ngo build && ./*.exe\n```\n**将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。**\n\n## 访问权限\ngo 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。\n\n```\ntype s1 struct {}\ntype S1 struct {}\nfunc F1() {}\nfunc f1() {}\n```\n\n## 安装 lib\n学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。\n```\ngo get url\n```\n这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：\n```\n$ go get github.com/astaxie/beego\n```\n\nlib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。\n```\n[GO_PATH]/src\n  - github.com\n    - astaxie\n      - beego\n```\n\n如果需要代理才能上网，那就设置 http_proxy：\n```\n$ http_proxy=proxy.com:8080 go get code.google.com/p/go.crypto/bcrypt\n```\n设置系统环境变量也可以。\n[How go configure go to use a proxy?](https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy)\n\n或者简单点，设置一个别名。\n```\n$ alias go='http_proxy=proxy.com:8080 go\n```\n\n最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。\n\n## 管理依赖\n[dep](https://github.com/golang/dep) 或者 [godep](https://github.com/tools/godep)(**已经停止更新，不建议使用**)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。\n\n\n## 常用的 lib（web service 开发），小知识\n### web 框架，路由\n* [beego](https://beego.me/) 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。\n* [mux](https://github.com/gorilla/mux) 轻量级路由方案\n\n\n### yaml 文件解析\n一篇介绍很全面的博文 [A tour of YAML parsers for Go](http://sweetohm.net/article/go-yaml-parsers.en.html)\n* [go-gypsy](https://github.com/kylelemons/go-gypsy) 提供了很多 low level api，需要自己组织才能完全解析文件内容\n* [yaml](https://github.com/go-yaml/yaml) 只能支持 flat map\n","slug":"golang-package-etc","published":1,"updated":"2018-12-19T08:40:46.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6b9n5g0009cdx7dnkrfxf9","content":"<h2><span id=\"引子\">引子</span></h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2><span id=\"项目结构\">项目结构</span></h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2><span id=\"访问权限\">访问权限</span></h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"安装-lib\">安装 lib</span></h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2><span id=\"管理依赖\">管理依赖</span></h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2><span id=\"常用的-libweb-service-开发小知识\">常用的 lib（web service 开发），小知识</span></h2>\n<h3><span id=\"web-框架路由\">web 框架，路由</span></h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3><span id=\"yaml-文件解析\">yaml 文件解析</span></h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>引子</h2>\n<p>新项目开始用 golang 作为后台开发语言，我之前主要使用 java 和 nodejs，所以本文大部分是以 java 或者 node 的过来人视角来审视 golang。不足之处，欢迎指正。</p>\n<h2>项目结构</h2>\n<p>如果项目只有一个 go 文件，那我们完全不用考虑模块问题。但这完全不现实。你必须把源代码按照职能，分割成不同的文件，再按照一定的规则组织起来。通常情况下，你还得安装很多外部 lib，简化开发流程。比如数据库，网络，自己实现相似的功能对于项目本身来说，没有太大意义 - 性价比太低。下面是一个 go 项目的目录结构。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">- apis</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - user.go</span></span><br><span class=\"line\"><span class=\"ruby\">     - addresss.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- conf</span></span><br><span class=\"line\"><span class=\"ruby\">   <span class=\"params\">| </span></span></span><br><span class=\"line\"><span class=\"ruby\">     - conf.yml</span></span><br><span class=\"line\"><span class=\"ruby\">-- main.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- router.go</span></span><br><span class=\"line\"><span class=\"ruby\">-- routes.go</span></span><br></pre></td></tr></table></figure>\n<p>类似 java， 一个项目中只有一个 main 函数作为项目入口，通常定义在 main.go 中。</p>\n<p>main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>运行项目</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build &amp;&amp; <span class=\"string\">./</span>*<span class=\"string\">.exe</span></span><br></pre></td></tr></table></figure>\n<p><strong>将项目打包成可执行文件（windows平台，exe文件），然后运行 exe 文件。</strong></p>\n<h2>访问权限</h2>\n<p>go 没有类似 java 那样的设定访问权限的关键字如 public, protected, private， 而是通过资源命名方式来区分。首字母大写的即为 public，可以跨 package 调用。否则，只能本 package 调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> s1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> S1 <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">F1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2>安装 lib</h2>\n<p>学习任何语言，安装 lib 总是绕不开的话题。好在，golang 安装 lib 并不复杂。虽然没有类似 npm 这种高度中心化的 package 管理方案。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">go</span> <span class=\"built_in\">get</span> url</span><br></pre></td></tr></table></figure>\n<p>这里的url可以是任何能够提供 lib 安装包的地址。比如, 安装 beego：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> <span class=\"built_in\">get</span> github.<span class=\"keyword\">com</span>/astaxie/beego</span><br></pre></td></tr></table></figure>\n<p>lib 会安装在 {GO_PATH}/src 目录下, 按照 url 的路径，依次生成对应目录。</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GO_PATH]/src</span><br><span class=\"line\">  -<span class=\"ruby\"> github.com</span></span><br><span class=\"line\"><span class=\"ruby\">    - astaxie</span></span><br><span class=\"line\"><span class=\"ruby\">      - beego</span></span><br></pre></td></tr></table></figure>\n<p>如果需要代理才能上网，那就设置 http_proxy：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ http_proxy=proxy<span class=\"selector-class\">.com</span>:<span class=\"number\">8080</span> go get <span class=\"selector-tag\">code</span><span class=\"selector-class\">.google</span><span class=\"selector-class\">.com</span>/p/go.crypto/bcrypt</span><br></pre></td></tr></table></figure>\n<p>设置系统环境变量也可以。<br>\n<a href=\"https://stackoverflow.com/questions/10383299/how-do-i-configure-go-to-use-a-proxy\" target=\"_blank\" rel=\"noopener\">How go configure go to use a proxy?</a></p>\n<p>或者简单点，设置一个别名。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> <span class=\"built_in\">go</span>='http_proxy=proxy.com:<span class=\"number\">8080</span> <span class=\"built_in\">go</span></span><br></pre></td></tr></table></figure>\n<p>最直接的办法，通过任何可行的方式将 lib 下载下来，放在 GO_PATH 下对应目录。</p>\n<h2>管理依赖</h2>\n<p><a href=\"https://github.com/golang/dep\" target=\"_blank\" rel=\"noopener\">dep</a> 或者 <a href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\">godep</a>(<strong>已经停止更新，不建议使用</strong>)。 可以将依赖信息记载到配置文件，或者直接将依赖下载到项目根目录下面的 vendor 内。个人倾向于将依赖lib的源文件保存下来，作为项目的一部分。具体原因，如有必要我可以再开一篇文章细说。</p>\n<h2>常用的 lib（web service 开发），小知识</h2>\n<h3>web 框架，路由</h3>\n<ul>\n<li><a href=\"https://beego.me/\" target=\"_blank\" rel=\"noopener\">beego</a> 最全面，包含路由，orm，数据库事务等企业级功能，但同时也最庞大。如果你的应用足够下，可以考虑自己搭建一个小脚手架。</li>\n<li><a href=\"https://github.com/gorilla/mux\" target=\"_blank\" rel=\"noopener\">mux</a> 轻量级路由方案</li>\n</ul>\n<h3>yaml 文件解析</h3>\n<p>一篇介绍很全面的博文 <a href=\"http://sweetohm.net/article/go-yaml-parsers.en.html\" target=\"_blank\" rel=\"noopener\">A tour of YAML parsers for Go</a></p>\n<ul>\n<li><a href=\"https://github.com/kylelemons/go-gypsy\" target=\"_blank\" rel=\"noopener\">go-gypsy</a> 提供了很多 low level api，需要自己组织才能完全解析文件内容</li>\n<li><a href=\"https://github.com/go-yaml/yaml\" target=\"_blank\" rel=\"noopener\">yaml</a> 只能支持 flat map</li>\n</ul>\n"},{"title":"Golang 与 MongoDB：入门篇","catalog":true,"date":"2018-02-02T07:47:08.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/get-started-of-golang-with-mongodb.md","raw":"---\ntitle: Golang 与 MongoDB：入门篇\ncatalog: true\ndate: 2018-02-02 15:47:08\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"get-started-of-golang-with-mongodb","published":1,"updated":"2018-12-19T08:40:46.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6b9n5q000ccdx7qbakaprf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"译-构建微服务面临的挑战","catalog":true,"date":"2018-06-12T02:30:51.000Z","subtitle":null,"header-img":null,"_content":"原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","source":"_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices.md","raw":"---\ntitle: 译-构建微服务面临的挑战\ncatalog: true\ndate: 2018-06-12 10:30:51\nsubtitle: \nheader-img:\ntags: micro service\n---\n原文链接：[https://thenewstack.io/microservices-standardization-moving-monolith-microservices/](https://thenewstack.io/microservices-standardization-moving-monolith-microservices/)\n## 六个问题\n少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。\n\n上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，[Susan Fowler-Rigetti](https://www.linkedin.com/in/susan-fowler-263b6343/) 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。\n\n### 组织架构\n[康威法则](http://www.melconway.com/Home/Conways_Law.html) 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 -- 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。\n\n### 更容易出错\n![Alt text](29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n### 资源竞争\n对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。\n\n当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。\n\n### 对微服务的误解\n很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。\n\n另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。\n\n### 技术债务\n当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。\n\n### 缺乏信任\n微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。\n\n## 解决办法\n如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。\n### 需要标准化\n![Alt text](d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png \"optional title\")\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。\n\n上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。\n\n> 很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。\n\n其次，对于**生产环境可用性**达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。\n\n### production ready 的微服务架构\n* Stability\n* Reliability\n* Scalability\n* Performance\n* Fault-Tolerance\n* Catastrophe-Preparedness\n* Monitoring\n* Documentation\n\n### 稳定性和可靠性\n快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。\n\n任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 [development pipeline](http://www.thenewstack.io/tag/continuous-integration-and-deployment)。\n\n### 可扩展性和性能\n当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。\n\n可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。\n\n### 容错和灾难防护\n为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。\n\n强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。\n\n鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。\n\n### 监控\n系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是\"导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。\n\n### 文档\n大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。\n\n## 更多内容\n[Production-Ready Microservices](https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&ie=UTF8&qid=1487184502&sr=1-1&keywords=Production-Ready+Microservices)","slug":"translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices","published":1,"updated":"2018-12-19T08:40:46.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6b9n5s000dcdx7o7l9sjw2","content":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2><span id=\"六个问题\">六个问题</span></h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3><span id=\"组织架构\">组织架构</span></h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3><span id=\"更容易出错\">更容易出错</span></h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3><span id=\"资源竞争\">资源竞争</span></h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3><span id=\"对微服务的误解\">对微服务的误解</span></h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3><span id=\"技术债务\">技术债务</span></h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3><span id=\"缺乏信任\">缺乏信任</span></h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2><span id=\"解决办法\">解决办法</span></h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3><span id=\"需要标准化\">需要标准化</span></h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3><span id=\"production-ready-的微服务架构\">production ready 的微服务架构</span></h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3><span id=\"稳定性和可靠性\">稳定性和可靠性</span></h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3><span id=\"可扩展性和性能\">可扩展性和性能</span></h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3><span id=\"容错和灾难防护\">容错和灾难防护</span></h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3><span id=\"监控\">监控</span></h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3><span id=\"文档\">文档</span></h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2><span id=\"更多内容\">更多内容</span></h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"https://thenewstack.io/microservices-standardization-moving-monolith-microservices/\" target=\"_blank\" rel=\"noopener\">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p>\n<h2>六个问题</h2>\n<p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p>\n<p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href=\"https://www.linkedin.com/in/susan-fowler-263b6343/\" target=\"_blank\" rel=\"noopener\">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p>\n<h3>组织架构</h3>\n<p><a href=\"http://www.melconway.com/Home/Conways_Law.html\" target=\"_blank\" rel=\"noopener\">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>\n“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p>\n<h3>更容易出错</h3>\n<p><img src=\"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<h3>资源竞争</h3>\n<p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p>\n<p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p>\n<h3>对微服务的误解</h3>\n<p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p>\n<p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p>\n<h3>技术债务</h3>\n<p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p>\n<h3>缺乏信任</h3>\n<p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p>\n<h2>解决办法</h2>\n<p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>\n第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>\n第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p>\n<h3>需要标准化</h3>\n<p><img src=\"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png\" alt=\"Alt text\" title=\"optional title\"><br>\n系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p>\n<p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p>\n<blockquote>\n<p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p>\n</blockquote>\n<p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p>\n<h3>production ready 的微服务架构</h3>\n<ul>\n<li>Stability</li>\n<li>Reliability</li>\n<li>Scalability</li>\n<li>Performance</li>\n<li>Fault-Tolerance</li>\n<li>Catastrophe-Preparedness</li>\n<li>Monitoring</li>\n<li>Documentation</li>\n</ul>\n<h3>稳定性和可靠性</h3>\n<p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p>\n<p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href=\"http://www.thenewstack.io/tag/continuous-integration-and-deployment\" target=\"_blank\" rel=\"noopener\">development pipeline</a>。</p>\n<h3>可扩展性和性能</h3>\n<p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p>\n<p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p>\n<h3>容错和灾难防护</h3>\n<p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p>\n<p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p>\n<p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p>\n<h3>监控</h3>\n<p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p>\n<h3>文档</h3>\n<p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p>\n<h2>更多内容</h2>\n<p><a href=\"https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices\" target=\"_blank\" rel=\"noopener\">Production-Ready Microservices</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","slug":"29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png","post":"cjq6b9n5s000dcdx7o7l9sjw2","modified":0,"renderable":0},{"_id":"source/_posts/about-file-upload-1/home-bg-2-dark.png","slug":"home-bg-2-dark.png","post":"cjq6b9n4z0006cdx7wt76n5u6","modified":0,"renderable":0},{"_id":"source/_posts/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","slug":"d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png","post":"cjq6b9n5s000dcdx7o7l9sjw2","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjq6b9n3u0001cdx76u94ojx7","tag_id":"cjq6b9n4h0005cdx7euusrinn","_id":"cjq6b9n5p000bcdx77psqnhzq"},{"post_id":"cjq6b9n460003cdx7alxa53y0","tag_id":"cjq6b9n4h0005cdx7euusrinn","_id":"cjq6b9n5u000ecdx7t0jeezy8"},{"post_id":"cjq6b9n5s000dcdx7o7l9sjw2","tag_id":"cjq6b9n5v000fcdx74s4ue3mz","_id":"cjq6b9n69000gcdx7hjx43shu"},{"post_id":"cjq6b9n590008cdx7mbd2rc53","tag_id":"cjq6fwtzq0000l0x7mbn7e6bz","_id":"cjq6fwtzw0001l0x7l24orc4b"}],"Tag":[{"name":"gulp","_id":"cjq6b9n4h0005cdx7euusrinn"},{"name":"micro service","_id":"cjq6b9n5v000fcdx74s4ue3mz"},{"name":"ejs","_id":"cjq6fwtzq0000l0x7mbn7e6bz"}]}}