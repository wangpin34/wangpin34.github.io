<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花萼横江</title>
  <icon>https://www.gravatar.com/avatar/bdd8c2a3556a0ee449e8878e935824c3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wangpin.xyz/"/>
  <updated>2021-03-03T03:11:45.883Z</updated>
  <id>http://blog.wangpin.xyz/</id>
  
  <author>
    <name>王品</name>
    <email>dmoneh@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于闭包的更多思考</title>
    <link href="http://blog.wangpin.xyz/2019/12/23/think-more-about-cloure-javascript/"/>
    <id>http://blog.wangpin.xyz/2019/12/23/think-more-about-cloure-javascript/</id>
    <published>2019-12-23T22:21:30.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="同学请你讲一下闭包">同学，请你讲一下闭包</span></h1><p>我相信很多 javascript 工程师（泛指任何部分或者主要使用 javascript 完成日常开发任务的软件工程师）都会在面试的时候被问到 「闭包」，我也不例外。幸运的是，我很早就将准确的定义背的滚瓜烂熟，这并不能帮助我写出更好的代码，但能让我通过那些艰难的面试。在软件行业，死记硬背知识点并不是个好习惯，但有时候却依然有用。比如应付非专业面试官的提问。</p><p>先不要忙着嘲笑这些面试官的肤浅，确实，他们根本不知道闭包到底是什么，能做什么，只会对着标准答案判断应试者的水平。但有一点他们没有做错，或者说他们的团队没有做错，对于 javascript 开发，闭包的确是神兵利器，掌握的越早越好，越深刻越好。以我看来，每一个学习 javascript 的人都应该花费一定的时间学习它，直到融会贯通。</p><h1><span id="闭包是什么">闭包是什么？</span></h1><p>闭包的标准定义是：函数始终能够访问包含它的代码块所定义的变量，即便此代码块已经执行结束。简单的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = createCounter();</span><br><span class="line">counter();</span><br></pre></td></tr></table></figure><p>注：函数 counter 能够访问包含它的代码块 createCounter 定义的变量 count，即便后者已经执行结束。</p><p>上面的例子中，counter 函数始终能够访问并更新 count 变量，看起来，counter 似乎和 count 之间产生了一段看不见摸不着但却真是存在的关系。很多书里面对这种关系有很复杂很抽象的定义，本质意思是说，创建函数对象时也会顺便复制一份函数所关联的变量。在我看来，这体现了 javascript 聪明的一面：忠实的还原<strong>定义对象</strong>和<strong>使用对象</strong>两个不同阶段的环境。createCounter 是<strong>定义</strong>，counter 是<strong>执行</strong>，但是由于闭包的支持，定义 counter 时所拥有的物理条件（可访问可更新的 count 变量，初始值为 0），在执行时依然成立。</p><h1><span id="只是数据安全吗">只是数据安全吗？</span></h1><p>很多文章在谈论闭包时会反复提及数据私密（data privacy），这当然是闭包所提供给工程师们的好处。比如上面的例子中，count 存储计数器当前值，它可以且只可以被 counter 按照事先定义的方式修改，其他任何代码都不可能直接访问，更新，删除它。这无疑是非常强大的编程能力，能够实现难以计数的复杂商业逻辑。</p><p>很多编程语言如 Java 也能通过另外的方式达到相同的效果，但更复杂。你可能先得准备一个 class，定义 private 成员变量，定义 public 方法以更新此变量。然后初始化 class 的对象。你得学习前面所说的这些知识以便保证数据确实被妥善的保护起来。而 javascript 的语法元素更少，你只需要在函数中定义 count，然后返回另一个函数（counter）来更新它。结束。</p><p>数据安全是非常重要而且常见的，你一定会在各种应用程序中编写类似的逻辑以保证你的数据不会被「不怀好意」的其他代码所破坏，有些甚至是自己编写的代码。从这个角度来说，javascript 在这样的场合一定会极大的提高编程效率，因为可以用相比 Java 更少的代码量，语法元素（访问限制修饰符，类，成员变量和方法）来实现完全一样的功能。</p><p>以上的结论明显和现实有所出入，现实世界中，Java 依然在某些行业拥有绝对的地位，主要的原因并非因为技术，很多公司倾向于使用现有的技术方案完成工作，而不是事实上更好的新技术。因为这些公司的决策者所要考虑的并不是技术的领先性和绝对的高效率，而是其他可能更加复杂的东西。</p><p>回到语言本身，在数据安全之外，闭包所要表达的终极目标是什么？我在前一节已经有所提及：<strong>保证函数被定义和被执行时使用使用相同的环境</strong>。具体的说，就是外部变量。定义和执行当然是两个不同的阶段，在实际的项目中，这样的两个阶段甚至会处于不同的源文件，他们的物理环境当然是不同的。闭包却能在一定程度上保证逻辑环境是不变的。当我们在阅读这样的代码时，就不必总要切换上下文，以保证自己的想法是正确无误的，而闭包帮我们做到了了这一点：只要在定义时逻辑自洽，执行时自然也天衣无缝。</p><p>所以闭包的根本意义在于，<strong>使我们不必再刻意定义和执行阶段，以减轻思维负担</strong>，这是很有意义的。人类拥有无以伦比的创造力和思维能力，但只局限于专注某个具体问题时。如果没有闭包，我们就必须在每一处代码执行的地方思考这里的 count 到底存不存在，如果存在，指向的到底是谁。这无疑非常复杂，而且对于解决软件问题毫无帮助。</p><h1><span id="所以呢">所以呢</span></h1><p>前面我反复提到了<strong>环境</strong>，环境是定义阶段（也即是外部函数的执行阶段）创建的，也即是说，<strong>每一次的重新定义，都会新创建一份新环境</strong>，多个环境之间互不干扰。从理论上来说，它们甚至无法感知到彼此的存在。所以：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter1 = createCounter();</span><br><span class="line"><span class="keyword">var</span> counter2 = createCounter();</span><br></pre></td></tr></table></figure><p>counter1 和 counter2 所访问和更新的 count 是两份 count，互不影响。</p><p>我们甚至可以通过传入参数影响新创建环境，比如，准备一个初始值而不总是使用 count = 0。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span>(<span class="params">input = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = input;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用 javascript 我们不能在运行的时候改变已定义函数的逻辑，但是可以通过任何可能的方式改变闭包的运行环境，间接影响函数逻辑。这并不是很容易就能分析得到最优解法。你必须准确的找到数据和逻辑的结合点，将其分离。将逻辑部分交给内部语句，然后期待外部输入一个预期范围的数据以形成特定的业务环境。这一定是比通过业务和功能的不同分割代码更抽象的编程实践，也更能训练思维能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;同学请你讲一下闭包&quot;&gt;同学，请你讲一下闭包&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;我相信很多 javascript 工程师（泛指任何部分或者主要使用 javascript 完成日常开发任务的软件工程师）都会在面试的时候被问到
        
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.wangpin.xyz/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>32 岁了，规划接下来的生活</title>
    <link href="http://blog.wangpin.xyz/2019/07/21/32-%E5%B2%81%E4%BA%86%EF%BC%8C%E8%AE%A1%E5%88%92%E4%B8%80%E4%B8%8B%E6%9C%AA%E6%9D%A5/"/>
    <id>http://blog.wangpin.xyz/2019/07/21/32-岁了，计划一下未来/</id>
    <published>2019-07-21T16:38:24.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="写在前面">写在前面</span></h1><p>今年我32岁，有两个活泼可爱的孩子。我很希望能够多一点时间陪伴他们，但是很遗憾，工薪阶层朝九晚五是最低的负荷了。所以，只有在周末的时候，才能安排大块连续的时间陪他们玩东玩西，骑车，做游戏，唱歌。我希望能尽快换一种生活方式，不必这样死板的上下班，即便每周只要五天，每天只要8小时。但前提是，我能找到另一种赚钱的方式 - 不是随随便便的换一个工作，那只是换汤不换药。目前我也不知道除了写代码我还能做什么，所以，先做个计划吧。</p><h1><span id="短期-稳定自己的职业">短期 - 稳定自己的职业</span></h1><h2><span id="技术">技术</span></h2><p>目前还要靠技术谋生，所以，精进和扩展技术还是非常必要的。</p><h3><span id="cssjs">css/js</span></h3><p>2019 年开始恶补了 media query 和移动端适配的知识，重新学习了 flex 和 grid 布局。框架方面，学习实践了 styled-components。个人感悟：</p><ul><li>(充分优化的前提下）代码的<strong>简洁</strong>和<strong>自收敛</strong>往往是鱼和熊掌不可兼得，公司项目的话，还是推荐多写代码保证相关样式定制好（尽量不继承任何parent的样式）。</li><li>《css 权威指南》还要继续读下去，理解原理比懂得“回字的10中写法”更重要。</li><li>有很多场合 svg 是比 css 更好的方案，比如复杂的动画。</li></ul><p>js 方面，学习了一些 lib，按照权重从先到后排列。</p><ul><li>seamless-immutable： immutable 的最简单实现，react 开发必备技能</li><li>formik： 比 redux-form 更符合<strong>人类习惯</strong>的表单解决方案，上手有一些难度，要理解很多新概念。大幅度提高了表单开发的生产力。</li><li>smooth-ui：学习了它创建 component 的工具函数如 createComponent，很受启发。阅读优秀项目的源码确实是一种享受，前提是能读的懂。</li><li>threejs：webgl 半入门水平，持续学习中。</li></ul><h3><span id="react-性能调优">react 性能调优</span></h3><p>主要是对公司项目的优化。我做了什么呢？</p><ul><li>自己实现了 lazy load image 并应用到了项目中，首屏流畅了很多。</li><li>模仿 antd-mobile 实现了部分组件以接触项目对 antd 的依赖以及大量的魔改，比较有挑战性的是实现 slider，借此温习了 mouse 和 touch event。</li><li>用 hooks API 重写了所有的 class component，很多 300 + 行的文件被分割成更小的组件，更好维护了。</li></ul><h3><span id="其他">其他</span></h3><p>其他如 nodejs，客户端框架如 react-native，cordova，flutter，只是停留在会用的阶段，研究不够深。下半年的主要精力还是会放在 react 优化上。</p><p>公司的领导希望未来可以介入 AI，3d 等行业，并多次在公开会议上提及相关的技术名词。<strong>如果</strong>我还将继续工作的话，最好可以在至少一个方面，比如  AI（数据分析）这方面有所深入。</p><h2><span id="职场软实力">职场软实力</span></h2><p>对我来说主要是 <strong>沟通能力</strong> 和 <strong>英语</strong>。为什么将沟通能力排在前面？因为我首先是沟通比较有很大的问题：</p><ul><li>热衷于鸡蛋里挑骨头</li><li>容易情绪化<br>尤其是，如果和别人意见不一致，我容易陷入“强调结论” - “对方委婉反对” - “再次强调（伴随自己无法感知到的僵硬语气）” - “对方强烈反对” 这个恶性循环。我现在已经能比较好的控制情绪和节奏，但是骨子里的好斗基因依然会在某些<strong>关键对话</strong>某些场合让我蠢蠢欲动。持续的情绪控制训练还是非常必要的。</li></ul><p>当我情绪稳定的时候，英语表达还是足够应付日常交流的。但是，因为平时训练少，听力有时会突然掉线，就是怎么也听不懂别人说什么。没什么可说的，练。最近开始在 medium 上写英文 story，会坚持输出下去的。</p><h2><span id="健身">健身</span></h2><p>买了两个 5kg 的浸塑哑铃，开始做一些简单的力量练习，由易到难。身体外观上的改变微乎其微，手臂的力量倒是提升了不少，背部不适也开始减少最终消失了 - 看起来似乎是预防了某些身体劳损的产生。食量也同时变大算是一个副作用吧，很难避免，只能尽量的较少油脂的摄入 - 以我现在的条件，还很难安排一天三顿的健身餐。</p><p>至于什么时候开始跑步，为了保护膝盖，最好还是等到体重降到接近正常水平来再说。在这之前，还是以无氧力量为主。</p><h1><span id="长期-写作-发布-app-理财">长期 - 写作 / 发布 app / 理财</span></h1><p>我把长期目标设定为这三个的原因很简单：成本低。</p><h2><span id="写作">写作</span></h2><p>我其实很喜欢发表感想，但是转化成文章就不容易。原因很多，主要是我觉得文章就应该结构严谨，有条不紊，论证严密，总之一切向战国纵横家的作品看齐。这太过了，很多时候只需要忠实的记录下来所看所思即可，不用太纠结是否有价值 - 也许未来就有价值了呢？也许可以成为未来的某一篇很有价值的文章的引子呢？强求完美实在没有必要。</p><p>接下来，产量说话。</p><p>有了产量之后，我才能准确的判断，也有机会让读者们“一起判断”，作为一个作者，我擅长写什么。这个时代对于可以持续的输出内容的人，是给予了不少机会的。也许，这是我的下一份职业呢。</p><h2><span id="app-开发和理财">app 开发和理财</span></h2><p>这两个都是属于可以挣点小钱，但要挣大钱，难度也许比自己写东西还要高。但理由还是一样，成本低。app 开发我一个人就可以搞定。理财的话，先从基本的基金入手吧，股票2020年再开始看看，对，以看为主。</p><p><strong>为了维持一份体面，也为了对家人负责，我肯定还要坚持一段时间。但为了长久的未来，我必须现在就得开疆拓土了</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.wangpin.xyz/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>You need seamless-immutable to refactor your react app</title>
    <link href="http://blog.wangpin.xyz/2019/07/04/You-need-seamless-immutable-to-refactor-your-react-app/"/>
    <id>http://blog.wangpin.xyz/2019/07/04/You-need-seamless-immutable-to-refactor-your-react-app/</id>
    <published>2019-07-04T16:22:59.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="说明-you-are-free-to-go-to-next-section-if-english-is-not-the-problem">说明 (You are free to go to next section if English is not the problem)</span></h1><p><strong>本文首发于 Medium，作者最近在练习英文写作，身在职场，谋生之技，请见谅</strong>。<br>下面是简单的总结：<br>对于 react app 来说，inmutable 并不一定是必须的。如果你的 state 比较简单，而且在更新 state 时足够小心，你能避免本文开始列出的问题。但是，如果有一种使用简单的技术能够让你从这种小心的节奏中解脱出来，让你专注于处理其他更有价值的问题，不是更好吗？</p><h1><span id="why-you-need-it">Why you need it?</span></h1><p>There are two major reasons why you need to use seamless-immutable in your react application.</p><ol><li>It’s a bad practice to update props inside the component because it leads to much more problems than your thoughts(It will be a big topic but now it’s known to all so I think I don’t need to explain that, at least in this article). So, from the tech point of view, <strong>immutable</strong>  is better.</li><li>To save the effort of differing props, the pure component does only compare the references of each property in props, called <strong>shallowly compares</strong>. If the references are the same, the re-render not happen. In using object or array we must very carefully to re-generate a new copy of them if the data changed. That’s the reason why <strong>spread</strong> operator is introduced by <strong>redux</strong> and is highlighted.</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> SUCCESS:</span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, xxx &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Read more in <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">purecomponent</a></p><h2><span id="and-why-seamless-immutable">And why seamless-immutable?</span></h2><p><strong>seamless-immutable</strong> is a simple implementation of immutable. Less size of the bundle, less time you need to learn how to do mutation. And, the very great side is, you can visit the immutable data just like a primitive object/array. No more operators, grammar.</p><h1><span id="get-started">Get started</span></h1><h2><span id="how-to-create-the-immutable-copy-of-an-objectarray">How to create the immutable copy of an object/array?</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable(object)</span><br><span class="line">Immutable(array)</span><br></pre></td></tr></table></figure><h2><span id="how-to-create-the-mutable-copyfor-easy-modification-without-using-replacesetmerge-methods-of-an-immutable-data">How to create the mutable copy(for easy modification without using replace/set/merge methods) of an immutable data?</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable.asMutable(object)</span><br></pre></td></tr></table></figure><p>additional options:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable.asMutable(object, &#123; <span class="attr">deep</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>This will create a mutable copy for each property(or elements in an array). That means all properties will be new in the mutable copy(If deep = true then all nested property will be new generated as well).  And that will leads to a performance issue in the application which has huge and complicated data because that react component will be re-render although it’s not necessary.</p><p>The better idea is to only mutate the property when it’s necessary. For example, there is an address list:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addrs = Immutable([</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"wangpin"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"mona"</span>, <span class="attr">children</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;</span><br><span class="line">])</span><br><span class="line"><span class="keyword">var</span> newAddrs = Immutable.set(addrs, <span class="number">0</span>, Immutable.merge(addrs[<span class="number">0</span>], &#123; <span class="attr">name</span>: <span class="string">'remind'</span>&#125;))</span><br></pre></td></tr></table></figure><blockquote><p>Like somebody said, every coin has two sides: Use ‘asMutable’ is easy for usual modifications like what you did before involving the concept `immutable’, but it’s bad for performance(for the big app). Try to update the object carefully with the operators provided by immutable is hard a lot to beginners, but it’s good or required and much worth to do in a big app.</p></blockquote><h1><span id="so-lets-learn-how-to-update-it-as-little-as-possible">So let’s learn how to update it as little as possible</span></h1><p>They are <strong>merge</strong>, <strong>replace</strong>, <strong>set &amp; setIn</strong>, <strong>update &amp; updateIn</strong>, <strong>without</strong>.</p><ol><li>Only <strong>set &amp; setIn</strong> can be applied on both object and an array, others only work on an object.</li><li><strong>merge</strong>, <strong>replace</strong>, <strong>set &amp; setIn</strong> support additional parameters <strong>deep:true</strong> to perform a deep operation. Others don’t.</li></ol><p>ps. I will not introduced the method <strong>get</strong> and <strong>getIn</strong> since they are not about mutation.</p><h2><span id="merge">merge</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">status</span>: <span class="string">"good"</span>, <span class="attr">hypothesis</span>: <span class="string">"plausible"</span>, <span class="attr">errors</span>: <span class="number">0</span>&#125;);</span><br><span class="line">Immutable.merge(obj, &#123;<span class="attr">status</span>: <span class="string">"funky"</span>, <span class="attr">hypothesis</span>: <span class="string">"confirmed"</span>&#125;);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;status: "funky", hypothesis: "confirmed", errors: 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">status</span>: <span class="string">"bad"</span>, <span class="attr">errors</span>: <span class="number">37</span>&#125;);</span><br><span class="line">Immutable.merge(obj, [</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">"funky"</span>, <span class="attr">errors</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">status</span>: <span class="string">"groovy"</span>, <span class="attr">errors</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">status</span>: <span class="string">"sweet"</span>&#125;]);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;status: "sweet", errors: 2&#125;)</span></span><br><span class="line"><span class="comment">// because passing an Array is shorthand for</span></span><br><span class="line"><span class="comment">// invoking a separate merge for each object in turn.</span></span><br></pre></td></tr></table></figure><h2><span id="replace">replace</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = Immutable(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;, <span class="attr">c</span>: <span class="string">'test'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = Immutable.replace(obj1, &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;&#125;, &#123;<span class="attr">deep</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;a: &#123;b: 'test'&#125;&#125;);</span></span><br><span class="line">obj1 === obj2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">obj1.a === obj2.a</span><br><span class="line"><span class="comment">// returns true because child .a objects were identical</span></span><br></pre></td></tr></table></figure><h2><span id="set-amp-setin">set &amp; setIn</span></h2><p><strong>Only set &amp; setIn can be applied on an array</strong>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">type</span>: <span class="string">"parrot"</span>, <span class="attr">subtype</span>: <span class="string">"Norwegian Blue"</span>, <span class="attr">status</span>: <span class="string">"alive"</span>&#125;);</span><br><span class="line">Immutable.set(obj, <span class="string">"status"</span>, <span class="string">"dead"</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;type: "parrot", subtype: "Norwegian Blue", status: "dead"&#125;)</span></span><br></pre></td></tr></table></figure><p>When called with an Immutable Array, the property parameter is the index to be changed:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array = Immutable([&quot;hello&quot;, &quot;world&quot;]);</span><br><span class="line">var mutatedArray = Immutable.set(array, 1, &quot;you&quot;);</span><br><span class="line"></span><br><span class="line">mutatedArray // [&quot;hello&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure><p>Like set, but accepts a nested path to the property.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">type</span>: &#123;<span class="attr">main</span>: <span class="string">"parrot"</span>, <span class="attr">sub</span>: <span class="string">"Norwegian Blue"</span>&#125;, <span class="attr">status</span>: <span class="string">"alive"</span>&#125;);</span><br><span class="line">Immutable.setIn(obj, [<span class="string">"type"</span>, <span class="string">"sub"</span>], <span class="string">"Norwegian Ridgeback"</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;type: &#123;main: "parrot", sub: "Norwegian Ridgeback"&#125;, status: "alive"&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = Immutable([[<span class="string">"one fish"</span>, <span class="string">"two fish"</span>], [<span class="string">"red fish"</span>, <span class="string">"blue fish"</span>]]);</span><br><span class="line"><span class="keyword">var</span> mutatedArray = Immutable.setIn(array, [<span class="number">1</span>, <span class="number">1</span>], <span class="string">"green fish"</span>);</span><br><span class="line"></span><br><span class="line">mutatedArray <span class="comment">// [["one fish", "two fish"], ["red fish", "green fish"]]</span></span><br></pre></td></tr></table></figure><h2><span id="update-amp-updatein">update &amp; updateIn</span></h2><p>Returns an Immutable Object with a single property updated using the provided updater function.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inc</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br><span class="line">Immutable.update(obj, <span class="string">"foo"</span>, inc);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: 2&#125;)</span></span><br></pre></td></tr></table></figure><p>All additional arguments will be passed to the updater function.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br><span class="line">Immutable.update(obj, <span class="string">"foo"</span>, add, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: 11&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>updateIn</strong> like <strong>setIn</strong> that it accetps a nested path to be property.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line">Immutable.updateIn(obj, [<span class="string">"foo"</span>, <span class="string">"bar"</span>], add, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: &#123;bar: 11&#125;&#125;)</span></span><br></pre></td></tr></table></figure><h2><span id="without">without</span></h2><p>Returns an Immutable Object excluding the given keys or keys/values satisfying the given predicate from the existing object.</p><p>Multiple keys can be provided, either in an Array or as extra arguments.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, &quot;with&quot;);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, [&quot;will&quot;, &quot;with&quot;]);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, &quot;will&quot;, &quot;with&quot;);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, (value, key) =&gt; key === &quot;the&quot; || value === &quot;echo&quot;);</span><br><span class="line">// returns Immutable(&#123;with: &quot;laughter&quot;&#125;)</span><br></pre></td></tr></table></figure><h1><span id="summary-of-seamless-immutable">Summary of seamless-immutable</span></h1><ol><li><strong>asMutable</strong> is the easiest way to perform modification, but it harms performance sometimes.</li><li>All methods for mutating object/array returns a new immutable copy. If you have to perform more than one mutation on the data,  please make sure every mutation works on the newer copy.</li></ol><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">const original = Immutable(xxx)</span><br><span class="line">const <span class="keyword">new</span><span class="type">er1</span> = Immutable.replace(original, xxx)</span><br><span class="line">const <span class="keyword">new</span><span class="type">er2</span> = Immutable.replace(<span class="keyword">new</span><span class="type">er1</span>, xxx)</span><br></pre></td></tr></table></figure><p>Thanks for your reading.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;说明-you-are-free-to-go-to-next-section-if-english-is-not-the-problem&quot;&gt;说明 (You are free to go to next section if English is not
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不再为折腾环境变量而哭泣</title>
    <link href="http://blog.wangpin.xyz/2019/05/27/configure-env-variables-without-tears/"/>
    <id>http://blog.wangpin.xyz/2019/05/27/configure-env-variables-without-tears/</id>
    <published>2019-05-27T16:25:07.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<p>create-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：</p><ul><li>.env ： 默认变量</li><li>.env.development: 开发环境变量</li><li>.env.production: 线上环境变量</li></ul><p>上面的结构很适合只需要区分开发环境和线上环境的业务场景，也只能适用于这种场景。而实际的情况可能更加复杂，比如，我现在所负责的项目，线上环境就有四个，分别是 dev/qa/stg/prod（称为 stack）。cra 提供的方法完全不够用。事实上，create-react-app 在 github 上的 issue 中就有讨论过相关的 topic，当然，目前还没有定论。否则，我也不会在折腾半天无果后，只能自己造轮子，然后写下这篇造后感。</p><h2><span id="idea-of-spring">idea of spring</span></h2><p><strong>遇到前端工程问题，不妨看看后端有什么现成的解法</strong>。刚好我用过 spring，它引入一种概念叫做 profile，一个 sprint app 可以包含多个 profile，每个 profile 是一份配置文件。可以在主配置文件中设置当前启用哪个 profile。比如，对于我们的项目，可以配置 dev/qa/stg/prod 四个 profile。实际应用中，spring app 从环境变量中读取当前启用的 profile 的名字。比如，虚拟机中设置一个环境变量 profile=dev，则 dev profile 被启用。</p><h2><span id="cra-能做什么">cra 能做什么</span></h2><p>看完 spring 的 idea，来分析下 create-react-app 的现状。</p><ol><li>cra 预置 NODE_ENV 作为环境变量，当运行 start 命令时，值为 development，当运行 build 时，值为 production。但我们要区分 4 个线上环境，所以，无用。</li><li>cra 设置了复杂的配置文件优先级策略，详见官网，结论依然是无用。我个人倾向于简洁直白，每个环境需要的变量最好全部写清楚，不需要<strong>继承</strong>或者<strong>组合</strong>。</li></ol><p>所以，cra本身的高级机制我们统统不用，只需要知道 cra 会读取 .env 文件，无论是 development 还是 production。</p><h2><span id="模仿-spring">模仿 spring</span></h2><p>先准备好四个 profile 文件：</p><ul><li>.env.dev</li><li>.env.qa</li><li>.env.stg</li><li>.env.prod<br>.env.dev 中内容，其他 profile 结构类似：</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">api_path: http://api.dev.com</span><br></pre></td></tr></table></figure><p>然后，根据环境变量 profile 切换 .env，即动态生成 .env 文件。</p><p>env.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> ini = <span class="built_in">require</span>(<span class="string">'ini'</span>)</span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">'dotenv'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.profile) &#123;</span><br><span class="line">    <span class="keyword">return</span> dotenv.config(&#123; <span class="attr">path</span>: path.join(__dirname, <span class="string">'..'</span>, <span class="string">`.env.<span class="subst">$&#123;process.env.profile&#125;</span>`</span>) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dotenv.config()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = load()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.error) &#123;</span><br><span class="line">  <span class="keyword">throw</span> result.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result.parsed)</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(<span class="string">'./.env'</span>, ini.stringify(result.parsed))</span><br></pre></td></tr></table></figure><p>修改 package.json 中 start 和 build 命令：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"start": "profile=dev node env.js &amp;&amp; react-scripts start",</span><br><span class="line">"build": "node env.js &amp;&amp; react-scripts build",</span><br></pre></td></tr></table></figure><p>可以看到我为本地开发配置的 profile 是 dev。production 上所用的 profile 以构建系统（jenkins虚拟机）所提供的 profile 为准。</p><h2><span id="可以提升的点">可以提升的点。</span></h2><p>未来，如果有时间的话，还可以做一些提升。</p><p>相对容易的，在 build 结束后删除 .env 文件。简单的做法是, build 完成后再调用删除命令。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"build": "node env.js &amp;&amp; react-scripts build &amp;&amp; node env.js cleanup",</span><br></pre></td></tr></table></figure><p>复杂一点的，完全弃用 .env 文件，通过子进程来调用 build 脚本，同时设置环境变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'api_path=xxx react-scripts build'</span>)</span><br></pre></td></tr></table></figure><h2><span id="总结和感想">总结和感想</span></h2><p>cra 官方只提供了区分开发和线上的环境变量管理办法，其实一开始就已经表明了他们绝对无法支持多线上环境这个现实，但是我还是愚蠢的尝试了几个小时，试图从多种配置文件的组合中寻找一种可以利用的模式，现在看起来这注定是要失败的。</p><p>我现在所“发明”的这种方式，其实就是简单的改变了思路：既然 cra 不支持多 profile，那我利用外部脚本按需生成 env 文件然后提供给 cra 不是一样解决问题吗？当然，到底要利用 lib 本身还是外部服务（脚本，其他lib）来解决问题，要综合考虑时间成本，可靠性。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;create-react-app 提供了丰富的配置环境变量的方式，比如，可以创建 .env, .env.development, .env.production 三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.env ：
        
      
    
    </summary>
    
    
      <category term="create-react-app" scheme="http://blog.wangpin.xyz/tags/create-react-app/"/>
    
  </entry>
  
  <entry>
    <title>react context 入门</title>
    <link href="http://blog.wangpin.xyz/2019/05/08/react-context-%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.wangpin.xyz/2019/05/08/react-context-入门/</id>
    <published>2019-05-08T16:03:24.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="why">Why？</span></h1><p>通过 props 将数据层层传递<strong>下去</strong>是最常见的方式，也是最简单的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 child 层次太深，props 传递会非常啰嗦。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Parent1 data=&#123;data&#125;/&gt;</span><br><span class="line">&lt;Parent2 data=&#123;data&#125;/&gt;</span><br><span class="line">&lt;Parent3 data=&#123;data&#125;/&gt;</span><br><span class="line">&lt;Child data=&#123;data&#125;/&gt;</span><br></pre></td></tr></table></figure><p>或者换一种思路，让 child 自己访问数据 - 这就是 context：在 context 中存储一些任何 child 都有可能访问的数据，然后在 component 中访问 context 对应的数据（也可以修改）。context 不那么常用，但很有必要掌握。</p><blockquote><p>通常，你可以采用 redux 来解决上述问题（redux 也是构建于 context 之上的），如果你并不熟悉 redux 或者由于任何原因不想采用 redux 作为数据管理方案，可以使用本文介绍的 context 。</p></blockquote><h1><span id="get-started">Get started</span></h1><p>context 包含下面几个核心概念。</p><ol><li>createContext</li><li>assign context</li><li>provider</li><li>consumer</li></ol><p>分别说明：</p><h2><span id="createcontext">createContext</span></h2><p>顾名思义，创建一个 context:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure><p>默认值可以给也可以不给。</p><h2><span id="assign-context">Assign context</span></h2><p>新创建的 context 是独立存在的，如果要在 component 里面访问 context，需要先建立联系。方式有两种，这里先说第一种 assign context。顾名思义，就是直接将 context 分配给某个 component。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.contextType = MyContext;</span></span><br></pre></td></tr></table></figure><p>也可以使用 public class fields syntax, 这样写：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  static contextType = <span class="type">MyContext</span>.</span><br><span class="line">  render () &#123;</span><br><span class="line">    let value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;value&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="provider-和-consumer">Provider 和 Consumer</span></h2><p>Provider 用于配置初始数据，Consumer 用于<strong>按需订阅</strong> context。</p><h3><span id="配置-provider">配置 Provider</span></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/**/</span>&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，此处 value 是必须提供的。</p><h3><span id="按需订阅">按需订阅</span></h3><p>在 component 内部通过对应的 Consumer 获取 value。这里完全可以根据具体业务决定是否访问 context，比 assign context 更灵活可控。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; (</span><br><span class="line">           &lt;div&gt;&#123;value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">         ) </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &lt;MyContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="defaultvalue">defaultValue</span></h2><p>你可能会注意到一旦使用 Provider &amp; Context， value 是必须提供的，所以 defaultValue 不会起作用。因此，defaultValue 只能在使用第一种办法 Assign Context 时生效。一般 defaultValue 可以忽略。</p><h2><span id="更新-value">更新 value</span></h2><p>常见的做法是将 value 存储为 root component 的 state 或者子属性，然后更新对应数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">context</span>: &#123;&#125; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleConextChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// change state here</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;Provider value=&#123;<span class="keyword">this</span>.state.context&#125;&gt;</span><br><span class="line">      &lt;App handleContextChange=&#123;<span class="keyword">this</span>.handleConextChange&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>context value 不必一定是 plain object，也可以包含 function，这样的好处是可以直接将操作 context 的通过 context 的方式传递给 child component，但我不推荐这种写法。</p><h1><span id="usecontext-hooks">UseContext Hooks</span></h1><p>React 16.8.x 发布了一系列 hooks api，旨在改变以往 class component 的诸多问题（开发和运行效率，可阅读性）。如果你喜欢 hooks，那也可以尝试下 useContext。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">value</span> = useContext(MyContext)</span><br></pre></td></tr></table></figure><p>useContext 等价于上面介绍的 assign context。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;why&quot;&gt;Why？&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;通过 props 将数据层层传递&lt;strong&gt;下去&lt;/strong&gt;是最常见的方式，也是最简单的。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Restful API 设计的三点经验之谈</title>
    <link href="http://blog.wangpin.xyz/2019/01/23/three-points-of-restful-api-design/"/>
    <id>http://blog.wangpin.xyz/2019/01/23/three-points-of-restful-api-design/</id>
    <published>2019-01-23T17:29:03.000Z</published>
    <updated>2021-03-03T03:11:45.855Z</updated>
    
    <content type="html"><![CDATA[<p>2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。</p><h2><span id="status-code">Status code</span></h2><p>基本的 code 原则很简单，2xx 表示成功，4xx 表示客户端错误，5xx 表示服务端错误。</p><p>那如何分辨是客户端还是服务端错误呢？我总结了以下几种常见的客户端错误，以及对应的错误码。</p><ul><li>401 - 未授权的访问比如访问资源需要 token 鉴权，如果不携带 token 或者 token 已过期，则返回 401.</li><li>403 - forbidden，禁止访问。比如某些资源只允许管理员访问，非管理员则返回 403。</li><li>404 - not found，不存在。</li></ul><p>总之，凡是客户的锅，都返回 4xx 。如果恰好不在上面所列的三种情况中，则用 400 代替。</p><p>服务端自身错误则包含两类情况：</p><ul><li>io 错误，比如读写文件，访问数据库</li><li>自身逻辑错误，比如内存泄漏。</li></ul><p>第一种错误是不可避免的，属于不可控的外部环境问题。第二种错误虽然可以通过 review 代码加上各种测试来预防，但<strong>最好</strong>有个兜底的错误处理以免程序挂掉。</p><p>我司对于服务端错误统一返回 500（internal server error），因为考虑到服务端错误对于客户来讲毫无建设意义，毕竟客户绝对没有办法帮助我们解决错误。即使对于工程师来说，日志也比 code 更有表现力。相对而言，客户端错误则尽量设计的详细因为大部分情况下客户端要据此来引导用户回到正常的业务中来。比如，如果返回 401，则引导用户登陆或者注册。如果业务比较复杂，还要考虑扩展 reponse 来指明更加具体的错误。如：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">400</span> <span class="keyword">bad </span>request</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"Name is required"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="list-api">List API</span></h2><p>GET /orders</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"offset"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">"limit"</span>: <span class="number">20</span>,</span><br><span class="line"> <span class="string">"count"</span>: <span class="number">100</span>,</span><br><span class="line"> <span class="string">"elements"</span>: <span class="string">[...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个 List API，如果资源不存在，返回应该是什么。受 404 概念的普及影响，很多人会选择返回</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">404 </span>NotFound</span><br></pre></td></tr></table></figure><p>难道说，如果不存在 orders（订单） 就是错误吗？比如我从来没有在淘宝下过单，那订单列表也就应该显示客户端错误吗？这显然是不对的。实际上，404 是指所请求的资源不存在。而对于 orders 来说，它是一个集合概念。不管下没下过单，这个集合总归是存在的。按照这个理论，正确的返回应该是：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"offset"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">"limit"</span>: <span class="number">20</span>,</span><br><span class="line"> <span class="string">"count"</span>: <span class="number">100</span>,</span><br><span class="line"> <span class="string">"elements"</span>: [] <span class="comment">// 空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以对于 List API 来说，没有 404。</p><h2><span id="parent-resource">Parent resource</span></h2><p>restful API 的路径可以表现资源的从属关系。比如，用户可以有多个地址。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/users/</span>&#123;user_id&#125;<span class="regexp">/addresses/</span></span><br></pre></td></tr></table></figure><p>那么，对于一个并不存在的用户而言，访问上述 API，应该返回什么？</p><p>用户不存在，他的地址也必然不存在，那似乎是个简单的客户端错误。但我们确实有必要参考 Parent resource 的状态吗？这从理论上讲似乎毫无破绽，但实际操作及其困难。假如 Parent resource 的状态为 s1, Child resource 的状态为 s2，如果必须参考 s1 才能定义 s2，则 Child resource 的状态为 s1 * s2。这还是简单的层次，如果 Parent 之上还有 Parent，则最终 Child 的状态会变成 s0 * s1 * s2。如果随着业务的升级，每个节点的状态推算都要这样越来越复杂，那结果必然是整个系统的崩塌。</p><p>所以，目前比较推崇的做法是，仅仅考虑目标资源或者资源集合的状态。即，addresses，不管它从属于谁。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;2015年冬天，我写下第一篇也是目前唯一一篇关于 Restful API 设计的文章。时间过的飞快，转眼三年前过去了。这三年间经历过的项目中，后台逐渐微服务化，restful 也成为大家耳熟能详的设计方案。这里记下些自己的经验和教训，以供对照。&lt;/p&gt;
&lt;h2&gt;&lt;span
        
      
    
    </summary>
    
    
      <category term="restful-api" scheme="http://blog.wangpin.xyz/tags/restful-api/"/>
    
  </entry>
  
  <entry>
    <title>tiny url - 相见恨晚</title>
    <link href="http://blog.wangpin.xyz/2019/01/11/start-to-use-tinyurl/"/>
    <id>http://blog.wangpin.xyz/2019/01/11/start-to-use-tinyurl/</id>
    <published>2019-01-11T14:30:54.000Z</published>
    <updated>2021-03-03T03:11:45.851Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="楔子">楔子</span></h1><p>刚开始做 <strong>scrum master</strong> 的时候，经常要发邮件广播 <strong>user story</strong> 的实施情况。我司使用 jira 来管理这些 user store。jira 提供了丰富的 <strong>search query</strong> 来搜索指定的内容。通常，我会将这些 <strong>user store</strong> 的 <strong>search query</strong> 包含在文件中，以便别人参考。但这个链接往往过长，非常不容易拷贝（虽然大部分使用者都是点击邮件中的链接浏览器自动打开相应页面），也非常影响整个邮件的排版。所以，通常我都会手动编辑这个链接的 <strong>display text</strong>，将原本默认展示的链接内容改成一个较短的名字。但这样一来，又不利于别人拷贝然后直接转发。</p><p>我的同事 Phoenix 是非常专业的 scrum 实践者，同时，也非常精通 jira。她告诉我，可以创建对应的 filter 来保存 query，然后只需要告知别人 filter 的链接或者名字就可以了。这个链接相对较短。我尝试了一下，很好用。但是，很多情况下我只是想临时分享一个长 url，也需要创建一个 filter。懒人思维作祟，我一定要知道另一个更加简便的办法，比如，输入长 url 自动转化为短 url，访问短 url 又能自动跳转到长 url。</p><p>这就是 <strong>tiny url</strong>。</p><h1><span id="tiny-url">tiny url</span></h1><p><strong>tiny url</strong> 并不是我自己创造的，而且它也并不是一个新概念 - 早在 2002 年已经问世了。想想早在 17 年前就有前辈发现问题并提出了应对办法，不得不说，十分敬佩。</p><p>这是 <a href="https://tinyurl.com/" target="_blank" rel="noopener">tiny url 官网</a>，以及首页简介。</p><blockquote><p>Are you sick of posting URLs in emails only to have it break when sent causing the recipient to have to cut and paste it back together? Then you’ve come to the right place. By entering in a URL in the text field below, we will create a tiny URL that will not break in email postings and never expires.</p></blockquote><p>tiny url 提出的理念（长 url 转化为短 url）影响了很多人，数以千计的 tiny url（或者称为 url shorter）应运而生。有面向后台 service 提供解决方案的，如 <a href="https://developers.rebrandly.com/" target="_blank" rel="noopener">rebrandly</a>，有面向 app 提供本地支持的，如我正在使用的一个 chrome 扩展 <a href="https://chrome.google.com/webstore/detail/tinyurl/lbadmllalinlpflkajgkkmjohckpnahm?hl=en" target="_blank" rel="noopener">tinyurl</a>。如果我想要将当前正在浏览的网页地址分享给别人，只需要点击它，就能立刻生成一个短 url。</p><p><img src="chrome-extension-tinyurl.jpg" alt="chrome-extension-tinyurl.jpg"></p><h1><span id="应用场景">应用场景</span></h1><ol><li>使用二维码来分享 url，如果 url 长度超过二维码可存储的数据长度，使用 <strong>tiny url</strong> 是个不错的办法。</li><li>在某通讯工具中其假想敌的产品链接。<a href="https://www.zhihu.com/question/37871221" target="_blank" rel="noopener">知乎上有过类似讨论</a>。</li></ol><h1><span id="tiny-product">tiny product</span></h1><p>tiny url 想做的事情很小，小的都没法写 ppt 去骗钱，但它依然有自己的价值 - 因为它确实解决了问题，虽然小，但帮助很多用户。比如对于我来说，简短的 url 看起来更加专业而精巧，所以邮件看起来也更加清爽。所以这就是所谓 tiny product 的价值。<strong>不求大而全，只要能在某个垂直领域做好，也能有自己的立足之地</strong>。这个规则可能不太适用于大投资的产品，毕竟他们普遍有盈利和上市的压力，但对于个人产品来说，能做到这份上，也算是不错的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;楔子&quot;&gt;楔子&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;刚开始做 &lt;strong&gt;scrum master&lt;/strong&gt; 的时候，经常要发邮件广播 &lt;strong&gt;user story&lt;/strong&gt; 的实施情况。我司使用 jira 来管理这些 user
        
      
    
    </summary>
    
    
      <category term="tiny-url" scheme="http://blog.wangpin.xyz/tags/tiny-url/"/>
    
      <category term="url-shortener" scheme="http://blog.wangpin.xyz/tags/url-shortener/"/>
    
  </entry>
  
  <entry>
    <title>震惊，web 应用不能做的 N 件事</title>
    <link href="http://blog.wangpin.xyz/2019/01/08/what-web-cannot-do/"/>
    <id>http://blog.wangpin.xyz/2019/01/08/what-web-cannot-do/</id>
    <published>2019-01-08T16:45:37.000Z</published>
    <updated>2021-03-03T03:11:45.847Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="web-应用的优势">web 应用的优势</span></h1><p>我理解的<strong>web 应用</strong>其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如 20 世纪初涌现的各大门户网站。而<strong>web 应用</strong> 则大多以丰富细腻的交互设计闻名，比如著名的 Gmail。虽然载体依然是浏览器，但使用方式更贴近传统意义上的用户软件，即原生应用。</p><p><strong>原生应用</strong>一定是和某种操作平台严格绑定的软件，最直观的，它一定会使用目标平台支持的语言和框架进行开发，比如 win 平台的 c#，ios 的 object c &amp; swift， android 的 java &amp; kotlin，使用特定平台提供的 sdk 以访问物理数据。并且要编译打包为目标平台支持的软件格式，有时甚至要严格到某个版本的平台，才能正常运行。发布渠道一般也会掌握在平台所有者手中。</p><p>说到 web 应用的优势，一般都要历数 原生应用 的各种「罪状」，如安装麻烦，兼容性差，升级不便。似乎 web 应用的诞生就是以取代 原生应用 为目标的。</p><p>不相信吗？那我们一个一个说。</p><h2><span id="无需安装">无需安装</span></h2><p>使用原生应用必须先下载安装。熟知的微信，支付宝，office，乃至各类大小型游戏，想要使用它们，必须经历枯燥的下载 -&gt; 安装，当然中间过程比我们肉眼所见更为复杂。更别提寻找可靠的安装文件所要花费的精力。如果不小心安装了流氓软件，后续的卸载清理也是不小的工程。</p><p>web 应用完全不需要这么麻烦。你需要的时候，只需要打开任何一个浏览器，输入地址或者打开收藏夹找到对应的链接，就可以开始使用了。不需要了，关掉对应的标签或者窗口。理论上讲，在别的电脑上使用这些 web 应用也是一样的容易。你不必像使用 原生应用 一样反复的安装。</p><p>随着浏览器功能的增强和丰富，web 应用开始蚕食原生应用的领地。图像处理，文本编辑，web 应用在这些方面汇集了双方的优势，变得越来越不可忽视。以我为例，平时开发软件中经常使用的工具，大部分已经 web 化了，比如大量的在线编程环境 repl，codesandbox，codepen。</p><h2><span id="无缝更新">无缝更新</span></h2><p>上面说 web 应用无需安装，从技术上来讲，这是不准确的。web 应用也有代码，资源文件，在实际运行之前，也需要等待这些文件下载完成。只不过相比于 原生应用 庞大的安装包来说，web 应用所依赖的「安装包」，从体积上来说，足够轻量。这是因为，原生应用 需要很多额外的 sdk/lib 来提供必要的支持，而浏览器本身已经准备好了「足够」的支持。web 应用运行于浏览器之上，自不需要再像 原生应用 一样「自力更生」。</p><p>浏览器之于 web 应用，就像操作系统+sdk 之于原生应用。</p><p>从这里看，web 应用并非不需要更新，而是它的更新太简单了 - 服务器端部署新代码，客户浏览器打开 web 应用下载到新代码所赋予的更新。搭配上合理的缓存机制，web 应用的十分安静，所谓「无缝更新」。而原生应用必须要下载一个相对较大的安装包，来取代已经安装的应用。这个过程牵涉到系统的权限，存储，所以并不「安静」。所以，web 应用频繁的更新并不稀奇，原生应用 则应该尽量避免太频繁的更新，因为过度打扰用户不是好事。</p><h2><span id="跨平台">跨平台</span></h2><p>我们已经知道 web 应用运行于浏览器（或者浏览器环境）之上，所以 web 应用的跨平台指的并不是跨操作系统平台，而是跨浏览器。早期并不存在跨浏览器这个说法，事实上那个年代也不需要，因为 web 应用还未诞生。直到 js 成为浏览器事实上的编程语言，跨浏览器才成为一个需要去解决的难题。我们看到现在跨浏览器并不是什么值得大说特说的价值，因为这个难题已经几乎解决了。怎么解决的呢？一般我说到这里的时候要列出三个阶段。</p><p>1 蛮荒时代<br>web 早期，浏览器环境差异极大，比较出名的是 event binder 上的差异。js 语言天生的灵活性在处理这种差异的时候得心应手，并且足够简单直接。这是 web 的蛮荒时代，也是百花齐放的时代。我曾经就收集了很多这样的代码片段，文件，即便是现在看起来，也会被前辈们的聪明才智所深深折服。<br>2 jquery<br>jquery 最杀手级的功能，是它完全复刻了 css selector。早期的 js 搜索 dom 的 api 相当简陋，尤其是不能按照层级关系搜索 dom（而有一定经验的 css writer 一定会大量的使用后代或者兄弟 selector）。jquery selector 填补了这片空白，而且做的很棒。初次之外，jquery 优秀的 api 设计，效率，都深刻的影响着后来者，和它的追随者。比如我以前写 lib 就不由自主的模仿 jquery 导出 instance 的方式。<br>3 殊途同归<br>时至今日，jquery 已经不再是舞台上的 super star。一方面是因为强调交互的 web 应用迫切的需要高开发效率的 mvvm 支持，另一方面，是浏览器们越来越同质化，已经不需要 jquery 夹在中间做 middle ware。现在，大部分时候，你都不需要在花太多的心思处理浏览器差异，写复杂的 dom selecter，原生 js 完全够用了。</p><hr><p>所以，web 应用的跨平台不是大风刮来的，也不是一蹴而就的。</p><p>但是，web 应用和 原生应用 跨平台的难度确实是不同的，这显而易见。这就是浏览器作为中间承担跨平台底层工作，而向上提供「比较」跨平台的接口。这和 java 虚拟机的跨平台方式有相似之处。</p><h1><span id="优势的另一面">优势的另一面</span></h1><p>换一个角度，优势就变成劣势了。还是一个一个来。</p><h2><span id="不能离线使用">不能离线使用</span></h2><p>浏览器并不提供文件存储功能，所以，web 应用想要模仿 原生应用 做到安装之后离线使用，是不可能的（PWA 是个好东西）。浏览器就像一个传统的电视机，你要看电视，转到对应的频道就可以。看到不错的节目想保存下来以后看，对不起，人家做不到。</p><h2><span id="不能访问本地资源">不能访问本地资源</span></h2><p>原生应用 可以依托系统资源完成功能，比如更好看的系统相册，文本阅读器，通过摄像头，麦克风录入信息（比如淘宝，京东的拍物搜索，声音搜索）。web 应用受限于浏览器的安全设置，只能卡在外面看风景。</p><h2><span id="js-的黑暗面">js 的黑暗面</span></h2><p>前端之所以入门简单，就在 js 的异步模型。写过 java swing，甚至 android 都知道使用多个线程处理事件的繁琐和难以调试，但又不得不用否则 app 就无法正常工作。而写 web 应用则完全不需要考虑多线程，你只需要这样那样拼好项目，不管是 listen 用户指令，还是后台相应，都不担心互相影响。当然，前提是每段代码都足够快速。</p><p>但有些情况下，代码运行速度会变慢，比如复杂的数据计算。js 在运行的时候浏览器，GUI 渲染线程和事件触发线程不工作，所以如果 js 长事件运行，web 应用就会变得卡顿。所以如果必须执行这样的代码，请务必了解以下 web workers。它会启动几个后台线程来运行 js。</p><p>而且，js 本身的效率也并不优秀，这方面可以期望的方案是 <a href="https://webassembly.org/" target="_blank" rel="noopener">web assembly</a>，通过将 c++ 代码的编译结果加载到浏览器以提供更优秀的执行效率。js 在图形图像上的尴尬兴许也可以寄希望于 web assembly 的「超能力」。</p><h2><span id="安全性">安全性</span></h2><p>web 应用的开放特性使得被「别有用心」的坏人利用或者伤害的门槛极低。很多黑客将矛头对准了漏洞百出的 web 应用，而受到威胁的 web 应用的所有者们也开始武装自己。攻防双方持久对峙的结果是，一系列的安全策略，规范，被发明和广泛的利用起来，双方的内部损耗也相应变多。</p><h1><span id="现实和未来">现实和未来</span></h1><p>现实中， web 和 原生应用 两者并非竞争关系，更像是相互协助的好基友。有时两者分别承担不同的业务时期，比如 web 应用负责前期的宣传，比较消耗性能或者必须利用系统资源而不得不采用原生应用的时候，由 web 应用引导用户安装原生应用。有时 web 应用化为原生应用的一部分存在（webview），负责完成复杂且变动频繁的界面交互（hybird app）。</p><p>另外一个值得注意的是 web 应用 native 化方案。目前主流的有 react-native，electron（其他概念类似的都不列举了）。可以看出行业的发展目标依旧是梦想着可以结合 web 应用和原生应用的各自优势。特别是，在人工成本居高不下，而 AI 自动开发还遥不可期的时代，仅仅是「一次编写多平台运行」这个跨平台特性，就使得 web 应用 成为一股不可忽视的声音。而只要可以跨平台而开发效率不难看，大部分人还是不怎么在乎是不是用 web 三件套的（html/css/js），比如最近火的一塌糊涂的 flutter。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;web-应用的优势&quot;&gt;web 应用的优势&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;我理解的&lt;strong&gt;web 应用&lt;/strong&gt;其实就是网站的一种新形式。传统的网站通常以内容为主，交互为辅，比如 20 世纪初涌现的各大门户网站。而&lt;strong&gt;web
        
      
    
    </summary>
    
    
      <category term="web 应用" scheme="http://blog.wangpin.xyz/tags/web-%E5%BA%94%E7%94%A8/"/>
    
      <category term="pwa" scheme="http://blog.wangpin.xyz/tags/pwa/"/>
    
      <category term="小程序" scheme="http://blog.wangpin.xyz/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="hybrid app" scheme="http://blog.wangpin.xyz/tags/hybrid-app/"/>
    
  </entry>
  
  <entry>
    <title>Wang Pin&#39;s 2018 总结 - thinking more，doing the best</title>
    <link href="http://blog.wangpin.xyz/2018/12/29/summary-of-2018/"/>
    <id>http://blog.wangpin.xyz/2018/12/29/summary-of-2018/</id>
    <published>2018-12-29T17:00:53.000Z</published>
    <updated>2021-03-03T03:11:45.835Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="跳出程序员的思维">跳出程序员的思维</span></h1><h2><span id="做出格的事">做“出格”的事</span></h2><p>很多人都曲解了【不在其位，不谋其政】的含义，包括曾经的我，觉得自己工作范畴之外的事情，都应该不闻不问，不理不睬。作为程序员，就应该专注于实现功能，提高效率，修复漏洞，至于客户需求，界面设计，等等，和技术无关的部分，就应该事不关己高高挂起。<br>但很多时候，事情并不是看上去那么简单。也许未经仔细确认的需求，会演化成无限膨胀不可制约的毒瘤；互相矛盾的设计语言，会将原本简单明了自解释的页面逻辑搅得乱七八糟。此时，迷茫的程序员们会痛恨产品经理，设计师，会怪罪公司。然而于事无补。<br><strong>所以，我现在偏好做“出格”的事情</strong>。</p><blockquote><p>要掌握一件东西，必须先了解它。</p></blockquote><p>要将需求的前前后后边边角角都捋清楚，才能在此之上构建足够明了的架构，函数，接口。同样的，要首先了解 UI 设计是怎么回事，才能据此来推导整个客户端界面所应该具备的风格，小到一个按钮应该如何反馈点击，大到复杂的界面如何响应不同尺寸的设备。<br>然后，<strong>必须去沟通</strong>。<br>得用产品经理的语言去和产品经理沟通，去阅读客户需求，去分析需求的含义，直到能彻底的掌握需求的本质。<br>得用设计师的语言去和设计师们沟通，去理解设计风格，去分析设计要素，直到看一眼他们的设计稿就能理解他们的设计诉求。<br>最后，<strong>还得学会关键对话</strong>。<br>当对方持有不同的观点时，努力平复情绪，理解，学习，持续沟通，直到双方达成共识。</p><p>当做的更多，往往就能看到更多，理解和包容更多。我看到产品经理在会议上面对即挑剔又无知的老板和客户时，无奈又疲惫；我看到设计师们面对繁重的设计任务和反复无常的经理时，一腔热血无法施展的辛酸。在往上，又能看到 vp 们的焦虑和无力。我一边看见，一边读书，尝试去分析，去感悟，然后静待成长。</p><h2><span id="看书">看书</span></h2><p>做出格的事情，除了准备好自己的大脑，随时从coding模式切换到日常模式以外，还得逐步构建自己的知识架构。看书是个好办法，当然前提是看好书，用心看。下面是我的（部分）书单。</p><ul><li>《品牌的起源》</li><li>《淘宝十年产品事》</li><li>《产品经理入门攻略》</li><li>《腾讯产品法》</li><li>《产品经理方法论》</li><li>《产品的视角：从热闹到门道》</li><li>《人人都是产品经理》</li><li>《破茧成蝶-用户体验设计师的成长之路》</li><li>《关键对话》</li></ul><p>作为业余放松，我也看小说。目前已读完的：</p><ul><li>《三体》</li><li>《大明1566》</li><li>《天龙八部》</li><li>《射雕英雄传》</li><li>《神雕侠侣》</li><li>《倚天屠龙记》</li><li>《碧血剑》</li><li>《鹿鼎记》</li><li>《连城诀》</li><li>《七种武器》</li></ul><p>在读和计划的：</p><ul><li>《冰与火之歌》</li><li>《哈利波特》</li><li>《书剑恩仇录》</li><li>《雪山飞狐》</li><li>《李自成》</li></ul><h2><span id="关于工程师和qa的思考">关于工程师和QA的思考</span></h2><p>当工程师的任务太繁重时，产品质量必然降低。那为了保证质量，应该招聘更多的工程师，这是很直接的思维。或者，招聘更多的QA来发现问题，然后请求工程师修复。后一种，好像也能解决问题，但是，他同时也将工程师和QA放在了对立的位置上。</p><p>在这样的管理方式下，整个项目组的人员演变，将变成：</p><ul><li>工程师任务太重，所以减少编写单元测试的时间</li><li>招聘QA来编写测试代码</li><li>工程师发现单元测试可有可无，于是不再写单元测试</li><li>招聘更多QA</li></ul><p>以上过程会无限循环，最终，会稳定为这种开发模式：工程师只写业务代码，基本不测试（自动或者手动），大量的QA辅助测试。随着业务代码的不断累计，问题也会越来越多并且难以简单重现，必须招聘越来越多的QA。同时，由于工程师数量少且任务重，随着项目越来越庞大， 产品迭代速度会越来越慢。</p><p>很不幸，我所在的项目组已经沦入这样的陷阱中。2018年我们招聘了 1 个开发，与之对应的，QA 为 3 个。</p><h1><span id="技术和创意">技术和创意</span></h1><h2><span id="server-render-和-pwa">server render 和 pwa</span></h2><p>spa（single page application）首屏渲染太慢，原因是它必须等待关键 js 文件下载完成并执行，而在执行的过程中，可能又会下载其他 css，图片，或者调用后台 api 获取构造页面的数据。这整个过程可能会耗时数秒。<br>server render 做这样的事情，在用户第一次访问时，在后台就准备好尽可能多的<strong>必须</strong>资源，一次返回给客户端，以加速首屏渲染效率。</p><p>pwa（progress web application）通过 server-worker 和 cache，将静态文件<strong>存储</strong>在本地，当再次启动 app 时，直接加载本地文件。由于本地文件加载0耗时，所以 pwa 能提供媲美原生应用的启动速度。</p><p>结合 spa 和 pwa，app 的<strong>启动速度</strong>将得到质的飞跃。</p><h2><span id="web-component">web component</span></h2><p>web component 提供了一组原生 api 以定制组件。目前，有一些领域已经开始在实践 web components，譬如<strong>微前端</strong>：用 web component 来业务模板，利用 shadow dom 天生的安全性来隔离数据和封装逻辑。</p><h2><span id="material-design">material design</span></h2><p>我的所有关于设计的初印象几乎都来自于 material design，由 google 某团队领导并推广的设计语言。从设计的门外汉，到现在可以对某些设计要素，如颜色，布局，动画，层次，等等，能够侃侃而谈，material design 功不可没。同时，它打开了一扇窗，通过丰富的站内索引，和不计其数的新鲜名词（对我而言），我得以了解以前完全陌生的领域，开始懂得鉴别美和丑。这一切，都是在不经意间，缓缓形成的。可能当时啃文档的时候，还有些觉得晦涩难懂，甚至痛苦，但现在想起来，却只有收获知识的喜悦。</p><h2><span id="创意">创意</span></h2><blockquote><p>没实现的创意，那只是脑洞<br>饭桌上，走廊里，或者办公室一角，我经常听到各种各样的奇思妙想，但100%不了了之。或因为本身的不切实际，或因为实现起来难于上天，或，更多的是，只是因为不愿意脏了手。</p></blockquote><p>世界上最轻松美妙的事，不过于高谈阔论，与之相对应的，最苦难的事，无非是身体力行。还好，我懂的不算太晚。我对一些创意，做了初步的规划。如下：</p><ol><li>hexo 主题 - remind<br><a href="https://baike.baidu.com/item/remind/10466250?fr=aladdin#5" target="_blank" rel="noopener">remind</a> 是一个魔兽争霸3选手的id，又名小凤凰，风格朴实的暗夜精灵选手。当时要给自己一个英文名，我不假思索，就选了 remind，即是向偶像致敬，也是来鞭策自己，永远勤恳踏实。我希望这个主题也能像它的名字一样，朴实，而又精致。</li><li>boli - local 资源文件编辑器<br>从入职 hp 的第一个项目起，就被国际化反复折腾 - 频繁的文件修改，低效的邮件沟通。翻译人员用 excel 保存修改意见，而我们用 json 文件保存最终结果。这中间的差别，再加上双方的沟通不畅，催生出来的质疑和职责，我至今记忆尤深。<br>但其实，问题十分简单 - 我们的思维方式和知识背景不一样。而解决问题的办法无非两种：统一思想，或者统一工具。私以为统一工具的难度较低。boli 就是这样的工具。我第一版的计划是做一个 editor。如果后续有需要，可以做云端。</li><li>更简单的私人博客<br>很多人从公共博客，比如cnblogs，转到私人博客，比如用 hexo 搭建，我觉得原因无非有下面几个：</li><li>想玩，比如我<br>2.想要自己的独立地址</li></ol><p>对于 2，如果让他们也经历 1 所不能避免的折腾：购买域名，备案，配置 ssl 证书，设置 dns，手动发布博文。那无疑是残忍的。那么，有什么办法能够即享受 2 的美好，又能避免 1 的折腾呢？这其中是不是隐含着一种商业模式呢？</p><p>（全文结束）</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;跳出程序员的思维&quot;&gt;跳出程序员的思维&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;span
        
      
    
    </summary>
    
    
      <category term="思考" scheme="http://blog.wangpin.xyz/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="总结" scheme="http://blog.wangpin.xyz/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="沟通能力" scheme="http://blog.wangpin.xyz/tags/%E6%B2%9F%E9%80%9A%E8%83%BD%E5%8A%9B/"/>
    
      <category term="职业发展" scheme="http://blog.wangpin.xyz/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>gulp 拾遗 (2) - 认识 glob</title>
    <link href="http://blog.wangpin.xyz/2018/12/26/gulp-series-2-glob/"/>
    <id>http://blog.wangpin.xyz/2018/12/26/gulp-series-2-glob/</id>
    <published>2018-12-26T17:05:16.000Z</published>
    <updated>2021-03-03T03:11:45.835Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="为什么要用-glob">为什么要用 glob</span></h1><p>gulp 的 <a href="https://gulpjs.com/docs/en/getting-started/creating-tasks" target="_blank" rel="noopener">task</a> 函数一般起自于 <a href="https://gulpjs.com/docs/en/api/src" target="_blank" rel="noopener">src</a> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'input/*.js'</span>)</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说， <strong>src</strong> API 根据输入参数（input/*.js），从文件系统中读取文件流（stream），从而进行后续的操作。src 函数的第一个输入参数称为 pattern，是一个 glob 语句。glob 语句类似于 unix shell 中描述文件的方式。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls ./input/*.js</span><br></pre></td></tr></table></figure><p>glob 语句很容易理解，比如上面的 input/<em>.js，表示 input 目录下（不包含子目录），扩展名为 js 的</em><em>所有</em>*文件。</p><p>如果想要自如的编写 gulp 脚本，掌握 glob 语句是必不可少的。事实上不只 gulp，其他构建工具如 webpack，也使用 glob 语句来匹配文件。我想原因无非有两个，一是因为 glob 语法非常简单，容易学习。另一方面， glob 借鉴了 unix/linux 中文件匹配的语法，而很多工程师都有 unix/linux 经验，学习成本很低。就像当年 android 使用 java 作为开发语言以至于收到很多 java 程序员的喜爱和支持。</p><h1><span id="node-glob">node-glob</span></h1><p>目前，glob 最好的实现应该是 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">node-glob</a>。下面是一个简单的例子，用于查找所有目录下的 js 文件。第一个参数称为 pattern，描述待匹配文件的路径特征；第二个参数是 options，提供一些增强的配置项，如配置工作目录，模式，排序规则，等等。第三个参数是回调函数。可以看到 glob 是异步函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// options is optional</span></span><br><span class="line">glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// files is an array of filenames.</span></span><br><span class="line">  <span class="comment">// If the `nonull` option is set, and nothing</span></span><br><span class="line">  <span class="comment">// was found, then files is ["**/*.js"]</span></span><br><span class="line">  <span class="comment">// er is an error object or null.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2><span id="pattern">pattern</span></h2><p>pattern 的类型是字符串或者字符串数组，每个字符串都可以包含以下几种关键字。</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">* 匹配 <span class="number">0</span> 或多个字符</span><br><span class="line">? 匹配 <span class="number">1</span> 个字符</span><br><span class="line">[...] 匹配一系列字符，比如 [a-z], [<span class="number">0</span><span class="number">-9</span>]。如果第一个字符是 ！ 或 ^， 则匹配不在其中的字符。比如 [^a-z] 匹配不是 a-z 之外的字符。</span><br><span class="line">!(<span class="built_in">pattern</span>|<span class="type">pattern</span>|<span class="type">pattern</span>) 匹配不符合所有 <span class="built_in">pattern</span> 的字符</span><br><span class="line">?(<span class="built_in">pattern</span>|<span class="type">pattern</span>|<span class="type">pattern</span>) 匹配 <span class="number">0</span> 或 <span class="number">1</span> 个符合其中一个 <span class="built_in">pattern</span> 的内容</span><br><span class="line">+(<span class="built_in">pattern</span>|<span class="type">pattern</span>|<span class="type">pattern</span>) 匹配 <span class="number">1</span> 或多个符合至少其中一个 <span class="built_in">pattern</span> 的内容</span><br><span class="line">*(a|<span class="type">b</span>|<span class="type">c</span>) 匹配 <span class="number">0</span> 或多个符合至少其中一个 <span class="built_in">pattern</span> 的内容</span><br><span class="line">@(<span class="built_in">pattern</span>|<span class="type">pat</span>*|<span class="type">pat</span>?erN) 匹配 <span class="number">1</span>个至少符合其中一个 <span class="built_in">pattern</span> 的内容</span><br><span class="line">** 两个星号匹配 <span class="number">0</span> 或多个目录</span><br></pre></td></tr></table></figure><p>上面的规则不算太复杂（相比正则表达式），但仍需要搭配一些练习才能掌握。</p><h2><span id="options">options</span></h2><p><a href="(https://gulpjs.com/docs/en/api/src#options)">options</a> 中的选项很多，拣几个常用的讲一下。</p><h3><span id="cwd">cwd</span></h3><p>cwd 表示当前工作目录（current work directory）。也就是 process.cwd()，也即使 nodejs 脚本的执行目录。什么意思呢？比如，有个文件 index.js，我们在 /home/wangpin 下执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/wangpin $ node index.js</span><br></pre></td></tr></table></figure><p>此时，cwd 是 /home/wangpin。<br>如果我们在 home 目录下启动 index.js：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home $ node wangpin/index.js</span><br></pre></td></tr></table></figure><p>此时，cwd 是 /home。</p><p>简单的说，** cwd 是我们运行脚本的目录，不是脚本的存放目录 **。</p><h3><span id="ignore">ignore</span></h3><p>设置一个 pattern 用于忽略某些文件。虽然有 ! 和 ^ 可以用来做 exclude，但总体来说， pattern 是用来做 include，在其中夹杂复杂的 exclude 规则会让整个 pattern 变得非常难以理解。更简单的办法是利用 ignore option 来设置过滤规则。即</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">files</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">pattern:</span> <span class="comment">include</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">files</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">ignore:</span> <span class="comment">exclude</span> <span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">files</span></span><br></pre></td></tr></table></figure><p>比如，选取 input 目录下的 js 文件，同时过滤掉 min.js 文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">glob(<span class="string">'./input/*.js'</span>, &#123;<span class="attr">ignore</span>: <span class="string">'./input/*.min.js'</span>&#125;)</span><br></pre></td></tr></table></figure><h1><span id="gulp-中的-glob">gulp 中的 glob</span></h1><p>gulp 并没有直接使用 node-glob，它自己做了很多的封装，创造出了 <a href="https://github.com/gulpjs/glob-stream" target="_blank" rel="noopener">glob-stream</a>，<a href="https://github.com/gulpjs/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a> 等一系列满足自身需求，同时也很有现实意义的库。gulp 的官方文档中队 vinyl 和 glob 也做了详细的阐释，请移步 <a href="https://gulpjs.com/docs/en/api/" target="_blank" rel="noopener">concepts</a>。</p><h1><span id="其他脚本中的-glob">其他脚本中的 glob</span></h1><p>编写任何涉及到文件检索的脚本，glob 都应该是首选。比如，我们想要将 dist 目录中的所有文件上传到 aws s3。如果用 fs api 生写，仅仅是遍历所有文件，就需要下面这一大段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalFiles = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">listFiles</span>(<span class="params">folder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readdirAsync(folder)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">        list = list.map(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> path.join(folder, f)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> files = list.filter(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fs.statSync(file).isFile()</span><br><span class="line">        &#125;)</span><br><span class="line">        totalFiles = totalFiles.concat(files)</span><br><span class="line">        <span class="keyword">let</span> folders = list.filter(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fs.statSync(file).isDirectory()</span><br><span class="line">        &#125;)</span><br><span class="line">          .map(<span class="function"><span class="keyword">function</span>(<span class="params">folder</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listFiles(folder)</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(folders)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> listFiles(src)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(totalFiles.map(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(file, src)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这还没有涉及复杂的 include 和 exclude 规则，已经是比较<strong>大</strong>的函数了。<br>如果用 glob 重构一下呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params">globs, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      glob(globs, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(files.filter(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fs.statSync(file).isFile()</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">files</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(files.map(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(file)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量减少的同时，复杂的include/exclude部分由专业的 glob 来负责。</p><h1><span id="总结">总结</span></h1><p>glob 是简单而强大的文件匹配库，gulp，webpack 等构架工具都使用它来简单化文件匹配工作，某种意义上来说它已经是文件匹配的事实标准。glob 也可以用于其他涉及文件匹配的应用场景，不必拘泥于已有的场合。</p><p>文中提到的库，文档，及相关资料地址。</p><ul><li><a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">node-glob</a></li><li><a href="https://gulpjs.com/docs/en/api/concepts" target="_blank" rel="noopener">gulp concepts</a></li><li><a href="https://gulpjs.com/docs/en/getting-started/explaining-globs" target="_blank" rel="noopener">gulp expaining globs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;为什么要用-glob&quot;&gt;为什么要用 glob&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;gulp 的 &lt;a href=&quot;https://gulpjs.com/docs/en/getting-started/creating-tasks&quot;
        
      
    
    </summary>
    
    
      <category term="gulp" scheme="http://blog.wangpin.xyz/tags/gulp/"/>
    
      <category term="前端工程" scheme="http://blog.wangpin.xyz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>gulp 拾遗 - nodejs/配置文件/环境变量</title>
    <link href="http://blog.wangpin.xyz/2018/12/20/gulp-series-1/"/>
    <id>http://blog.wangpin.xyz/2018/12/20/gulp-series-1/</id>
    <published>2018-12-20T14:38:57.000Z</published>
    <updated>2021-03-03T03:11:45.831Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="楔子">楔子</span></h2><p>最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth 登陆页，等等。说它们大，是因为麻雀虽小但也五脏俱全，用于开发和部署的脚本，模板引擎，乃至项目本身是用到的react全家桶，任何一个点单独拿出来，都是可以大说特说的话题。</p><p>当然，本文还是将话题限制在 <a href="https://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 方面。</p><p>负责过工程脚本的，对于 gulp，甚至在它之前的 <a href="https://gruntjs.com/" target="_blank" rel="noopener">grunt</a>，都不会太陌生。gulp 和 grunt 比较类似，但是 gulp 更简单易学。其他相关的名词如 <a href="http://browserify.org/" target="_blank" rel="noopener">browserfily</a>/<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>/<a href="https://rollupjs.org/guide/en" target="_blank" rel="noopener">rollup</a>/<a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a> ，它们的用途是管理资源，相对来说，比较偏应用层。而 gulp 和 grunt 着重于任务管理，比较偏底层。事实上，上述四个打包工具也都有 gulp 的插件。</p><h2><span id="nodejs">Nodejs</span></h2><p>编写任务函数的时候，经常要读写外部文件，这就免不了使用到 nodejs 的 <a href="https://nodejs.org/api/fs.html" target="_blank" rel="noopener">fs</a>（文件系统）模块。比如遍历文件夹，读取文件内容。相应的，文件路径的处理，离不开 <a href="https://nodejs.org/api/path.html" target="_blank" rel="noopener">path</a> 模块。<a href="https://nodejs.org/api/process.html" target="_blank" rel="noopener">process</a> 模块经常用于切换工作目录，读取命令行参数，终止进程，等等。</p><p>如果需要将资源文件（html/js/css/images等等）部署到服务器，比如 aws s3，或者阿里云文件服务器，就需要结合对应的sdk上传文件。通常，你还需要告知服务器，待上传文件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">mime type</a>，以便用户浏览器正确的解析你的文件。</p><p>如果还需要调用某些远端 api 来更新数据，那就要借助 <a href="https://github.com/request/request" target="_blank" rel="noopener">request</a> 或者 <a href="https://github.com/request/request-promise" target="_blank" rel="noopener">request-promise</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request(&#123;url, method, body&#125;)</span><br></pre></td></tr></table></figure><h2><span id="gulp-任务">gulp 任务</span></h2><p>从 gulp 4.x 开始，任务的编写方式变成定义function，如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deploy</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">exports.deploy = deploy</span><br></pre></td></tr></table></figure><p>而在此之前，编写任务使用下面的方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'deploy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>新的设计对自由度的提升很大，只要function的返回值是stream/promise/obserable，既可以当作一个合格的 task。这样，创建很多原子的 task，再通过各种方式串联/并联起来，构成各式符合需要的 task，就成了一件和 gulp 无关的事情。程序员可以专注于这些 task 的编写而不用顾及 gulp 本身的限制。我把这个变化称为以退为进，gulp 的作者们希望通过减少自己存在感的方式，来赢得更多的粉丝。事实上，这也一直是 gulp 的哲学。<strong>尽量少做，将自由留给用户</strong>。另一个领域也奉行这个原则的是 reactjs。</p><p>另一方面，gulp也在吸收自己社区优秀的设计，比如，gulp 也提供了串行(series)和并行(parallel)任务的原生支持, 不需要再借助第三方插件完成这两项工作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.series(task1, task2, ...)</span><br><span class="line">gulp.parallel(task1, task2, ...)</span><br></pre></td></tr></table></figure><h2><span id="配制文件">配制文件</span></h2><p>很多时候我们需要使用到外部配置文件。nodejs 对 json 友好，直接 require 就能获取 json 文件的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'config.json'</span>)</span><br></pre></td></tr></table></figure><p>json 文件简单易懂，但作为配制文件，表达力并不强。这个仔细分辨起来，对我来说比较困难。我想可能是因为 json 文件太冗杂：大量于数据无用的字符如花括号，双引号，逗号，影响阅读。目前，很多大型项目使用 yaml 来作为标准配置文件，包括 由 json 转 yaml 的 spring，默认使用 yaml 的 swagger，等等。</p><h2><span id="环境变量">环境变量</span></h2><p>有些关键/敏感信息的配置项不能硬写在文件中，比如数据库的用户名和密码。通常，运行环境会将这些信息配置在环境变量中，由我们的配置文件或者脚本自行读取。</p><p>本地开发一般也要维持这样的方式，即，从环境变量中读取配置数据，哪怕那个数据库就安装在本机上。这样是为了保证开发的配置方式和线上一致，避免低级错误。比如，有些程序员习惯直接修改配置文件，加入密码等敏感信息，如果这份修改不小心被提交到代码仓库，再被别有用心的人盗取，可能会引起严重的生产事故。因此，这些信息还是只存放在环境变量中的好。</p><p>有三种使用环境变量的方式：</p><ol><li>修改系统变量，好处是一次修改可多次使用，方便。缺点是多个项目使用同名不同值的变量（命名空间问题），引起冲突，而且，系统变量对所有应用程序开放，也不够安全。</li><li>在某个命令行中 export。好处是临时声明比较安全。缺点是每次新打开的命令行都需要重新 export，麻烦。</li><li>保存一份配置项在本地仓库。安全（可以设置较高的读权限），并且，规避了多个项目的命名冲突。比较流行的实现有 <a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a>。只需要在项目根目录添加 .env 文件并保存配置项，就可以将配置设置在进程里。</li></ol><p>综上，dotenv 是目前最好的方案。</p><h2><span id="总结">总结</span></h2><p>本文作为 gulp 系列的开篇，主要阐述下面几个观点。</p><ul><li>gulp 是基础的任务管理工具。</li><li>编写 gulp 脚本离不开 nodejs 的支持，常用模块有 fs，path，process 等。</li><li>gulp 4.x 的任务编写更加简洁可扩展。</li><li>使用 yaml  作为配置管理文件 。</li><li>使用 dotenv 为本地开发提供环境变量。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2&gt;&lt;span id=&quot;楔子&quot;&gt;楔子&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;最近一段时间，陆陆续续做了几个不大不小的前端项目。说它们小，是因为业务逻辑相对简单。事实上它们都不是独立的应用，而是围绕一个应用的周边设施。比如，邮件的 html 模板，OAuth
        
      
    
    </summary>
    
    
      <category term="gulp" scheme="http://blog.wangpin.xyz/tags/gulp/"/>
    
      <category term="前端工程" scheme="http://blog.wangpin.xyz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>译-构建微服务面临的挑战</title>
    <link href="http://blog.wangpin.xyz/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/"/>
    <id>http://blog.wangpin.xyz/2018/06/12/translate-Six-Challenges-Every-Organization-Will-Face-Implementing-Microservices/</id>
    <published>2018-06-12T10:30:51.000Z</published>
    <updated>2021-03-03T03:11:45.891Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://thenewstack.io/microservices-standardization-moving-monolith-microservices/" target="_blank" rel="noopener">https://thenewstack.io/microservices-standardization-moving-monolith-microservices/</a></p><h2><span id="六个问题">六个问题</span></h2><p>少量的微服务可以正常运行而不必过多干涉。而一旦程序规模上升，就像在其他任何系统中面临的问题一样，程序组织架构，人员配置，乃至资源分配，很小的问题也会被放大，以至于拖垮一个系统。</p><p>上个月的旧金山微服务实践峰会， 曾经供职于 Stripe 和 Uber 的工程师，<a href="https://www.linkedin.com/in/susan-fowler-263b6343/" target="_blank" rel="noopener">Susan Fowler-Rigetti</a> 福勒， 详细阐述了构建大规模微服务面临的 6 个问题。</p><h3><span id="组织架构">组织架构</span></h3><p><a href="http://www.melconway.com/Home/Conways_Law.html" target="_blank" rel="noopener">康威法则</a> 表示，软件公司的人员组织结构往往反映了他们在软件上架构。因此，当公司将传统的服务架构迁移到一个一个的微服务 – 然后他们马上就会拥有相应的一个个微服务团队。他们往往是相互孤立的，包括开发规范，实践经验等等有价值的信息都不能得到完全的共享。<br>“微服务工程师和团队变得和微服务本身一样”， 福勒说，“他们很擅长并且只擅长做自己的事情。” 这对于特定的一个团队是件好事，因为他们往往可以高效的处理事务。但是工程师转换到另一个团队会很困难。有些工程师反映说，换团队对于他们来说，更像是换了一个公司，因为工作方式完全不一样了。</p><h3><span id="更容易出错">更容易出错</span></h3><p><img src="29abad0d-screen-shot-2017-02-21-at-9.45.39-pm.png" alt="Alt text" title="optional title"><br>系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p><h3><span id="资源竞争">资源竞争</span></h3><p>对于微服务来说，硬件资源，工程师，都是稀缺并且昂贵的。比如，当硬件资源紧张时，购买更多的硬件，并不能立刻解决问题。或者，在系统规模比较小的时候可以起作用，但是当你的微服务数量很多，就很难通过这种简单方式扩展。</p><p>当系统中有数十甚至上百个微服务时，如何有限考虑某些更关键的微服务？哪些应该得到更多资源？谁来负责做这样的决定？ 这都是大型系统亟需解决的问题。</p><h3><span id="对微服务的误解">对微服务的误解</span></h3><p>很多人将微服务看做狂野西部 —— 你可以做任何你想做的事情，用任何你喜欢的技术，语言，数据库，等等，最终形成一个可以被其他服务调用的服务。这样操作的副作用很大，因为整个系统会充满无数各式各样不同版本的数据库，代码库。</p><p>另一个误解是将微服务视为银弹 —— 期望它会解决所有工程化方便遇到的难题。事实上，微服务应该是系统发展达到其扩展能力极限时，可以采用的一种方案。而不是摆脱工程难题的办法。</p><h3><span id="技术债务">技术债务</span></h3><p>当工程师们可以随心所欲的运用各种不同的技术，架构，脚本来构建差不多的微服务时，这意味着整个系统中会充满大量不确定的东西 —— 只有直接负责的工程师才知道他在代码里做了什么。一旦你需要修改这样的东西，重写是唯一的选择。</p><h3><span id="缺乏信任">缺乏信任</span></h3><p>微服务处于复杂的调用链之中，彼此依赖，但是由于缺乏工程规范和有效沟通，你可能很难确定其他微服务是可靠的。最终，你甚至没法衡量这些微服务可以在生产可靠工作。</p><h2><span id="解决办法">解决办法</span></h2><p>如果你的公司已经在采用微服务架构，以上问题可能并不新鲜。你更关心的一定是，如何解决以上问题呢?<br>第一，公司各个层面统一认识。标准化不仅仅是最佳实践，而是必须的原则。<br>第二，所有的微服务在架构，运营和组织标准上都遵循同样的原则，而不是某个或者某几个。这样我们才能确信所有的微服务都能提供可靠的服务。</p><h3><span id="需要标准化">需要标准化</span></h3><p><img src="d206b9c0-screen-shot-2017-02-21-at-9.39.57-pm-1024x408.png" alt="Alt text" title="optional title"><br>系统越大，越容易产生错误。当你的系统中有数千个微服务在运行，任何一个都有可能出错。</p><p>上面的图片来自福勒的分享。如图，微服务在第四层工作。其他的层次，都应该提供统一的抽象接口或者服务，以供微服务使用。这能够有效地限制技术债务问题。</p><blockquote><p>很多人认为微服务架构提供免费的无限扩展性，这是错的，你还需要做更多额外的工作来确保它的扩展性没有被破坏。</p></blockquote><p>其次，对于<strong>生产环境可用性</strong>达成共识。这应该成为工程师文化的一部分。很多时候，工程师将标准化看做一种障碍，但在微服务的世界里并不成立。任何微服务都不能损害整个系统的完整性和标准化。</p><h3><span id="production-ready-的微服务架构">production ready 的微服务架构</span></h3><ul><li>Stability</li><li>Reliability</li><li>Scalability</li><li>Performance</li><li>Fault-Tolerance</li><li>Catastrophe-Preparedness</li><li>Monitoring</li><li>Documentation</li></ul><h3><span id="稳定性和可靠性">稳定性和可靠性</span></h3><p>快速修改和部署是微服务最重要的两个话题，他们会影响微服务的稳定性。一个可靠的微服务，无论它如何被修改/部署，都不影响客户端，依赖它的所有其他服务，和它本身的生态系统。稳定性和可靠性通常是联系在一起的，稳定性的需求往往也是可靠性的需求。</p><p>任何软件产品在正式交付使用前总是要经过严格的测试，微服务也不列外，通常，我们在生产环境之前准备多个 stack 用于测试微服务，称为 <a href="http://www.thenewstack.io/tag/continuous-integration-and-deployment" target="_blank" rel="noopener">development pipeline</a>。</p><h3><span id="可扩展性和性能">可扩展性和性能</span></h3><p>当微服务增长到一定规模时，你必须考虑如何管理数据流量。有一些语言天生不具备有效的扩展性，比如不允许并发，分区，效率提升。用这些语言书写的服务很难扩展。（nodejs？）在系统设计的初期，应该避免使用这些语言。</p><p>可扩展性表示微服务可以处理多少请求，而性能表示如何处理这些请求。高性能服务可以更高效的利用资源，处理任务，高速处理用户请求。如何一个服务扩展性较差，未来会导致诸如服务中断急剧增加，最终导致可用性下降。</p><h3><span id="容错和灾难防护">容错和灾难防护</span></h3><p>为了确保可用性，工程师要保证即使微服务本身出错，整个系统不会因此而受损。工程师必须清楚的知道所有可能会导致故障的方式，并在出现故障时自动备份。</p><p>强大的弹性测试是成功应对灾难的关键。这包括代码测试，负载测试和其他主动测试中的混乱测试。每一种失败模式都应该投入生产环境，看看它是如何生存的。</p><p>鉴于微服务环境和复杂的依赖链的复杂性，失败是不可避免的。 微服务需要能够承受内部和外部故障。</p><h3><span id="监控">监控</span></h3><p>系统的状态瞬息万变，所以，使用监控工具使用检测系统的状态非常重要。不夸张的时候，缺乏有效监控是&quot;导致“系统瘫痪的第二大原因。监控能够提供实时的系统状态，运维人员可以据此来预测系统发展，以及防范和规避灾难。另一个相关的东西是日志。根据福勒的说法，日志是监控的重要组成部分。要知道发生了什么事情，那就只能去查阅事件发生时的日志。</p><h3><span id="文档">文档</span></h3><p>大部分的工程师都不喜欢写文档，但它非常重要。除了消除技术债务，它对于其他工程师快速切入新项目也非常重要。</p><h2><span id="更多内容">更多内容</span></h2><p><a href="https://www.amazon.com/Production-Ready-Microservices-Standardized-Engineering-Organization/dp/1491965975/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1487184502&amp;sr=1-1&amp;keywords=Production-Ready+Microservices" target="_blank" rel="noopener">Production-Ready Microservices</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;原文链接：&lt;a href=&quot;https://thenewstack.io/microservices-standardization-moving-monolith-microservices/&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
      <category term="micro service" scheme="http://blog.wangpin.xyz/tags/micro-service/"/>
    
  </entry>
  
  <entry>
    <title>ejs 入门</title>
    <link href="http://blog.wangpin.xyz/2018/02/02/get-started-ejs/"/>
    <id>http://blog.wangpin.xyz/2018/02/02/get-started-ejs/</id>
    <published>2018-02-02T13:21:32.000Z</published>
    <updated>2021-03-03T03:11:45.887Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="为什么要学习模板引擎">为什么要学习模板引擎</span></h2><p>在我年轻的时候，经常听长辈们前辈们说，先不要管是什么，集中精力狠狠地学一阵，自然能有所收获。在很长一段时间，我对这句话深信不疑并身体力行。说实话，在付出了比较可观的精力甚至财力之后，确实能有所收获。但也仅此而已，得到的很多知识和经验，往往并无太多实际意义。</p><p>随着年岁的增长，可支配的时间大幅度减少，同时精力也不如年轻时旺盛。原本粗放的学习方式显得更加不合时宜。所以，现在我更多的问自己，这个东西对我有用吗？再好的知识，如果对我的个人提升无用，那也是没有意义的。</p><p>回到本文主题，我之所以认为模板引擎很重要，原因无非是，它是一门收益极高的知识。它能将内容和html分离，想象这个特性的应用场景。假如有一个页面要给 20 个国家做国际化，那我们只需要准备 20 份 local 文件，一份模板，搭配对应的脚本，就能直接生成 20 个对应的 html 文件。 以后支持别的语言，也只需要新增 local 文件而已。如果这个项目的参与者不是程序员，那也没关系，他们所要关注的不是复杂多变的css和html，仅仅是 local 文件罢了。</p><p>即使现今 react/vuejs/angular 大行其道，模板引擎依然有它的用武之地。至少，这个星球上还有那么多站点依然是内容展示而非 webapp，而即便是 webapp 也有对应的一些内容页面，这些，都是模板引擎可以发光发热的舞台。</p><p>今天的主角是 ejs，开发者是大名鼎鼎的 tj。我的博客引擎 hexo 也默认支持 ejs 作为模板。</p><h2><span id="安装">安装</span></h2><p>ejs 是一个 js 模板引擎，语法简单，集成方便，被很多框架所使用。</p><p>通过 npm 安装：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> ejs -S</span><br></pre></td></tr></table></figure><p>也可以下载<a href="https://github.com/mde/ejs/releases/latest" target="_blank" rel="noopener">独立版本</a>。</p><h2><span id="基本语法要素">基本语法要素</span></h2><p>ejs 的语法比较简单： 初始化模板-&gt;加载数据-&gt;渲染</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str 模板内容，一般从 .ejs 模板文件读取</span></span><br><span class="line"><span class="comment">//options 一些配置，比如分隔符，缓存，debug 输出，等等</span></span><br><span class="line"><span class="keyword">var</span> template = ejs.compile(str, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//data 待渲染的数据</span></span><br><span class="line"><span class="keyword">var</span> html = template(data);</span><br></pre></td></tr></table></figure><p>如果不需要复用模板，可以直接生成 html</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ejs.render(str, data, options);</span><br></pre></td></tr></table></figure><p>实际的例子：<br>template.ejs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (user) &#123; %&gt;</span><br><span class="line">  &lt;h2&gt;&lt;%- user.name %&gt;&lt;/h2&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = fs.readFileSync(<span class="string">'template.ejs'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">'wangpin'</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> template = ejs.compile(str);</span><br><span class="line"><span class="keyword">var</span> result = template(data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>wangpin<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="标签">标签</span></h2><p>上面的 template 中，使用到 3 种标签。</p><ul><li>&lt;% 程序标签，控制流程，没有输出。比如这里的 if (user)</li><li>&lt;%- 输出标签，不做转义</li><li>%&gt; 结束标签</li></ul><p>还有其他 4 种类型，这里一一介绍。</p><ul><li>&lt;%= 输出标签，转义 html 字符，比如 &lt; &gt;</li><li>&lt;%# 注释，不输出任何内容</li><li>&lt;%% 输出 <strong>&lt;%</strong></li><li>-%&gt; 结束便签，并删除最近的一个空行</li></ul><h2><span id="包含-includes">包含 Includes</span></h2><p>模板可以引用另一个模板的内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% users.forEach(function(user)&#123; %&gt;</span><br><span class="line">    &lt;%- include(&apos;user/show&apos;, &#123;user: user&#125;); %&gt;</span><br><span class="line">  &lt;% &#125;); %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>两个要点：</p><ul><li>不能转义模板内容，所以这里<strong>必须</strong>使用 <strong>&lt;%-</strong>。</li><li>初始化父 template 的时候，options 中必须指定 filename。</li></ul><p>简单的例子：<br>subTemplate.ejs</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">user.hometown</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>template.ejs</p><figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">if</span> (user) &#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby"> user.name </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby"> <span class="keyword">include</span>(<span class="string">'./subTemplate'</span>, &#123;<span class="symbol">user:</span> user&#125;); </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure><p>test.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = fs.readFileSync(<span class="string">'template.ejs'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">'wangpin'</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">hometown</span>: <span class="string">'weinan'</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 指定 filename 为 template</span></span><br><span class="line"><span class="keyword">var</span> template = ejs.compile(str, &#123; <span class="attr">filename</span>: <span class="string">'template'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> result = template(data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>指定 filename 是为了在解析 include 的时候确定 subTemplate 的相对路径。</p><blockquote><p>Includes are relative to the template with the include call</p></blockquote><h2><span id="定制分隔符">定制分隔符</span></h2><p>默认使用的分隔符是 <strong>%</strong>, 如果想要换成其他字符，可以在全局，或者某个 template 上做单独的配置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>),</span><br><span class="line">    users = [<span class="string">'geddy'</span>, <span class="string">'neil'</span>, <span class="string">'alex'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just one template</span></span><br><span class="line">ejs.render(<span class="string">'&lt;?= users.join(" | "); ?&gt;'</span>, &#123;<span class="attr">users</span>: users&#125;,</span><br><span class="line">    &#123;<span class="attr">delimiter</span>: <span class="string">'?'</span>&#125;);</span><br><span class="line"><span class="comment">// =&gt; 'geddy | neil | alex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or globally</span></span><br><span class="line">ejs.delimiter = <span class="string">'$'</span>;</span><br><span class="line">ejs.render(<span class="string">'&lt;$= users.join(" | "); $&gt;'</span>, &#123;<span class="attr">users</span>: users&#125;);</span><br></pre></td></tr></table></figure><h2><span id="参考文档">参考文档</span></h2><p><a href="http://ejs.co/" target="_blank" rel="noopener">http://ejs.co/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2&gt;&lt;span
        
      
    
    </summary>
    
    
      <category term="前端工程" scheme="http://blog.wangpin.xyz/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="ejs" scheme="http://blog.wangpin.xyz/tags/ejs/"/>
    
      <category term="模板引擎" scheme="http://blog.wangpin.xyz/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>文件上传二三事</title>
    <link href="http://blog.wangpin.xyz/2015/11/20/about-file-upload-1/"/>
    <id>http://blog.wangpin.xyz/2015/11/20/about-file-upload-1/</id>
    <published>2015-11-20T18:05:52.000Z</published>
    <updated>2021-03-03T03:11:45.883Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="引子">引子</span></h1><p>其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。</p><p>–跟生孩子一样啊。</p><h1><span id="选择文件">选择文件</span></h1><p>谈到文件上传，不得不提 form，中文名叫表单。它可以包含一个用来选择文件的东东，叫做 file。</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> name=<span class="string">"uploadForm"</span> action=<span class="string">"/upload"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line"><span class="keyword">file</span>:&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"file"</span> name=<span class="string">"anyname"</span>/&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure><p>action 表示表单的数据发送的目标地址，method 表示发送表单所使用的 http 方法（get / post），enctype表示数据的编码方式，对于文件上传，必须为 <strong>_multipart/form-data</strong>_。</p><p>具体的定义参见 <a href="http://www.w3school.com.cn/tags/tag_form.asp" target="_blank" rel="noopener">form</a>。</p><p>下面是对应的页面，可以看到，有一个提示选择文件的按钮</p><p><img src="https://cloud.githubusercontent.com/assets/12655367/11392603/c82764be-9395-11e5-97d8-991e6ac51738.JPG" alt="file-upload"></p><p>点击按钮，就可以选择文件啦。</p><p><img src="https://cloud.githubusercontent.com/assets/12655367/11392669/2cf81a6e-9396-11e5-9d2a-d7d8832c92ed.gif" alt="choose-file"></p><ul><li>小贴士：文件选择好之后，可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="noopener">FileReader</a> 进行预览，或者简单的编辑。</li></ul><h1><span id="如何上传">如何上传</span></h1><p>简单的上传，只需要提交对应的 form 就可以了。是不是很简单，O(∩_∩)O哈哈哈~。</p><h1><span id="增强实现">增强实现</span></h1><p>上面介绍的都太简单粗暴肤浅了，实际项目中老板，客户100%会投反对票。因为实在是太简陋了。</p><h2><span id="美化选择按钮">美化选择按钮</span></h2><p>浏览器提供的原生控件实在是丑的不忍心看，可以自己画一个好看的按钮。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.chooseFile</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">106px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">29px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#B6E2C9</span>;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">font-family</span>: monospace;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得把原来的form隐藏掉。</p><p>接下来你需要做的是给这个按钮绑定 click listener ，当它被点击时，触发 form 中的 file 的 click 事件。</p><p><img src="https://cloud.githubusercontent.com/assets/12655367/11393543/2bdfbe8e-939b-11e5-8a35-055d02f06c4f.gif" alt="custom-choose"></p><h2><span id="不想刷新页面">不想刷新页面</span></h2><p>有些时候，希望上传时不刷新当前页面。但是使用 form 是避免不了页面刷新的。怎么办？</p><p>第一个想出这个办法的肯定是个头脑灵活的家伙–使用隐藏的 iframe 上传。</p><p>原理是，在当前页面（父页面）中添加 iframe，iframe 的页面（子页面）中包含 form 和相关的函数（验证，预处理等等）。当用户在父页面点击选择文件的按钮时，去触发子页面中 file 控件的 click 事件。</p><p>当用户提交时，提交子页面中的 form。这时，子页面跳转，而父页面没有刷新。</p><p>这个方案有个缺点，就是需要前后端协同工作。</p><p>当需要使用回调函数来处理上传完成后后端返回的数据时，需要和后端预先达成约定，如，回调函数名，参数列表，等等。这对前后端完全分离的开发场景(比如，你只是开发前端UI)是一个挑战。（出现全栈工程师的原因，是不是就是因为前端工程师想把这些依赖但是却又无法完全控制的工作给**_抢**_过来？）</p><p>比如，父页面须定义回调函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadSuccess</span> (<span class="params">result</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端须对action（上面form中定义的/upload）返回html，html包含对回调函数的调用，以及制定参数。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">window.uploadSuccess('xxxxxx');</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">sript</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当然，如果你是**<em>全栈工程师**</em>,这都不算事。自己一个人搞，还约定个啥。</p><h2><span id="formdataajax文件上传">FormData，ajax文件上传</span></h2><p>你说文件上传这么常见的功能，咋就不用直接用 js 搞定呢？ 非要牵扯什么 form，什么 iframe，烦？</p><p>客官，看来你需要的是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects" target="_blank" rel="noopener">FormData</a>。</p><p>FormData 允许通过 js 构造 form ，然后通过 ajax 方式上传。为了方便，这里使用 jquery 的 ajax。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'file'</span>, fileObj);</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/upload'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: data,</span><br><span class="line">    cache: <span class="literal">false</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    processData: <span class="literal">false</span>, <span class="comment">// Don't process the files</span></span><br><span class="line">    contentType: <span class="literal">false</span>, <span class="comment">// Set content type to false as jQuery will tell the server its a query string request</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line">          <span class="comment">//jqXHR may have no responseJSON in old jquery</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(jqXHR.responseJSON, <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，processData 必须指定为false，否则，jquery 会尝试格式化formData，这会引起一些错误。</p><p>一些低版本的浏览器可能对 FormData 没有提供支持，所以实际项目中要谨慎使用哦。</p><h1><span id="文件验证">文件验证</span></h1><p>有时候，我们需要对文件进行譬如大小，类型(通过扩展名)，名称的验证，只有符合预期的才允许上传。</p><h2><span id="前端">前端</span></h2><p>前端获取这三个属性非常简单。</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">file</span> = uploadForm.anyname.files[<span class="number">0</span>];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">file</span>.<span class="keyword">name</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">file</span>.<span class="built_in">size</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">file</span>.<span class="keyword">type</span>);</span><br></pre></td></tr></table></figure><p>更详细的介绍 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="noopener">file api</a></p><h2><span id="后端">后端</span></h2><p>相对前端来说，由于涉及到 http 报文的细节，所以稍微复杂一点(意思就是说，我讲的很有可能是片面的，错误的)。</p><p>http 报文，也就是你从浏览器的 network 调试窗口看到的 request 信息，它主要包括 header 和 body 两部分。header 中包含 content-length，也就是发送数据的长度，一般可以依次作为对文件大小的判断。如果后端检测到它大于预设的最大限制，则返回错误给前端。</p><p>http 的 body 部分会为上传文件的数据的开始和结尾插入边界，例如，chrome</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">------WebKitFormBoundarycKtZKQMmA6QfpeMW</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"file"</span>; filename=<span class="string">"bt.jpg"</span></span><br><span class="line">Content-<span class="keyword">Type</span>: image/jpeg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">------WebKitFormBoundarycKtZKQMmA6QfpeMW--</span></span><br></pre></td></tr></table></figure><p>并且，在文件内容之前，是文件的元数据，例如名词，类型，还有大小。</p><p>后端可以根据边界的检验，识别上传的文件，读取元数据中的文件属性，从而为验证提供数据。</p><p>有很多文件上传框架会将文件写入临时文件夹后，再做验证。其实是非常没有必要的。完全可以在 http 数据开头的一部分（数据并不是一起传送，而是类似于流的方式）抵达服务器时就完成验证，从而尽早的返回错误，避免不必要的数据操作（所谓优化–能不做，尽量不做。）。</p><h1><span id="为什么叫二三事">为什么叫二三事</span></h1><p>也许叫xxx大全会好一点，不过本人孤傲的不愿意拾人牙慧，只要叫做 二三事 了。所谓 <strong>_二三</strong>_，其实是一堆事。有叙述，有感叹，有建议。当然，也有吐槽。</p><h1><span id="后记">后记</span></h1><h2><span id="补充">补充</span></h2><ul><li>除了 file 表单，file对象还可以从拖拽事件中获取。</li></ul><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">e<span class="selector-class">.dataTransfer</span><span class="selector-class">.files</span></span><br></pre></td></tr></table></figure><ul><li>http body中，上传文件的边界可以由程序指定</li></ul><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">var boundary = 'fdfrefdrerefdfd';</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart/form-data, boundary="</span>+boundary); <span class="comment">// simulate a file MIME POST request.  </span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Length"</span>, fileSize);  </span><br><span class="line"></span><br><span class="line">var body = '';  </span><br><span class="line">body += <span class="string">"--"</span> + boundary + <span class="string">"\r<span class="subst">\n</span>"</span>;  </span><br><span class="line">body += <span class="string">"Content-Disposition: form-data; name=<span class="subst">\"</span>"</span>+dropbox.getAttribute('name')+<span class="string">"<span class="subst">\"</span>; filename=<span class="subst">\"</span>"</span> + fileName + <span class="string">"<span class="subst">\"</span>\r<span class="subst">\n</span>"</span>;  </span><br><span class="line">body += <span class="string">"Content-Type: "</span>+fileType+<span class="string">"\r<span class="subst">\n</span>\r<span class="subst">\n</span>"</span>;  </span><br><span class="line">body += fileData + <span class="string">"\r<span class="subst">\n</span>"</span>;  </span><br><span class="line">body += <span class="string">"--"</span> + boundary + <span class="string">"--\r<span class="subst">\n</span>"</span>;  </span><br><span class="line"></span><br><span class="line">xhr.sendAsBinary(body);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1&gt;&lt;span id=&quot;引子&quot;&gt;引子&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;其实很早就开始酝酿这一篇了，无奈总是发现有缺漏的地方，遂努力恶补前端+后端+底层相关知识。今天终于可以发表了。&lt;/p&gt;
&lt;p&gt;–跟生孩子一样啊。&lt;/p&gt;
&lt;h1&gt;&lt;span
        
      
    
    </summary>
    
    
      <category term="文件上传" scheme="http://blog.wangpin.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="http" scheme="http://blog.wangpin.xyz/tags/http/"/>
    
  </entry>
  
</feed>
