<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.0, shrink-to-fit=no, user-scalable=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="title" content="花萼横江"><meta name="sub title"><meta name="description" content="花萼横江"><meta name="key words"><meta name="author" content="王品"><meta name="language" content="zh-CN"><title>You need seamless-immutable to refactor your react app</title><link rel="stylesheet" type="text/css" href="/css/reset.css"><link rel="stylesheet" type="text/css" href="/css/index.css"><link rel="stylesheet" type="text/css" href="/css/nav.css"><link rel="stylesheet" type="text/css" href="/css/wigets.css"><link rel="stylesheet" type="text/css" href="/css/code.css"></head><body> <nav><div class="top-bar">花萼横江</div><label class="mobile-menu"><input type="checkbox"><div class="items"><a href="/">首页</a><a href="/about">关于</a><a href="/projects">项目</a><a href="/archives">归档</a></div><div class="overlap"></div></label></nav><section class="body"><article><header><h1><a href="/2019/07/04/You-need-seamless-immutable-to-refactor-your-react-app/">You need seamless-immutable to refactor your react app</a></h1><div class="metadata">创建于 2019年07月04日   最后一次更新于 2021-03-03 03:11</div></header><main><div class="summary">It's not a required skill for developing an app which writen in reactjs. If you are sure the state structure is simple enough and you are always be carefully while doing the mututation. However, if there is a piece of knowledge that make it easy and safe while developing an app, who not give it a chance?</div><div class="dividing-line"></div><h1><span id="说明-you-are-free-to-go-to-next-section-if-english-is-not-the-problem">说明 (You are free to go to next section if English is not the problem)</span></h1>
<p><strong>本文首发于 Medium，作者最近在练习英文写作，身在职场，谋生之技，请见谅</strong>。<br>
下面是简单的总结：<br>
对于 react app 来说，inmutable 并不一定是必须的。如果你的 state 比较简单，而且在更新 state 时足够小心，你能避免本文开始列出的问题。但是，如果有一种使用简单的技术能够让你从这种小心的节奏中解脱出来，让你专注于处理其他更有价值的问题，不是更好吗？</p>
<h1><span id="why-you-need-it">Why you need it?</span></h1>
<p>There are two major reasons why you need to use seamless-immutable in your react application.</p>
<ol>
<li>It’s a bad practice to update props inside the component because it leads to much more problems than your thoughts(It will be a big topic but now it’s known to all so I think I don’t need to explain that, at least in this article). So, from the tech point of view, <strong>immutable</strong>  is better.</li>
<li>To save the effort of differing props, the pure component does only compare the references of each property in props, called <strong>shallowly compares</strong>. If the references are the same, the re-render not happen. In using object or array we must very carefully to re-generate a new copy of them if the data changed. That’s the reason why <strong>spread</strong> operator is introduced by <strong>redux</strong> and is highlighted.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> SUCCESS:</span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, xxx &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Read more in <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">purecomponent</a></p>
<h2><span id="and-why-seamless-immutable">And why seamless-immutable?</span></h2>
<p><strong>seamless-immutable</strong> is a simple implementation of immutable. Less size of the bundle, less time you need to learn how to do mutation. And, the very great side is, you can visit the immutable data just like a primitive object/array. No more operators, grammar.</p>
<h1><span id="get-started">Get started</span></h1>
<h2><span id="how-to-create-the-immutable-copy-of-an-objectarray">How to create the immutable copy of an object/array?</span></h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable(object)</span><br><span class="line">Immutable(array)</span><br></pre></td></tr></table></figure>
<h2><span id="how-to-create-the-mutable-copyfor-easy-modification-without-using-replacesetmerge-methods-of-an-immutable-data">How to create the mutable copy(for easy modification without using replace/set/merge methods) of an immutable data?</span></h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable.asMutable(object)</span><br></pre></td></tr></table></figure>
<p>additional options:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Immutable.asMutable(object, &#123; <span class="attr">deep</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>This will create a mutable copy for each property(or elements in an array). That means all properties will be new in the mutable copy(If deep = true then all nested property will be new generated as well).  And that will leads to a performance issue in the application which has huge and complicated data because that react component will be re-render although it’s not necessary.</p>
<p>The better idea is to only mutate the property when it’s necessary. For example, there is an address list:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addrs = Immutable([</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"wangpin"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"mona"</span>, <span class="attr">children</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;</span><br><span class="line">])</span><br><span class="line"><span class="keyword">var</span> newAddrs = Immutable.set(addrs, <span class="number">0</span>, Immutable.merge(addrs[<span class="number">0</span>], &#123; <span class="attr">name</span>: <span class="string">'remind'</span>&#125;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Like somebody said, every coin has two sides: Use ‘asMutable’ is easy for usual modifications like what you did before involving the concept `immutable’, but it’s bad for performance(for the big app). Try to update the object carefully with the operators provided by immutable is hard a lot to beginners, but it’s good or required and much worth to do in a big app.</p>
</blockquote>
<h1><span id="so-lets-learn-how-to-update-it-as-little-as-possible">So let’s learn how to update it as little as possible</span></h1>
<p>They are <strong>merge</strong>, <strong>replace</strong>, <strong>set &amp; setIn</strong>, <strong>update &amp; updateIn</strong>, <strong>without</strong>.</p>
<ol>
<li>Only <strong>set &amp; setIn</strong> can be applied on both object and an array, others only work on an object.</li>
<li><strong>merge</strong>, <strong>replace</strong>, <strong>set &amp; setIn</strong> support additional parameters <strong>deep:true</strong> to perform a deep operation. Others don’t.</li>
</ol>
<p>ps. I will not introduced the method <strong>get</strong> and <strong>getIn</strong> since they are not about mutation.</p>
<h2><span id="merge">merge</span></h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">status</span>: <span class="string">"good"</span>, <span class="attr">hypothesis</span>: <span class="string">"plausible"</span>, <span class="attr">errors</span>: <span class="number">0</span>&#125;);</span><br><span class="line">Immutable.merge(obj, &#123;<span class="attr">status</span>: <span class="string">"funky"</span>, <span class="attr">hypothesis</span>: <span class="string">"confirmed"</span>&#125;);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;status: "funky", hypothesis: "confirmed", errors: 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">status</span>: <span class="string">"bad"</span>, <span class="attr">errors</span>: <span class="number">37</span>&#125;);</span><br><span class="line">Immutable.merge(obj, [</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">"funky"</span>, <span class="attr">errors</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">status</span>: <span class="string">"groovy"</span>, <span class="attr">errors</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">status</span>: <span class="string">"sweet"</span>&#125;]);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;status: "sweet", errors: 2&#125;)</span></span><br><span class="line"><span class="comment">// because passing an Array is shorthand for</span></span><br><span class="line"><span class="comment">// invoking a separate merge for each object in turn.</span></span><br></pre></td></tr></table></figure>
<h2><span id="replace">replace</span></h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = Immutable(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;, <span class="attr">c</span>: <span class="string">'test'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = Immutable.replace(obj1, &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="string">'test'</span>&#125;&#125;, &#123;<span class="attr">deep</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;a: &#123;b: 'test'&#125;&#125;);</span></span><br><span class="line">obj1 === obj2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">obj1.a === obj2.a</span><br><span class="line"><span class="comment">// returns true because child .a objects were identical</span></span><br></pre></td></tr></table></figure>
<h2><span id="set-amp-setin">set &amp; setIn</span></h2>
<p><strong>Only set &amp; setIn can be applied on an array</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">type</span>: <span class="string">"parrot"</span>, <span class="attr">subtype</span>: <span class="string">"Norwegian Blue"</span>, <span class="attr">status</span>: <span class="string">"alive"</span>&#125;);</span><br><span class="line">Immutable.set(obj, <span class="string">"status"</span>, <span class="string">"dead"</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;type: "parrot", subtype: "Norwegian Blue", status: "dead"&#125;)</span></span><br></pre></td></tr></table></figure>
<p>When called with an Immutable Array, the property parameter is the index to be changed:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array = Immutable([&quot;hello&quot;, &quot;world&quot;]);</span><br><span class="line">var mutatedArray = Immutable.set(array, 1, &quot;you&quot;);</span><br><span class="line"></span><br><span class="line">mutatedArray // [&quot;hello&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure>
<p>Like set, but accepts a nested path to the property.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">type</span>: &#123;<span class="attr">main</span>: <span class="string">"parrot"</span>, <span class="attr">sub</span>: <span class="string">"Norwegian Blue"</span>&#125;, <span class="attr">status</span>: <span class="string">"alive"</span>&#125;);</span><br><span class="line">Immutable.setIn(obj, [<span class="string">"type"</span>, <span class="string">"sub"</span>], <span class="string">"Norwegian Ridgeback"</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;type: &#123;main: "parrot", sub: "Norwegian Ridgeback"&#125;, status: "alive"&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = Immutable([[<span class="string">"one fish"</span>, <span class="string">"two fish"</span>], [<span class="string">"red fish"</span>, <span class="string">"blue fish"</span>]]);</span><br><span class="line"><span class="keyword">var</span> mutatedArray = Immutable.setIn(array, [<span class="number">1</span>, <span class="number">1</span>], <span class="string">"green fish"</span>);</span><br><span class="line"></span><br><span class="line">mutatedArray <span class="comment">// [["one fish", "two fish"], ["red fish", "green fish"]]</span></span><br></pre></td></tr></table></figure>
<h2><span id="update-amp-updatein">update &amp; updateIn</span></h2>
<p>Returns an Immutable Object with a single property updated using the provided updater function.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inc</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br><span class="line">Immutable.update(obj, <span class="string">"foo"</span>, inc);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: 2&#125;)</span></span><br></pre></td></tr></table></figure>
<p>All additional arguments will be passed to the updater function.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br><span class="line">Immutable.update(obj, <span class="string">"foo"</span>, add, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: 11&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>updateIn</strong> like <strong>setIn</strong> that it accetps a nested path to be property.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="keyword">var</span> obj = Immutable(&#123;<span class="attr">foo</span>: &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line">Immutable.updateIn(obj, [<span class="string">"foo"</span>, <span class="string">"bar"</span>], add, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// returns Immutable(&#123;foo: &#123;bar: 11&#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<h2><span id="without">without</span></h2>
<p>Returns an Immutable Object excluding the given keys or keys/values satisfying the given predicate from the existing object.</p>
<p>Multiple keys can be provided, either in an Array or as extra arguments.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, &quot;with&quot;);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, [&quot;will&quot;, &quot;with&quot;]);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, &quot;will&quot;, &quot;with&quot;);</span><br><span class="line">// returns Immutable(&#123;the: &quot;forests&quot;&#125;)</span><br><span class="line"></span><br><span class="line">var obj = Immutable(&#123;the: &quot;forests&quot;, will: &quot;echo&quot;, with: &quot;laughter&quot;&#125;);</span><br><span class="line">Immutable.without(obj, (value, key) =&gt; key === &quot;the&quot; || value === &quot;echo&quot;);</span><br><span class="line">// returns Immutable(&#123;with: &quot;laughter&quot;&#125;)</span><br></pre></td></tr></table></figure>
<h1><span id="summary-of-seamless-immutable">Summary of seamless-immutable</span></h1>
<ol>
<li><strong>asMutable</strong> is the easiest way to perform modification, but it harms performance sometimes.</li>
<li>All methods for mutating object/array returns a new immutable copy. If you have to perform more than one mutation on the data,  please make sure every mutation works on the newer copy.</li>
</ol>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">const original = Immutable(xxx)</span><br><span class="line">const <span class="keyword">new</span><span class="type">er1</span> = Immutable.replace(original, xxx)</span><br><span class="line">const <span class="keyword">new</span><span class="type">er2</span> = Immutable.replace(<span class="keyword">new</span><span class="type">er1</span>, xxx)</span><br></pre></td></tr></table></figure>
<p>Thanks for your reading.</p>
</main></article></section><footer><section class="links"> <a href="atom.xml"> <span class="icon" name="rss"></span></a><a href="https://github.com/wangpin34"> <span class="icon" name="github"></span></a><a href="https://hexo.io">Hexo</a></section><section class="copyright">© 2019 王品</section></footer></body></html>